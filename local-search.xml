<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Matlab学习笔记</title>
    <link href="/2021/08/31/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h2><ol><li><p><code>clear</code> 函数清理工作区。<code>clc</code> 命令清理<strong>命令行窗口</strong>。</p></li><li><p>使用 <code>format</code> 函数控制显示的精度：</p><p>输入 <code>format long</code> 显示更多小数。</p><p>输入 <code>format short</code> 可切换回默认显示。</p></li><li><p>使用 <code>:</code> 运算符并仅指定起始值和最终值。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">y = <span class="hljs-number">5</span>:<span class="hljs-number">8</span><br>y = <br>    <span class="hljs-number">5</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span>    <span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure></li></ol><p>运算符使用默认的间距 <code>1</code>，但是您可以指定您自己的间距，如下所示。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = <span class="hljs-number">20</span>:<span class="hljs-number">2</span>:<span class="hljs-number">26</span><br>x = <br>    <span class="hljs-number">20</span>    <span class="hljs-number">22</span>    <span class="hljs-number">24</span>    <span class="hljs-number">26</span><br></code></pre></div></td></tr></table></figure><p>如果您知道向量中所需的元素数目（而不是每个元素之间的间距），则可以改用 <code>linspace</code> 函数：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">linspace</span>(first,last,number_of_elements)<br></code></pre></div></td></tr></table></figure><ol start="4"><li>转置：x = x’</li></ol><p>您可以通过在一条命令中创建行向量并将其全部转置来创建列向量。注意此处使用圆括号来指定运算的顺序。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = (<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">5</span>)&#x27;<br>x = <br>    <span class="hljs-number">1</span><br>    <span class="hljs-number">3</span><br>    <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><ol start="5"><li><p><code>rand(2)</code> 命令中的 <code>2</code> 指定输出将为一个 2×2 的随机数矩阵。</p><p><code>rand(2,3)</code> 2 x 3矩阵</p></li><li><p>如何知道现有矩阵的大小？您可以使用 <code>size</code> 函数。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">size</span>(x)<br></code></pre></div></td></tr></table></figure><p>您也可以使用一行代码创建与现有矩阵大小相同的矩阵。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">rand</span>(<span class="hljs-built_in">size</span>(x))<br></code></pre></div></td></tr></table></figure><p><code>numel(y)</code>函数可以获得y中元素的个数</p></li><li><p>使用类似c语言的方式获得数组元素</p></li><li><p>用作索引时，冒号运算符 (<code>:</code>) 可指代该维度中的所有元素。以下语法</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = A(<span class="hljs-number">2</span>,:)<br>会创建一个包含A中第 <span class="hljs-number">2</span> 行上所有元素的行向量。<br></code></pre></div></td></tr></table></figure></li></ol><p>冒号运算符可以引用某个值范围。以下语法会创建一个包含矩阵 <code>A</code> 的第 1 行、第 2 行和第 3 行所有元素的矩阵。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = A(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,:)<br></code></pre></div></td></tr></table></figure><ol start="9"><li><p>单个索引值可用于引用向量元素。例如</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = v(<span class="hljs-number">3</span>)会返回向量 `v` 的第 <span class="hljs-number">3</span> 个元素<br></code></pre></div></td></tr></table></figure></li><li><p>您可以结合使用索引与赋值，将数组值更改为与其他元素相等。例如，以下代码将 <code>x(1)</code> 的值更改为 <code>x(2)</code> 的值：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x(<span class="hljs-number">1</span>) = x(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure></li><li><p>MATLAB 的设计让您能够自然地处理数组。例如，您可以将一个标量值与数组中的所有元素相加。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">y = x + <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>您可以将任意两个大小相同的数组相加。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z = x + y<br></code></pre></div></td></tr></table></figure><p>您可以将数组中的所有元素与某个标量相乘或相除。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z = <span class="hljs-number">2</span>*xy = x/<span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>MATLAB 的函数可在单个命令中对整个向量或值数组执行数学运算。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">xSqrt = <span class="hljs-built_in">sqrt</span>(x)<br></code></pre></div></td></tr></table></figure></li><li><p><code>*</code> 运算符执行<a href="http://www.mathworks.com/help/matlab/ref/mtimes.html">矩阵乘法</a>。因此，如果您使用 <code>*</code> 将两个大小相同的向量相乘，则由于内部维度不一致，您将会收到一条错误消息。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z = [<span class="hljs-number">3</span> <span class="hljs-number">4</span>] * [<span class="hljs-number">10</span> <span class="hljs-number">20</span>]<br></code></pre></div></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">错误使用  * 用于矩阵乘法的维度不正确。 <br></code></pre></div></td></tr></table></figure><p>而 <code>.*</code> 运算符执行按元素乘法，允许您将两个大小相同的数组的对应元素相乘。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z = [<span class="hljs-number">3</span> <span class="hljs-number">4</span>] .* [<span class="hljs-number">10</span> <span class="hljs-number">20</span>]<br></code></pre></div></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z =     <span class="hljs-number">30</span>    <span class="hljs-number">80</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>size</code> 函数可以应用于矩阵，以生成单个输出变量或两个输出变量。使用方括号 (<code>[ ]</code>) 获得多个输出。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">[xrow,xcol] = <span class="hljs-built_in">size</span>(x)<br></code></pre></div></td></tr></table></figure><p>可以使用 <code>max</code> 函数确定向量的最大值及其对应的索引值。<code>max</code> 函数的第一个输出为输入向量的最大值。执行带两个输出的调用时，第二个输出为索引值。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">[xMax,idx] = <span class="hljs-built_in">max</span>(x)<br></code></pre></div></td></tr></table></figure><p>可以使用波浪号字符 (<code>~</code>) 忽略特定输出。</p></li><li><p>您可以使用关系运算符将某个向量或矩阵与单个标量值进行比较。结果是与原始数组相同大小的逻辑数组。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">[<span class="hljs-number">5</span> <span class="hljs-number">10</span> <span class="hljs-number">15</span>] &gt; <span class="hljs-number">12</span><span class="hljs-built_in">ans</span> =     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>您可以使用逻辑数组作为数组索引，在这种情况下，MATLAB 会提取索引为 <code>true</code> 的数组元素。以下示例将会提取 <code>v1</code> 中大于 6 的所有元素。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">v = v1(v1 &gt; <span class="hljs-number">6</span>)v =    <span class="hljs-number">6.6678</span>    <span class="hljs-number">9.0698</span><br></code></pre></div></td></tr></table></figure><p>使用逻辑索引在数组中重新赋值。例如，如果您要将数组 <code>x</code> 中等于 <code>999</code> 的所有值都替换为值 <code>1</code>，请使用以下语法。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x(x==<span class="hljs-number">999</span>) = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="2-画图"><a href="#2-画图" class="headerlink" title="2. 画图"></a>2. 画图</h2><h3 id="2-1-plot函数"><a href="#2-1-plot函数" class="headerlink" title="2.1 plot函数"></a>2.1 plot函数</h3><ol><li><p>可以使用 <code>plot</code> 函数在一张图上绘制两个相同长度的向量。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(x,y)<br></code></pre></div></td></tr></table></figure></li><li><p><code>plot</code> 函数接受一个附加参数。使用该参数，您可以通过在引号中包含不同符号的方式来指定与之对应的颜色、线型和标记样式。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(x,y,<span class="hljs-string">&quot;r--o&quot;</span>)<br></code></pre></div></td></tr></table></figure></li></ol><p>   以上命令将会绘制一条红色 (<code>r</code>) 虚线 (<code>--</code>)，并使用圆圈 (<code>o</code>) 作为标记。您可以在<a href="http://www.mathworks.com/help/matlab/ref/linespec.html">线条设定</a>的文档中了解有关可用符号的详细信息。</p><ol start="3"><li><p>每个绘图命令都创建了一个单独的绘图。要在一张图上先后绘制两条线，请使用 <code>hold on</code> 命令保留之前的绘图，然后添加另一条线。</p><p>启用保留状态时，将继续在同一坐标区上绘图。要恢复默认绘图行为，即其中每个绘图都有自己的坐标区，请输入 <code>hold off</code>。</p><p>任务</p></li><li><p>单独绘制一个向量时，MATLAB 会使用向量值作为 y 轴数据，并将 x 轴数据的范围设置为从 <code>1</code> 到 <code>n</code>（向量中的元素数目）。</p></li><li><p><code>plot</code> 函数接受可选的附加输入，这些输入由一个属性名称和一个关联的值组成。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(y,<span class="hljs-string">&quot;LineWidth&quot;</span>,<span class="hljs-number">5</span>)<br></code></pre></div></td></tr></table></figure></li></ol><p>   以上命令将绘制一条粗线。您可以在<a href="https://www.mathworks.com/help/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">线条属性</a>文档中了解更多可用属性的详细信息。</p><p>   使用 <code>plot</code> 函数时，您可在绘图参数和线条设定符之后添加属性名称-属性值对组。</p>   <figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(x,y,<span class="hljs-string">&quot;ro-&quot;</span>,<span class="hljs-string">&quot;LineWidth&quot;</span>,<span class="hljs-number">5</span>)<br></code></pre></div></td></tr></table></figure><h3 id="2-2-其他函数"><a href="#2-2-其他函数" class="headerlink" title="2.2 其他函数"></a>2.2 其他函数</h3><ol><li><p>使用 <code>xlim</code> 函数放大所关注的区域。（在画图函数之后）</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">xlim([xmin xmax])例子：<span class="hljs-built_in">plot</span>(f,yfft)xlim([<span class="hljs-number">0</span> <span class="hljs-number">1000</span>])<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="2-3-在图像中添加注释"><a href="#2-3-在图像中添加注释" class="headerlink" title="2.3 在图像中添加注释"></a>2.3 在图像中添加注释</h3><ol><li><p>使用绘图注释函数（例如 <code>title</code>）在绘图中添加标签。</p><p>此类函数的输入是一个字符串。MATLAB 中的字符串是用双引号 (<code>&quot;</code>) 引起来的。</p></li></ol><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">title(<span class="hljs-string">&quot;Plot Title&quot;</span>)<br></code></pre></div></td></tr></table></figure><ol start="2"><li><p>使用 <code>ylabel</code> 函数给y轴添加标签 </p></li><li><p>使用 <code>legend</code> 函数为绘图添加图例。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">legend</span>(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>)<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="3-导入数据"><a href="#3-导入数据" class="headerlink" title="3.  导入数据"></a>3.  导入数据</h2><ol><li><p>要提取表变量，可以使用<em>圆点表示法</em>：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">data.VariableName<br></code></pre></div></td></tr></table></figure></li><li><p>您可以通过在实时脚本的输出窗格中点击表来与表进行交互。例如，您可以使用表的一个变量对表进行排序。<br><img src="https://matlabacademy-content.mathworks.com/4.30/R2021a/cn/content/Importing%20Data/Importing%20Data%20as%20a%20Table/images/sorttablesmall.jpg" alt="img"><br>在您对表感到满意时，您可以通过更新代码使更改永久化。</p></li><li><p>圆点表示法用于提取表变量。要提取行，可以使用常规数组索引。</p><p>尝试提取表的前三行：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">top3 = elements(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,:)<br></code></pre></div></td></tr></table></figure><p>请注意，<code>top3</code> 也是一个表。</p></li></ol><h1 id="MATLAB-入门之旅摘要"><a href="#MATLAB-入门之旅摘要" class="headerlink" title="MATLAB 入门之旅摘要"></a>MATLAB 入门之旅摘要</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/matlab_env/create-and-edit-variables.html"><code>x = pi</code></a></td><td align="center">使用等号 (<code>=</code>) 创建变量。 左侧 (<code>x</code>) 是变量的名称，其值为右侧 (<code>pi</code>) 的值。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/learn_matlab/calling-functions.html"><code>y = sin(-5)</code></a></td><td align="center">您可以使用括号提供函数的输入。</td></tr></tbody></table><h2 id="桌面管理"><a href="#桌面管理" class="headerlink" title="桌面管理"></a>桌面管理</h2><table><thead><tr><th align="center">函数</th><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/save.html"><code>save</code></a></td><td align="center"><code>save data.mat</code></td><td align="center">将当前工作区保存到 MAT 文件中。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/load.html"><code>load</code></a></td><td align="center"><code>load data.mat</code></td><td align="center">将 MAT 文件中的变量加载到工作区。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/clear.html"><code>clear</code></a></td><td align="center"><code>clear</code></td><td align="center">清除工作区中的所有变量。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/clc.html"><code>clc</code></a></td><td align="center"><code>clc</code></td><td align="center">清除命令行窗口中的所有文本。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/format.html"><code>format</code></a></td><td align="center"><code>format long</code></td><td align="center">更改数值输出的显示方式。</td></tr></tbody></table><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>4</code></td><td align="center">标量</td></tr><tr><td align="center"><code>[3 5]</code></td><td align="center">行向量</td></tr><tr><td align="center"><code>[1;3]</code></td><td align="center">列向量</td></tr><tr><td align="center"><code>[3 4 5;6 7 8]</code></td><td align="center">矩阵</td></tr></tbody></table><h2 id="等间距向量"><a href="#等间距向量" class="headerlink" title="等间距向量"></a>等间距向量</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>1:4</code></td><td align="center">使用<a href="https://www.mathworks.com/help/matlab/ref/colon.html">冒号 (<code>:</code>)</a> 运算符，创建一个从 <code>1</code> 到 <code>4</code>，间距为 <code>1</code> 的向量。</td></tr><tr><td align="center"><code>1:0.5:4</code></td><td align="center">创建一个从 <code>1</code> 到 <code>4</code>，间距为 <code>0.5</code> 的向量。</td></tr><tr><td align="center"><code>linspace(1,10,5)</code></td><td align="center">创建一个包含 <code>5</code> 个元素的向量。这些值从 <code>1</code> 到 <code>10</code> 均匀间隔。</td></tr></tbody></table><h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>rand(2)</code></td><td align="center">创建一个 <code>2</code> 行 <code>2</code> 列的方阵。</td></tr><tr><td align="center"><code>zeros(2,3)</code></td><td align="center">创建一个 <code>2</code> 行 <code>3</code> 列的矩形矩阵。</td></tr></tbody></table><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>A(end,2)</code></td><td align="center">访问最后一行的第二列中的元素。</td></tr><tr><td align="center"><code>A(2,:)</code></td><td align="center">访问第二行所有元素。</td></tr><tr><td align="center"><code>A(1:3,:)</code></td><td align="center">访问前三行的所有列。</td></tr><tr><td align="center"><code>A(2) = 11</code></td><td align="center">将数组中第二个元素的值更改为 <code>11</code>。</td></tr></tbody></table><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>[1 1; 1 1]*[2 2;2 2] ans =     4    4     4    4</code></td><td align="center">执行<a href="https://www.mathworks.com/help/matlab/matlab_prog/array-vs-matrix-operations.html#btyv9yp-4">矩阵乘法</a>。</td></tr><tr><td align="center"><code>[1 1; 1 1].*[2 2;2 2] ans =     2    2     2    2</code></td><td align="center">执行<a href="https://www.mathworks.com/help/matlab/matlab_prog/array-vs-matrix-operations.html#bu90xxy-1">按元素乘法</a>。</td></tr></tbody></table><h2 id="多个输出"><a href="#多个输出" class="headerlink" title="多个输出"></a>多个输出</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>[xrow,xcol] = size(x)</code></td><td align="center">将 <code>x</code> 中的行数和列数保存为两个不同变量。</td></tr><tr><td align="center"><code>[xMax,idx] = max(x)</code></td><td align="center">计算 <code>x</code> 的最大值及其对应的索引值。</td></tr></tbody></table><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>doc randi</code></td><td align="center">打开 <code>randi</code> 函数的文档页。</td></tr></tbody></table><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>plot(x,y,&quot;ro-&quot;,&quot;LineWidth&quot;,5)</code></td><td align="center">绘制一条红色 (<code>r</code>) 虚线 (<code>--</code>) 并使用圆圈 (<code>o</code>) 标记，线宽很大。</td></tr><tr><td align="center"><code>hold on</code></td><td align="center">在现有绘图中新增一行。</td></tr><tr><td align="center"><code>hold off</code></td><td align="center">为下一个绘图线条创建一个新坐标区。</td></tr><tr><td align="center"><code>title(&quot;My Title&quot;)</code></td><td align="center">为绘图添加标签。</td></tr></tbody></table><h2 id="使用表"><a href="#使用表" class="headerlink" title="使用表"></a>使用表</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>data.HeightYards</code></td><td align="center">从表 <code>data</code> 中提取变量 <code>HeightYards</code>。</td></tr><tr><td align="center"><code>data.HeightMeters = data.HeightYards*0.9144</code></td><td align="center">从现有数据中派生一个表变量。</td></tr></tbody></table><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>[5 10 15] &gt; 12</code></td><td align="center">将向量与值 <code>12</code> 进行比较。</td></tr><tr><td align="center"><code>v1(v1 &gt; 6)</code></td><td align="center">提取 <code>v1</code> 中大于 <code>6</code> 的所有元素。</td></tr><tr><td align="center"><code>x(x==999) = 1</code></td><td align="center">用值 <code>1</code> 替换 <code>x</code> 中等于 <code>999</code> 的所有值。</td></tr></tbody></table><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>if x &gt; 0.5    y = 3 else    y = 4 end</code></td><td align="center">如果 <code>x</code> 大于 <code>0.5</code>，则将 <code>y</code> 的值设置为 <code>3</code>。  否则，将 <code>y</code> 的值设置为 <code>4</code>。</td></tr><tr><td align="center"><code>for c = 1:3    disp(c) end</code></td><td align="center">循环计数器 (<code>c</code>) 遍历 值 <code>1:3</code>（<code>1</code>、<code>2</code> 和 <code>3</code>）。  循环体显示 <code>c</code> 的每个值。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="/2021/08/31/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="1-用-的个数来表示标题的大小"><a href="#1-用-的个数来表示标题的大小" class="headerlink" title="1.用#的个数来表示标题的大小"></a>1.用#的个数来表示标题的大小</h3><blockquote><p>Tips:标题的上下两行都必须是空行</p></blockquote><h3 id="2-表示下划线"><a href="#2-表示下划线" class="headerlink" title="2.表示下划线"></a>2.<u>表示下划线</u></h3><h3 id="3-—-表示分行符"><a href="#3-—-表示分行符" class="headerlink" title="3.—/***表示分行符"></a>3.—/***表示分行符</h3><blockquote><p>eg  </p></blockquote><hr><h3 id="4-创建脚注"><a href="#4-创建脚注" class="headerlink" title="4.创建脚注"></a>4.创建脚注</h3><h4 id="想要创建一个脚注类似这样-脚注"><a href="#想要创建一个脚注类似这样-脚注" class="headerlink" title="想要创建一个脚注类似这样[^脚注]"></a>想要创建一个脚注类似这样[^脚注]</h4><p>[^脚注]：这是我的第一个脚注</p><h3 id="5-代码的显示"><a href="#5-代码的显示" class="headerlink" title="5.代码的显示"></a>5.代码的显示</h3><ul><li>在段落中显示代码用``将其包围</li></ul><blockquote><p>eg.<code>printf(&quot;%d&quot;)</code>函数</p></blockquote><ul><li>使用```</li></ul><blockquote><p>eg.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> git<br></code></pre></div></td></tr></table></figure><h3 id="6-使用-表示列表-但是整篇文档只能使用一种符号"><a href="#6-使用-表示列表-但是整篇文档只能使用一种符号" class="headerlink" title="6.使用+/-/*表示列表(但是整篇文档只能使用一种符号)"></a>6.使用+/-/*表示列表(但是整篇文档只能使用一种符号)</h3><blockquote><p>eg:</p><ul><li>列表第一行</li><li>列表第二行<br><em>列表嵌套:</em> 子列表前面需要四个空格(一个Tab)  </li></ul></blockquote><p>eg:</p><ol><li>父列表<ul><li>子列表第一行</li><li>子列表第二行</li></ul></li></ol><h3 id="7-插入链接"><a href="#7-插入链接" class="headerlink" title="7.插入链接"></a>7.插入链接</h3><blockquote><p>eg. 这里有一个<a href="https://www.bing.com/">链接</a></p></blockquote><h3 id="8-插入图片"><a href="#8-插入图片" class="headerlink" title="8.插入图片"></a>8.插入图片</h3><blockquote><p>eg. 这里有一个图片<img src="..." alt="图片"></p></blockquote><h3 id="9-删除线"><a href="#9-删除线" class="headerlink" title="9.删除线"></a>9.删除线</h3><blockquote><p>eg. <del>这里没有删除线</del></p></blockquote><h3 id="10-如果要在列表项目内放进区块，那么就需要在-gt-前添加四个空格的缩进。"><a href="#10-如果要在列表项目内放进区块，那么就需要在-gt-前添加四个空格的缩进。" class="headerlink" title="10.如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。"></a>10.如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</h3><p>区块中使用列表实例如下：</p><ul><li><p>第一项</p><blockquote><p>啊哈<br>啊哈</p></blockquote></li><li><p>第二项</p></li></ul><h3 id="11-表格"><a href="#11-表格" class="headerlink" title="11.表格"></a>11.表格</h3><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><blockquote><p>语法格式如下：</p></blockquote><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><blockquote><p>我们还可以设置表格的<code>对齐方式</code></p></blockquote><ul><li>-: 设置内容和标题栏居右对齐</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ul><h3 id="12-输入公式"><a href="#12-输入公式" class="headerlink" title="12. 输入公式"></a>12. 输入公式</h3><h4 id="1-上下标"><a href="#1-上下标" class="headerlink" title="(1) 上下标"></a>(1) 上下标</h4><p>使用<code>^</code>表示上标, 用<code>_</code>表示下标.</p><ul><li>上下标有多个字符时. 要用<code>&#123; &#125;</code>括起来</li></ul><h4 id="2-求和-sum-下标-上标"><a href="#2-求和-sum-下标-上标" class="headerlink" title="(2) 求和 : $$\sum_{下标}^{上标}$$"></a>(2) 求和 : $$\sum_{下标}^{上标}$$</h4><p>公式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$$\sum_&#123;下标&#125;^&#123;上标&#125;$$<br></code></pre></div></td></tr></table></figure><ul><li><p>连乘将sum换成prod即可</p></li><li><p>若想要这种效果: $$\displaystyle\sum_{i=0}^{n}$$, 在<code>\sum</code>前加上<code>\displaystyle</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$$\displaystyle\sum_&#123;i=0&#125;^&#123;n&#125;$$<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="3-分式-根式"><a href="#3-分式-根式" class="headerlink" title="(3) 分式 根式"></a>(3) 分式 根式</h4><p>使用<code>\frac&#123;分子&#125;&#123;分母&#125;</code>来表示分式</p><p>使用<code>\sqrt[开方次数]&#123;被开方公式&#125;</code>来表示分式 </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记</title>
    <link href="/2021/08/31/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Part-1：语法"><a href="#Part-1：语法" class="headerlink" title="Part 1：语法"></a>Part 1：语法</h2><h3 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1. 关键字"></a>1. 关键字</h3><h4 id="lt-1-gt-static关键字"><a href="#lt-1-gt-static关键字" class="headerlink" title="&lt;1&gt; static关键字"></a>&lt;1&gt; static关键字</h4><h5 id="1-static修饰方法："><a href="#1-static修饰方法：" class="headerlink" title="(1) static修饰方法："></a>(1) static修饰方法：</h5><p>分为静态方法和非静态方法：</p><ul><li><p><strong>静态方法</strong>是在类中使用<code>staitc</code>修饰的方法，在类定义的时候已经被装载和分配。</p></li><li><p><strong>非静态方法</strong>是不加<code>static</code>关键字的方法，在类定义时没有占用内存，非静态方法只有在类被实例化成对象时，对象调用该方法才被分配内存.</p></li></ul><blockquote><p>注意: <strong>静态方法只能访问静态成员</strong>，<strong>实例方法可以访问静态和实例成员</strong>。</p><p>因为实例成员和变量属于某个对象的, 而静态方法在使用时,不一定存在对象, 所以不允许访问.</p></blockquote><p>调用静态方法可以<strong>无需创建对象</strong> </p><p>而调用实例方法则<strong>需要创建对象</strong></p><h5 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h5><ul><li>所有静态方法: <code> 类名.方法名</code></li><li>实例方法: <ul><li>当前类: <code>this.方法名 </code>(this可省略)</li><li>其他类:<code>对象名.方法名</code><ul><li>子类调用父类: <code>super.方法名</code></li></ul></li></ul></li></ul><h5 id="2-static修饰变量"><a href="#2-static修饰变量" class="headerlink" title="(2)static修饰变量"></a>(2)static修饰变量</h5><p>也称为<strong>静态变量</strong>。</p><ul><li><p>静态变量<strong>被所有对象共享</strong>，内存中只有<strong>一个副本</strong>，在<strong>类初次加载的时候</strong>才会初始化</p></li><li><p>非静态变量是<strong>对象所拥有的</strong>，在<strong>创建对象的时候</strong>被初始化，存在多个副本，各个对象拥有的副本互不影响</p></li><li><p>static不允许用来修饰局部变量</p></li></ul><blockquote><p>与C/C++中的static不同，Java中的static关键字<strong>不会影响到变量或者方法的作用域</strong></p><p>静态成员变量虽然独立于对象，但是<strong>不代表不可以通过对象去访问</strong>，所有的静态方法和静态变量<strong>都可以通过对象访问</strong>（只要访问权限足够）。</p></blockquote><h4 id="lt-2-gt-final-关键字"><a href="#lt-2-gt-final-关键字" class="headerlink" title="&lt;2&gt; final 关键字"></a>&lt;2&gt; final 关键字</h4><ul><li><p>声明类: 表示该类<strong>不能继承</strong>，即最终类；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<span class="hljs-comment">//类体&#125;</span><br></code></pre></div></td></tr></table></figure></li><li><p>声明方法: 表示该方法<strong>不能被子类重写</strong>, 即最终方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">修饰符(<span class="hljs-keyword">public</span>/<span class="hljs-keyword">protected</span>/<span class="hljs-keyword">default</span>/<span class="hljs-keyword">private</span>) <span class="hljs-keyword">final</span> 返回值类型 方法名()&#123;<span class="hljs-comment">//方法体&#125;</span><br></code></pre></div></td></tr></table></figure></li><li><p>声明变量: 表示该变量不可修改, 即最终变量</p></li></ul><h4 id="lt-3-gt-this-关键字"><a href="#lt-3-gt-this-关键字" class="headerlink" title="&lt;3&gt;this 关键字"></a>&lt;3&gt;this 关键字</h4><ul><li><p><code>this.属性名称</code>: 访问本类的成员变量, 用来区分成员变量和局部变量</p></li><li><p><code>this.方法名称</code>: 访问本类的成员方法</p><ul><li><p>特例: <code>this(参数)</code>: 访问本类的构造方法,但注意:</p><blockquote><p>1.不能在普通方法中使用, 只能写在构造方法中</p><ol start="2"><li>必须是构造方法的第一条语句</li></ol></blockquote></li></ul></li></ul><h3 id="2-修饰符"><a href="#2-修饰符" class="headerlink" title="2.修饰符"></a>2.修饰符</h3><p>public &gt; protected &gt; package &gt; private</p><h4 id="lt-1-gt-protected修饰符"><a href="#lt-1-gt-protected修饰符" class="headerlink" title="&lt;1&gt;protected修饰符"></a>&lt;1&gt;protected修饰符</h4><blockquote><p>被protected 修饰的成员对于<strong>本包和其子类</strong>可见</p></blockquote><p><strong>详解</strong>: protected的可见性在于:</p><ul><li>父类的 protected 成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例<strong>可以访问</strong>其从父类<strong>继承而来</strong>的protected成员（子类的），而<strong>不能访问</strong>父类实例的protected成员（父类的）。</li></ul><p>例子: 第9章作业题</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> homework.ch9.p1;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> homework.ch9.p2;<br><span class="hljs-keyword">import</span> homework.ch9.p1.A;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> A().j = <span class="hljs-number">10</span>;<span class="hljs-comment">//不同包中,父类的protected变量不可访问</span><br>        <span class="hljs-keyword">this</span>.j = <span class="hljs-number">10</span>;<span class="hljs-comment">//指当前类B的继承来的protected变量,可以访问</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-可变参数"><a href="#3-可变参数" class="headerlink" title="3.可变参数"></a>3.可变参数</h3><p>可变参数用类型<code>...</code>定义，可变参数<strong>相当于数组类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Group</span> </span>&#123;<br><span class="hljs-keyword">private</span> String[] names;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNames</span><span class="hljs-params">(String... names)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.names = names;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h3><h4 id="4-1-向上转型"><a href="#4-1-向上转型" class="headerlink" title="4.1 向上转型"></a>4.1 向上转型</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Person p= <span class="hljs-keyword">new</span> Student();<span class="hljs-comment">//Student是Person的子类</span><br>p是一个引用类型为Person，实际类型为Student的变量<br></code></pre></div></td></tr></table></figure><p>​        这种指向是允许的，因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。所以说，<code>Person</code>类型的变量<code>p</code>，指向<code>Student</code>类型的实例，对<code>p</code>做任何<code>Person</code>的操作, <code>Student</code>实例都能实现。</p><p>​        变量p指向的还是一个<code>Student</code>类型的实例对象，只是p的操作被局限在<code>Person</code> 所具有的内容中。</p><blockquote><p>与之相反的就是向下转型: 把父类类型强制转型为子类类型</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Student s=<span class="hljs-keyword">new</span> Person();<br></code></pre></div></td></tr></table></figure><p><strong>很可能会失败!</strong> 因为s为student类型的变量, 而<code>Person</code>很可能没有<code>Student</code>的部分内容。</p></blockquote><ul><li>从现实的角度来理解：一个Student，说他是个Person那肯定没错；但一个Person不一定是Student</li></ul><h4 id="4-2-多态"><a href="#4-2-多态" class="headerlink" title="4.2 多态"></a>4.2 多态</h4><p>由4.1中的例子，对于变量p，其实际类型为Student，而引用类型为Person，那么p.run()调用的是谁的方法？</p><p>答案是：<code>Student</code></p><p>这说明：Java的<em><strong>实例方法</strong></em>调用是<strong>基于运行时的实际类型</strong>的动态调用，<strong>而非变量的声明类型</strong>。　　　　（１）</p><p>这就是<strong>多态</strong></p><blockquote><p>多态的特性就是，<strong>运行期才能动态决定</strong>调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法</p><p>多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p></blockquote><ul><li>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用.</li></ul><h5 id="注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）"><a href="#注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）" class="headerlink" title="注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）"></a>注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）</h5><h4 id="4-3-抽象类"><a href="#4-3-抽象类" class="headerlink" title="4.3 抽象类"></a>4.3 抽象类</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类。</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。</p><p>即<code>Person</code>的子类必须覆写<code>run()</code>方法。</p><ul><li>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Person s = <span class="hljs-keyword">new</span> Student();<br>Person t = <span class="hljs-keyword">new</span> Teacher();<br></code></pre></div></td></tr></table></figure><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型。这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><h4 id="4-4-接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）"><a href="#4-4-接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）" class="headerlink" title="4.4 接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）"></a>4.4 接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）</h4><h5 id="4-4-1-定义"><a href="#4-4-1-定义" class="headerlink" title="4.4.1 定义"></a>4.4.1 定义</h5><p>​        所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p><p>​        当一个<code>class</code>去实现一个接口时, 使用<code>implement</code>关键字</p><p>​        与继承不同, 一个类只能继承自一个父类, 但一个类却能实现<strong>多个接口</strong></p><h5 id="4-4-2-接口继承"><a href="#4-4-2-接口继承" class="headerlink" title="4.4.2 接口继承"></a>4.4.2 接口继承</h5><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。</p><h5 id="4-4-3-default方法"><a href="#4-4-3-default方法" class="headerlink" title="4.4.3 default方法"></a>4.4.3 default方法</h5><p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(getName() + <span class="hljs-string">&quot; run&quot;</span>);    &#125;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="５-异常"><a href="#５-异常" class="headerlink" title="５.异常"></a>５.异常</h3><h4 id="5-1-抛出异常"><a href="#5-1-抛出异常" class="headerlink" title="5.1 抛出异常"></a>5.1 抛出异常</h4><p>抛出异常分两步：</p><ol><li>创建某个<code>Exception</code>的实例；</li><li>用<code>throw</code>语句抛出。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s==<span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    &#125;&#125;<br></code></pre></div></td></tr></table></figure><ul><li>JVM先执行<code>finally</code>中的语句, 再抛出异常; 但若<code>finally</code>中也抛出了异常, catch抛出的异常会被屏蔽。绝大多数情况下，在<code>finally</code>中不要抛出异常。若真有需求，使用<code>Throwable.addSuppressed()</code>, 具体自行百度.</li></ul><h4 id="5-2捕获异常"><a href="#5-2捕获异常" class="headerlink" title="5.2捕获异常"></a>5.2捕获异常</h4><p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明.</p><ul><li><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类。</p><ul><li>使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<strong>不再</strong>继续匹配。即：多个<code>catch</code>语句<strong>只有一个能被执行</strong>。所以顺序很重要，要把子类放前面。</li><li><code>try ... catch</code>还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。</li><li>catch语句和finally语句至少得有一个，可以理解为两个同级的出口</li></ul></li><li><p>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。</p><blockquote><p>某个方法抛出了异常时，若当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try ... catch</code>被捕获为止</p></blockquote><ul><li>调用方在调用这些方法的时候，必须强制捕获这些异常，否则编译器会报错。</li><li>我们也可以不捕获它，而是在调用了这些方法的方法定义处加上<code>throws xxx</code></li></ul></li><li><p>可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在<strong>更高的调用层捕获</strong>。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会。</p><p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>。</p><blockquote><p>因为<code>main()</code>方法声明了可能抛出<code>Exception</code>，也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p></blockquote></li><li><p>所有异常都可以<strong>调用<code>printStackTrace()</code>方法打印异常栈</strong>，这是一个简单有用的快速打印异常的方法。</p></li></ul><h4 id="5-3-最常见的NullPointerException"><a href="#5-3-最常见的NullPointerException" class="headerlink" title="5.3 最常见的NullPointerException"></a>5.3 最常见的NullPointerException</h4><p>好的编码习惯可以极大地降低<code>NullPointerException</code>的产生:</p><ol><li>成员变量在定义时初始化：</li></ol><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name = <span class="hljs-string">&quot;&quot;</span>;&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li><p>使用空字符串<code>&quot;&quot;</code>而不是默认的<code>null</code>可避免很多<code>NullPointerException</code>.</p></li><li><p>返回空字符串<code>&quot;&quot;</code>、空数组而不是<code>null</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">public <span class="hljs-keyword">String</span>[] readLinesFromFile(<span class="hljs-keyword">String</span> <span class="hljs-keyword">file</span>) &#123;    <span class="hljs-keyword">if</span> (getFileSize(<span class="hljs-keyword">file</span>) == <span class="hljs-number">0</span>) &#123;        // 返回空数组而不是null:        <span class="hljs-keyword">return</span> new <span class="hljs-keyword">String</span>[<span class="hljs-number">0</span>];    &#125;    ...&#125;<br></code></pre></div></td></tr></table></figure><p>这样可以使得调用方无需检查结果是否为<code>null</code>。</p></li></ol><blockquote><p> 如果调用方一定要根据<code>null</code>判断，比如返回<code>null</code>表示文件不存在，那么考虑返回<code>Optional&lt;T&gt;</code></p></blockquote><p><strong>定位NullPointerException</strong></p><p>可以启用Java 14的增强异常信息来查看<code>NullPointerException</code>的详细错误信息。</p><p>这种增强的<code>NullPointerException</code>详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个<code>-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java -XX:+ShowCodeDetailsInExceptionMessages Main.java<br></code></pre></div></td></tr></table></figure><h3 id="6-I-O"><a href="#6-I-O" class="headerlink" title="6.I/O"></a>6.I/O</h3><p>Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符</p><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl">// 假设当前目录是C:\DocsFile f1 = new File(<span class="hljs-string">&quot;sub\\javac&quot;</span>); <span class="hljs-regexp">//</span> 绝对路径是C:\Docs\<span class="hljs-function"><span class="hljs-keyword">sub</span>\<span class="hljs-title">javacFile</span> <span class="hljs-title">f3</span> = <span class="hljs-title">new</span> <span class="hljs-title">File</span></span>(&quot;.\\<span class="hljs-keyword">sub</span>\\javac&quot;); // 绝对路径是C:\Docs\<span class="hljs-function"><span class="hljs-keyword">sub</span>\<span class="hljs-title">javac</span></span><br></code></pre></div></td></tr></table></figure><p>可以用<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p><h3 id="7-覆写clone（）"><a href="#7-覆写clone（）" class="headerlink" title="7.覆写clone（）"></a>7.覆写clone（）</h3><h4 id="7-1-List深拷贝"><a href="#7-1-List深拷贝" class="headerlink" title="7.1 List深拷贝"></a>7.1 List深拷贝</h4><p><a href="https://blog.csdn.net/DeMonliuhui/article/details/54572908">看这里</a></p><h3 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h3><h3 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8. 泛型"></a>8. 泛型</h3><h4 id="8-1-使用通配符"><a href="#8-1-使用通配符" class="headerlink" title="8.1 使用通配符"></a>8.1 使用通配符</h4><h5 id="1-extends"><a href="#1-extends" class="headerlink" title="1. extends"></a>1. extends</h5><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p><h5 id="2-super"><a href="#2-super" class="headerlink" title="2. super"></a>2. super</h5><p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p><ul><li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li><li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li></ul><p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p><p>换句话说，使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p><h5 id="3-PECS-原则"><a href="#3-PECS-原则" class="headerlink" title="3. PECS 原则"></a>3. PECS 原则</h5><p>ECS原则：Producer Extends Consumer Super。</p><p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p><h4 id="8-2-擦拭法"><a href="#8-2-擦拭法" class="headerlink" title="8.2 擦拭法"></a>8.2 擦拭法</h4><p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code>int</code>；</li><li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li></ul><h3 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="# 零碎知识点"></a># 零碎知识点</h3><h5 id="（1）既对字段进行初始化，又在构造方法中对字段进行初始化："><a href="#（1）既对字段进行初始化，又在构造方法中对字段进行初始化：" class="headerlink" title="（1）既对字段进行初始化，又在构造方法中对字段进行初始化："></a>（1）既对字段进行初始化，又在构造方法中对字段进行初始化：</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;Unamed&quot;</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age =<span class="hljs-number">10</span>;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;            <span class="hljs-keyword">this</span>.name=name;            <span class="hljs-keyword">this</span>.age=age;        &#125;        &#125;<br></code></pre></div></td></tr></table></figure><p><strong>Q:</strong> 当我们创建对象的时候，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>得到的对象实例，字段的初始值是啥？</p><p>**A: **在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p><ol><li><p>先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；</p></li><li><p>执行构造方法的代码进行初始化。</p></li></ol><p>因此，构造方法的代码由于后运行，所以，new Person(“Xiao Ming”, 12)的字段值最终由构造方法的代码确定。</p><h5 id="（2）增强for循环（for-each）"><a href="#（2）增强for循环（for-each）" class="headerlink" title="（2）增强for循环（for each）"></a>（2）增强for循环（for each）</h5><p>增强for循环不会修改原数组的值</p><blockquote><p>因为每一次loop你只是获得了当前元素的值，却没有获得当前元素在数组中的对象句柄。这样就无法直接操作对应的句柄。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] s=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v: s)&#123;    ++v;&#125;<span class="hljs-comment">//s数组的值不会变化!</span><br></code></pre></div></td></tr></table></figure><blockquote><p>想遍历数组并只想获得元素值的时候才用for-each</p><p>其他的时候比如想修改数组，或者想获得index的时候就别用for-each</p></blockquote><h5 id="（3）字符串相加"><a href="#（3）字符串相加" class="headerlink" title="（3）字符串相加"></a>（3）字符串相加</h5><ul><li><p><strong>都是静态字符串</strong>的结果会添加到字符串池;</p></li><li><p>如果其中<strong>含有变量</strong>则<strong>不会</strong>进入字符串池中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;Hello&quot;</span>;String b = a+<span class="hljs-string">&quot;world&quot;</span>;    <span class="hljs-comment">//含有变量a，不会进入String c = &quot;Hello&quot;+&quot; world&quot;;//进入常量池String d = &quot;Hello world&quot;;//c==d, 但b不等于d//注意，final修饰的字符串当作静态字符串来看，不是变量final String s1=&quot;Hello&quot;;final String s2=&quot; world&quot;;s1+s2==d;//结果为ture</span><br></code></pre></div></td></tr></table></figure></li><li><p>字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。</p></li></ul><h2 id="Part-2：Tips"><a href="#Part-2：Tips" class="headerlink" title="Part 2：Tips"></a>Part 2：Tips</h2><h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h4><blockquote><p>多行注释和单行注释与c相同 </p></blockquote><h5 id="文档注释-可以使用javadoc提取注释-自动形成API文档"><a href="#文档注释-可以使用javadoc提取注释-自动形成API文档" class="headerlink" title="文档注释: 可以使用javadoc提取注释, 自动形成API文档"></a>文档注释: 可以使用<code>javadoc</code>提取注释, 自动形成API文档</h5><p>点击<code>Tools</code> -&gt; <code>Generate JavaDoc</code> 选择output 文件夹为doc目录(需要新建)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">特点:第一个斜杠后两个*注释对象:紧跟其后的代码块<span class="hljs-comment">/**注释内容   注释内容*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>&#123;    xxx&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>形成写文档注释的习惯</p></blockquote><h4 id="2-注意import"><a href="#2-注意import" class="headerlink" title="2. 注意import"></a>2. 注意import</h4><h2 id="Part-3：IDE及命令行"><a href="#Part-3：IDE及命令行" class="headerlink" title="Part 3：IDE及命令行"></a>Part 3：IDE及命令行</h2><h3 id="一、Idea的使用"><a href="#一、Idea的使用" class="headerlink" title="一、Idea的使用"></a>一、Idea的使用</h3><h4 id="1-基本流程"><a href="#1-基本流程" class="headerlink" title="1. 基本流程"></a>1. 基本流程</h4><p><code>new project</code> -&gt; <code>在src下创建一个package</code> -&gt; <code>在package下创建class</code>  </p><blockquote><p>在项目文件夹下创建一个bin目录, 用于存放编译成功的.class文件</p><p>创建后需要到<code>File</code> -&gt; <code>Project Structure</code> 中修改<code>Project compiler output</code></p></blockquote><h4 id="2-奇技淫巧"><a href="#2-奇技淫巧" class="headerlink" title="2. 奇技淫巧"></a>2. 奇技淫巧</h4><h5 id="2-1-生成弹出对话框"><a href="#2-1-生成弹出对话框" class="headerlink" title="2.1 生成弹出对话框"></a>2.1 生成弹出对话框</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.swing.JOp<br></code></pre></div></td></tr></table></figure><h3 id="二、命令行的使用"><a href="#二、命令行的使用" class="headerlink" title="二、命令行的使用"></a>二、命令行的使用</h3><h4 id="1-注意"><a href="#1-注意" class="headerlink" title="1. 注意"></a>1. 注意</h4><ul><li><p>在使用<code>javac</code> 编译时, shell目前所处的目录应为package的顶级目录,即<code>src</code>目录</p><p>例如：package名为 homework.ch1, 则在该目录系统中, class文件夹就相当于 src文件夹</p><ul><li>文件的目录结构如下：<img src="C:\Users\池炜恒\AppData\Roaming\Typora\typora-user-images\image-20210305163509008.png" alt="image-20210305163509008"></li></ul><p>​        那么 shell所处的目录应为：./chapter1/class</p><p>​    </p><ul><li><p>运行Welcome.class时, 类名要打全! 要带上package名,这样jvm才找得到</p><blockquote><p>这是因为JVM只看完整类名 , 编译器编译出的class文件也只使用完整类名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$  java homework.ch1.Welcome<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><h2 id="Part-4-：作业知识点"><a href="#Part-4-：作业知识点" class="headerlink" title="Part 4 ：作业知识点"></a>Part 4 ：作业知识点</h2><h4 id="4-1-chapter-2-3"><a href="#4-1-chapter-2-3" class="headerlink" title="4.1 chapter 2-3"></a>4.1 chapter 2-3</h4><ol><li><p>switch 语句的判断条件expression的计算结果只能是__不大于int__的类型</p></li><li><p>Java源程序经过编译后生成被称为 <strong>字节码</strong> 的特殊机器语言码</p></li><li><p>&amp;&amp;为条件逻辑运算符，&amp;为无条件逻辑运算符，有区别</p></li><li><p>Java中所有的方法都__必须在类内定义__</p></li><li><p>一些规则:</p><ul><li><p>一个源文件中__只能有一个public类__。</p></li><li><p>一个源文件__可以有多个非public类__。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span></span>&#123; <span class="hljs-comment">//只能有一个public class,且该文件必须命名为C1.java    ...&#125;class C2 &#123;&#125;final class C3&#123;&#125;...//可以有任意个 class</span><br></code></pre></div></td></tr></table></figure></li><li><p>源文件的名称应该__和public类的类名保持一致__。例如：源文件中public类的类名是Employee，那么源文件应该命名Employee.java。</p></li><li><p>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</p></li><li><p>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</p></li></ul></li><li><p>java标识符__严格区分大小写__, __不能__以数字开头</p></li></ol><h4 id="4-2-Chapter-4-5"><a href="#4-2-Chapter-4-5" class="headerlink" title="4.2 Chapter 4-5"></a>4.2 Chapter 4-5</h4><ol><li><p>字符串函数：</p><ul><li><p>indexof(): 返回某个字符串在字符串中<strong>首次出现</strong>的位置，从0开始计数（用数组下标理解）</p></li><li><p>lastIndexof(): <strong>最后一次</strong>出现的位置</p><ul><li><p><strong>public int lastIndexOf(int ch):</strong> 返回指定字符在此字符串中<strong>最后一次</strong>出现处的索引，如果此字符串中没有这样的字符，则<strong>返回 -1</strong>。</p></li><li><p><strong>public int lastIndexOf(int ch, int fromIndex):</strong> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行<strong>反向搜索</strong>，如果此字符串中没有这样的字符，则返回 -1。</p><blockquote><p>fromIndex: 开始搜索的索引位置</p></blockquote></li></ul></li><li><p>substring(): 用于截取字符串的一部分，返回新字符串</p><ul><li>substring(0,11): 表示0-<strong>10</strong>的子串</li><li>substring(11): 表示从11-末尾的子串</li></ul></li></ul><blockquote><p>注意: 字符串函数中,若参数为(int, int), 如substring(0,11),则一般为数组下标0 - <strong>(11-1)<strong>的字符的范围, 即</strong>不含后一个参数</strong>的范围</p><p>如何理解? </p><p>非常容易。可以把这两个数字看成地址，地址0-1之间的内存储存第一个字符，那么显然0-11的地址范围不包括位置11上的字符</p><p>可以用下图理解，可以看到insert将字符串插在了地址8的位置，即数组下标8的位置</p><p><img src="C:\Users\池炜恒\AppData\Roaming\Typora\typora-user-images\image-20210314105209855.png" alt="image-20210314105209855"></p></blockquote><ul><li>int length(): 返回字符串的长度，（字符数）</li><li>concat(String s): 将s连接到当前字符串上</li><li>清空StringBuffer s：s.delete(0,length()-1);  或者  s.setLength(0);</li></ul></li></ol><h4 id="4-3-Chapter-6-7"><a href="#4-3-Chapter-6-7" class="headerlink" title="4.3 Chapter 6-7"></a>4.3 Chapter 6-7</h4><ol><li><p><code>length</code>和<code>length()</code>是不同的</p><ol><li>length用于求<strong>数组</strong>的长度, 即数组元素个数 </li><li>length()用于求<strong>字符串对象</strong>的长度</li></ol></li><li><p>数组声明和初始化语句</p><ul><li><p><code>int a[]=null</code>等效于<code>int[] b=&#123;&#125;</code>;</p></li><li><p><code>int[] c=&#123;1,2,3,4&#125; </code>等效于<code>int[] c</code>= new <strong>int[]</strong>{1,2,3,4} </p><p><strong>注意：</strong>此处<code>new int[]</code>的<code>[]</code>不能少！</p><p>int[ ] c=new int{1,2,3,4} 错误!</p></li><li><p>int[ ] d[ ]=new int[5][ ]</p></li></ul></li><li><p>判断：局部变量在使用前必须通过初始化或者赋值语句显式地给一个值。( √ )</p><p>原因：<strong>局部变量必须初始化</strong>,而类的成员变量有默认值0,不用初始化</p><blockquote><p>注意: 成员变量和局部变量<strong>不同</strong>! 区别如下: </p></blockquote><p>**1.在类中的位置不同 **</p><p>成员变量: 在类中, 方法外</p><p>局部变量: 在方法中, 代码块, 或形参列表中</p><p><strong>2.在内存中的位置不同</strong></p><p>成员变量: 堆中(与<strong>对象</strong>共存亡)</p><p>局部变量: 栈中(与<strong>方法调用或代码块的执行</strong>共存亡)</p><p><strong>3.初始值</strong></p><p>成员变量: 有默认初始值</p><p>局部变量: 没有默认初始值, 使用前<strong>必须初始化</strong></p></li><li><p>仅返回类型不同的方法不是合法的重载</p><blockquote><p><strong>方法重载</strong>：指方法名称相同，但<strong>形参列表不同</strong>的方法</p></blockquote></li></ol><h4 id="4-4-Chapter-9"><a href="#4-4-Chapter-9" class="headerlink" title="4.4 Chapter 9"></a>4.4 Chapter 9</h4><ol><li><p>静态方法不能访问实例变量</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;    m =<span class="hljs-number">1</span>;<span class="hljs-comment">//会报错，因为fun()为静态方法&#125; //将m改为static即可</span><br></code></pre></div></td></tr></table></figure></li><li><p>private权限</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AA</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//注意i为privateAA(int i)&#123;this.i =i;&#125;String AA(long i) &#123;this.i = i;return  &quot;i = &quot; + this.i;&#125;&#125;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>在其他类中,使用<code>new AA(10)</code>创建一个实例对象<code>test</code></p><p>因为<code>i</code>为<code>private</code>(仅类内能访问), 所以不能通过<code>test.i</code>在其他类中访问<code>i</code>；</p><p>但是可以通过调用<code>String AA(long i)函数</code>来<strong>间接修改</strong><code>i</code>的值！</p><p>因为AA函数位于类AA中, 可以访问i. 且权限为<code>package</code>，同一包的实例对象都可以调用</p></blockquote></li></ol><h4 id="4-5-Chapter-11-13"><a href="#4-5-Chapter-11-13" class="headerlink" title="4.5 Chapter 11-13"></a>4.5 Chapter 11-13</h4><ol><li><p>抽象类：<strong>含有</strong>抽象方法的类，可以有非抽象方法（包括构造方法）和实例字段，也可以是非抽象类的子类</p><p>与接口的区别：</p><p>1）接口不能有构造方法，抽象类可以有。</p><p>2）接口不能有方法体，抽象类可以有。</p><p>3）接口不能有静态方法，抽象类可以有。</p></li><li><p>接口可以继承多个父接口，而类只能继承一个父类</p><blockquote><p>不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？</p><p>但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。</p></blockquote></li><li><p>使用父类的引用变量指向子类实例，若父类的实例方法被覆盖，则调用子类的实例方法（多态性）；若没被覆盖，则调用子类的实例方法。</p></li></ol><h4 id="4-6-Chapter-19"><a href="#4-6-Chapter-19" class="headerlink" title="4.6 Chapter 19"></a>4.6 Chapter 19</h4><ol><li><div class="hljs code-wrapper"><pre><code class="java">static void s2(T i) &#123;&#125;//编译报错，类型变量T无法在静态上下文中被引用</code></pre></div></li><li></li></ol><h4 id="4-7-Chapter-30"><a href="#4-7-Chapter-30" class="headerlink" title="4.7 Chapter 30"></a>4.7 Chapter 30</h4><ol><li>sleep不会释放锁，await会</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习笔记</title>
    <link href="/2021/08/31/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Part1：菜鸟教程"><a href="#Part1：菜鸟教程" class="headerlink" title="Part1：菜鸟教程"></a>Part1：菜鸟教程</h2><h3 id="1-C-基本数据类型"><a href="#1-C-基本数据类型" class="headerlink" title="1. C++基本数据类型"></a>1. C++基本数据类型</h3><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p><table><thead><tr><th align="center">类型</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">布尔型</td><td align="center">bool</td></tr><tr><td align="center">字符型</td><td align="center">char</td></tr><tr><td align="center">整型</td><td align="center">int</td></tr><tr><td align="center">浮点型</td><td align="center">float</td></tr><tr><td align="center">双浮点型</td><td align="center">double</td></tr><tr><td align="center">无类型</td><td align="center">void</td></tr><tr><td align="center">宽字符型</td><td align="center">wchar_t</td></tr></tbody></table><blockquote><p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p></blockquote><h3 id="2-C-修饰符类型"><a href="#2-C-修饰符类型" class="headerlink" title="2. C++修饰符类型"></a>2. C++修饰符类型</h3><p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p><p>下面列出了数据类型修饰符：</p><ul><li>signed</li><li>unsigned</li><li>long</li><li>short</li></ul><p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p><p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p><p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>unsigned、long</strong>，<code>int</code> 是隐含的。</p><h3 id="3-C-储存类"><a href="#3-C-储存类" class="headerlink" title="3.C++储存类"></a>3.C++储存类</h3><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。</p><p>因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h3><p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5.引用"></a>5.引用</h3><p>引用变量是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><h4 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h4><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p>我们可以为 i 声明引用变量，如下所示：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">int<span class="hljs-meta">&amp;  r = i;</span><br></code></pre></div></td></tr></table></figure><p>之后，r就可以当作正常的变量使用</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; x, <span class="hljs-keyword">int</span>&amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">int</span> temp;<br>   temp = x; <span class="hljs-comment">/* 保存地址 x 的值 */</span><br>   x = y;    <span class="hljs-comment">/* 把 y 赋值给 x */</span><br>   y = temp; <span class="hljs-comment">/* 把 x 赋值给 y  */</span><br>   <span class="hljs-keyword">return</span>;<br>&#125;<span class="hljs-comment">//通过引用的方式传入参数，既可以免去指针操作的繁琐，又可以修改原参数</span><br></code></pre></div></td></tr></table></figure><h1 id="Part2：OI-WIKI"><a href="#Part2：OI-WIKI" class="headerlink" title="Part2：OI WIKI"></a>Part2：OI WIKI</h1><h2 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1. 内存分配"></a>1. 内存分配</h2><p>​        C++ 中新增了 <code>new</code> 和 <code>delete</code> 关键字用来在“自由存储区”上分配空间，这个自由存储区可以是堆也可以是静态存储区，他们是为了配合“类”而出现的。其中 <code>delete[]</code> 还能够直接释放动态数组的内存，非常方便。<code>new</code> 和 <code>delete</code> 关键字会调用类型的构造函数和析构函数，相比 C 中的 <code>malloc()</code>、<code>realloc()</code>、<code>free()</code> 函数，他们对类型有更完善的支持，<strong>但是效率不如 C 中的这些函数</strong>。</p><p>​        简而言之，如果你需要动态分配内存的对象是<strong>基础类型或他们的数组</strong>，那么你可以**使用 <code>malloc()</code> **进行更高效的内存分配；但如果你新建的对象是非基础的类型，那么建议使用 <code>new</code> 以获得安全性检查。值得注意的是尽管 <code>new</code> 和 <code>malloc()</code> 都是返回指针，但是 <code>new</code> 出来的指针 <strong>只能</strong> 用 <code>delete</code> 回收，而 <code>malloc()</code> 出来的指针也只能用 <code>free()</code> 回收，否则会有内存泄漏的风险</p><h2 id="2-struct"><a href="#2-struct" class="headerlink" title="2. struct"></a>2. struct</h2><p>​    尽管在 C 和 C++ 中都有 struct 的概念，但是他们对应的东西是不能混用的！C 中的 struct 用来描述一种固定的内存组织结构，而 <strong>C++ 中的 struct 就是一种类</strong>，<strong>它与类唯一的区别就是它的成员和继承行为默认是 public 的</strong>，而一般类的默认成员是 private 的。这一点在写 C/C++ 混合代码时尤其致命。</p><p>另外，声明 struct 时 C++ 也不需要像 C 那么繁琐，</p><p>C 版本：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node_t</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node_t</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">int</span> key;<br>&#125; Node;<br></code></pre></div></td></tr></table></figure><p>C++ 版本</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  Node *next;<br>  <span class="hljs-keyword">int</span> key;<br>&#125;;<span class="hljs-comment">//和类的声明非常类似</span><br></code></pre></div></td></tr></table></figure><h2 id="3-类"><a href="#3-类" class="headerlink" title="3. 类"></a>3. 类</h2><p>类（class）是结构体的拓展，不仅能够拥有成员元素，还拥有成员函数。</p><p>C++ 中 <code>struct</code> 关键字定义的也是类，上文中的 <strong>结构体</strong> 的定义来自 C。因为某些历史原因，C++ 保留并拓展了 <code>struct</code>。</p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>类使用关键字 <code>class</code> 或者 <code>struct</code> 定义，下文以 <code>class</code> 举例。</p><h3 id="访问说明符"><a href="#访问说明符" class="headerlink" title="访问说明符"></a>访问说明符</h3><ul><li><code>public</code>：<strong>类内</strong> 还是 <strong>类外</strong> 都可以访问。</li><li><code>protected</code>：可以被<strong>类内、派生类</strong>或者友元的成员访问，但类外<strong>不能访问</strong>。</li><li><code>private</code>：只能被 <strong>类内</strong> 成员或者友元的成员访问，<strong>不能</strong> 被从类外或者派生类中访问。</li></ul><p>对于 <code>struct</code>，它的所有成员都是默认 <code>public</code>。对于 <code>class</code>，它的所有成员都是默认 <code>private</code>。</p><blockquote><p>友元：使用 <code>friend</code> 关键字修饰某个函数或者类。</p><p>简单来说就是只要带有这个类的 <code>friend</code> 标记，就<strong>可以访问私有</strong>或<strong>受保护</strong>的成员元素。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下使用命令行打开网页</title>
    <link href="/2021/08/31/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5/"/>
    <url>/2021/08/31/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>部分应用没有Linux版本，而使用wine版本又存在bug，对于有网页版的应用，我们可以使用如下的方式。</p><p>以下以test为例</p></blockquote><ol><li><p>创建文件夹test</p></li><li><p>cd进该文件夹，执行<code>yarn init</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ code index.js<br><span class="hljs-comment">#输入以下内容</span><br>const &#123; app, BrowserWindow, Menu &#125; = require(<span class="hljs-string">&#x27;electron&#x27;</span>)<br>Menu.setApplicationMenu(null);<br>app.on(<span class="hljs-string">&#x27;ready&#x27;</span>, ()=&gt;&#123;<br><span class="hljs-built_in">let</span> win = new BrowserWindow()<br>win.loadURL(<span class="hljs-string">&#x27;目标网址&#x27;</span>)<br>&#125;)<br>$ electron .<br><span class="hljs-comment">#或者 </span><br>$ electron ~/Code/linux_app_repo/<span class="hljs-built_in">test</span> <span class="hljs-comment">#绝对路径（这里是我的绝对路径，以实际情况为准）</span><br></code></pre></div></td></tr></table></figure></li><li><p>将上述的electron指令写入到xxx.sh文件中，并将该sh文件<code>mv</code>到<code>/usr/local/bin</code>下</p></li><li><p>编辑<code>～/.zshrc</code>，使用<code>alias</code>指令将xxx.sh转换为想要的指令名，然后<code>source</code>一下即可生效</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OI Wiki学习笔记</title>
    <link href="/2021/08/31/OI-Wiki%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/OI-Wiki%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Part1：语言基础"><a href="#Part1：语言基础" class="headerlink" title="Part1：语言基础"></a>Part1：语言基础</h2><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h4><ol><li>应该尽量将较大的数组定义为全局变量。因为局部变量会被创建在栈区中，过大（大于栈的大小）的数组会爆栈，进而导致 RE。</li><li>可以通过下标运算符 <code>[]</code> 来访问数组内元素，数组的索引（即方括号中的值）从 0 开始。以一个包含 10 个元素的数组为例，它的索引为 0 到 9，而非 1 到 10。但在 OI 中，为了使用方便，我们通常会将数组开大一点，不使用数组的第一个元素，从下标 1 开始访问数组元素。</li></ol><h4 id="2-文件读写"><a href="#2-文件读写" class="headerlink" title="2. 文件读写"></a>2. 文件读写</h4><ol><li><p><strong>freopen</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">FILE* <span class="hljs-title">freopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* mode, FILE* stream)</span></span>;<span class="hljs-comment">//stream即为stdin和stdout</span><br></code></pre></div></td></tr></table></figure><p>将指定输入输出流以指定方式重定向到文件，包含于头文件 <code>stdio.h (cstdio)</code> 中。</p><p>该函数可以在不改变代码原貌的情况下改变输入输出环境</p><p>配合<code>scanf</code>、<code>printf</code>即可直接实现文件读写</p></li><li><p><strong>fopen</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">FILE* <span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* mode)</span></span><br></code></pre></div></td></tr></table></figure><p>配合<code>fscanf</code>、<code>fprintf</code></p><p>还需要定义File指针</p></li></ol><h2 id="Part2：算法基础"><a href="#Part2：算法基础" class="headerlink" title="Part2：算法基础"></a>Part2：算法基础</h2><h4 id="1-递归要点"><a href="#1-递归要点" class="headerlink" title="1. 递归要点"></a>1. 递归要点</h4><p><strong>明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，</strong> 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。以遍历二叉树为例。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">traverse</span>(root-&gt;left);<br>  <span class="hljs-built_in">traverse</span>(root-&gt;right);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        这几行代码就足以遍历任何一棵二叉树了。对于递归函数 <code>traverse(root)</code>，只要相信给它一个根节点 <code>root</code>，它就能遍历这棵树。所以只需要把这个节点的左右节点再传给这个函数就行了。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo+github搭建个人博客并发布文章</title>
    <link href="/2021/08/30/%E4%BD%BF%E7%94%A8Hexo-github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/08/30/%E4%BD%BF%E7%94%A8Hexo-github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h2><p>在安装nodejs和npm时踩坑，一开始使用yay安装，但npm无法使用，一直报错缺少module.</p><p>解决：使用nvm安装</p><h2 id="2-hexo命令"><a href="#2-hexo命令" class="headerlink" title="2. hexo命令"></a>2. hexo命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs hexo">hexo init #初始化博客<br>命令简写<br>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy #部署<br><br>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令<br></code></pre></div></td></tr></table></figure><h3 id="发布新文章"><a href="#发布新文章" class="headerlink" title="发布新文章"></a>发布新文章</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo clean <span class="hljs-comment">#本来不需要这一步，但是加上总没错</span><br>$ hexo g<br>$ hexo d<br><span class="hljs-comment">#或者直接生成并部署</span><br>$ hexo g -d<br></code></pre></div></td></tr></table></figure><blockquote><p>如果看不到网页更新，尝试使用<code>Shift</code>+<code>F5</code>清空浏览器缓存后重试</p></blockquote><h2 id="3-主题配置"><a href="#3-主题配置" class="headerlink" title="3. 主题配置"></a>3. 主题配置</h2><p>本网站使用的主题为fluid,配置文档<a href="https://hexo.fluid-dev.com/docs/guide">看这里</a></p><p>其他功能定制<a href="https://www.erenship.com/posts/40222.html">看这里</a></p><h2 id="4-文章编写"><a href="#4-文章编写" class="headerlink" title="4. 文章编写"></a>4. 文章编写</h2><h3 id="4-1-Front-matter"><a href="#4-1-Front-matter" class="headerlink" title="4.1  Front-matter"></a>4.1  <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a></h3><ul><li><p>添加标签</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">tags:</span> <span class="hljs-string">a</span> <span class="hljs-comment">#添加a标签</span><br><span class="hljs-string">tags:[a,</span> <span class="hljs-string">b]</span> <span class="hljs-comment">#添加a和b两个标签</span><br></code></pre></div></td></tr></table></figure></li><li><p>为首页的文章配封面图</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br></code></pre></div></td></tr></table></figure><p>如果想统一给文章设置一个默认图片（文章不设置 <code>index_img</code> 则默认使用这张图片），可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">default_index_img:</span> <span class="hljs-string">/img/example.jpg</span><br></code></pre></div></td></tr></table></figure></li><li><p>文章页顶部大图</p><p>默认显示<strong>主题配置</strong>中的 <code>post.banner_img</code></p><p>如需要设置单个文章的 Banner，在 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter (opens new window)</a>中指定 <code>banner_img</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">banner_img：</span> <span class="hljs-string">/img/xxx.jpg</span><br></code></pre></div></td></tr></table></figure></li><li><p>参数表</p></li></ul><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td><td align="left"></td></tr><tr><td align="left"><code>lang</code></td><td align="left">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td><td align="left">Inherited from <code>_config.yml</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记</title>
    <link href="/2021/08/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Part-1：-bash"><a href="#Part-1：-bash" class="headerlink" title="Part 1： bash"></a>Part 1： bash</h2><h3 id="1-压缩文件"><a href="#1-压缩文件" class="headerlink" title="1. 压缩文件"></a>1. 压缩文件</h3><p>*.zip          zip 程序压缩的文件;<br>*.gz           gzip 程序压缩的文件;#windows中的WinRaR/7Zip可解压<br>*.bz2          bzip2 程序压缩的文件;#比gzip更好<br>*.xz           xz 程序压缩的文件;#压缩比更高<br>#因为上述程序通常只能压缩一个文件，所以在压缩多个文件时非常不方便<br>#所以产生了tar这个打包程序，将多个文件打包成一个文件！<br>*.tar          tar 程序打包的数据,#并没有压缩过;<br>*.tar.gz      tar 程序打包的文件,其中并且经过 gzip 的压缩<br>*.tar.bz2      tar 程序打包的文件,其中并且经过 bzip2 的压缩<br>*.tar.xz      tar 程序打包的文件,其中并且经过 xz 的压缩</p><h4 id="1-单个文件-gz-bz2-xz"><a href="#1-单个文件-gz-bz2-xz" class="headerlink" title="(1) 单个文件: .gz   .bz2   xz"></a>(1) 单个文件: <code>.gz</code>   <code>.bz2</code>   <code>xz</code></h4><p>用法几乎相同</p><figure class="highlight diff"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-d :解压缩</span><br><span class="hljs-deletion">-c :将压缩的过程产生的数据输出到屏幕上</span><br><span class="hljs-deletion">-k :保留原本的文件</span><br><span class="hljs-deletion">-v :可以显示出原文件/压缩文件案的压缩比等信息;</span><br><span class="hljs-deletion">-# :#为数字的意思,代表压缩等级,默认是6</span><br><span class="hljs-deletion">-l :列出压缩文件的相关信息</span><br></code></pre></div></td></tr></table></figure><h4 id="2-打包-tar"><a href="#2-打包-tar" class="headerlink" title="(2) 打包:  tar"></a>(2) 打包:  <code>tar</code></h4><figure class="highlight diff"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-x :解打包或解压缩的功能,可以搭配 -C (大写) 在特定目录解开</span><br><span class="hljs-deletion">-C 目录:这个选项用在解压缩,若要在特定目录解压缩,可以使用这个选项。</span><br><span class="hljs-deletion">-f filename:-f 后面要立刻接要被处理的档名!建议 -f 单独写一个选项啰!(比较不会忘记)</span><br><br><span class="hljs-deletion">-c :建立打包文件,可搭配 -v 来察看过程中被打包的档名(filename)</span><br><span class="hljs-deletion">-t :察看打包文件的内容含有哪些档名,重点在察看『档名』就是了;</span><br><span class="hljs-deletion">-v :在压缩/解压缩的过程中,显示正在处理的文件名</span><br><br><span class="hljs-deletion">-z :透过 gzip的支持进行压缩/解压缩:此时档名最好为 *.tar.gz</span><br><span class="hljs-deletion">-j :透过 bzip2 的支持进行压缩/解压缩:此时档名最好为 *.tar.bz2</span><br><span class="hljs-deletion">-J :透过 xz的支持进行压缩/解压缩:此时档名最好为 *.tar.xz</span><br></code></pre></div></td></tr></table></figure><h4 id="3-对于tar-xz-等文件-可采用两种方法解压"><a href="#3-对于tar-xz-等文件-可采用两种方法解压" class="headerlink" title="(3) 对于tar.xz 等文件 可采用两种方法解压"></a>(3) 对于<code>tar.xz</code> 等文件 可采用两种方法解压</h4><ul><li>先将外层用xz解压方式解压,，然后里层用tar解压方式解压：</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ xz -d  ***.tar.xz<br>$ tar -xv -f  ***.tar<br></code></pre></div></td></tr></table></figure><ul><li>直接解压：</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">解压: $ tar -Jxv -f  ***.tar.xz<br>压缩: $ tar -Jcv -f  ***.tar.xz    <span class="hljs-comment">#compress</span><br><span class="hljs-comment">#对于tar.gz : 将J改为z</span><br><span class="hljs-comment">#对于tar.bz2: 将J改为j</span><br></code></pre></div></td></tr></table></figure><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><h4 id="2-1-Ubuntu及类似环境下"><a href="#2-1-Ubuntu及类似环境下" class="headerlink" title="2.1 Ubuntu及类似环境下"></a>2.1 Ubuntu及类似环境下</h4><h5 id="1-deb"><a href="#1-deb" class="headerlink" title="(1) deb"></a>(1) deb</h5><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo dpkg -i xxxx.deb<br><span class="hljs-comment">#对于官⽹已经提供了 Ubuntu 版本 .deb 安装⽂件的，可在官⽹下载 .deb 安装⽂件后，执⾏下⾯的命令安装</span><br>$ sudo apt install ./&lt;file&gt;.deb<br></code></pre></div></td></tr></table></figure><h5 id="2-rmp"><a href="#2-rmp" class="headerlink" title="(2) rmp"></a>(2) rmp</h5><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将.rpm 包转换为.deb 包（当前⽬录下会⽣成⼀个 deb 安装包)</span><br>sudo alien xxxx.rpm<br><span class="hljs-comment"># 安装</span><br>sudo dpkg -i xxxx.deb<br></code></pre></div></td></tr></table></figure><h4 id="2-2-Manjaro"><a href="#2-2-Manjaro" class="headerlink" title="2.2 Manjaro"></a>2.2 Manjaro</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ debtap xxx.deb <br><span class="hljs-comment"># manjaro需要先使用debtap工具将deb包转换为arch软件包</span><br><span class="hljs-comment"># 可使用-q跳过问题</span><br>$ sudo pacman -U xxx.tar.xx <br><span class="hljs-comment">#然后使用pacman进行安装即可</span><br></code></pre></div></td></tr></table></figure><h3 id="3-有用的指令"><a href="#3-有用的指令" class="headerlink" title="3. 有用的指令"></a>3. 有用的指令</h3><h4 id="（1）alias"><a href="#（1）alias" class="headerlink" title="（1）alias"></a>（1）alias</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">alias</span> lm=<span class="hljs-string">&#x27;ls -al&#x27;</span>  <span class="hljs-comment">#表示用lm代表ls -al$ unalias xxx  #取消# 可以将alias命令加入~/.bashrc ~/.zshrc文件中，永久生效，使用source ～/.xxx更新设置</span><br></code></pre></div></td></tr></table></figure><h4 id="（2）history"><a href="#（2）history" class="headerlink" title="（2）history"></a>（2）history</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">history</span> <span class="hljs-comment">#显示历史命令$ !5 # 执行第5个命令$ !! # 执行上一个命令$ !xx#执行以xx开头的命令</span><br></code></pre></div></td></tr></table></figure><h3 id="4-shell快捷键"><a href="#4-shell快捷键" class="headerlink" title="4. shell快捷键"></a>4. shell快捷键</h3><ul><li><p>移动光标：</p><ul><li><p><code>ctrl</code> + <code>a</code> 最前面</p></li><li><p><code>ctrl</code> + <code>e</code> 最后面</p></li></ul></li><li><p>删除：</p><ul><li><code>ctrl</code> + <code>u</code> 从光标处向前删除</li></ul></li><li><p><code>ctrl</code> + <code>k</code> 向后</p></li></ul><h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h3><ul><li><p>显示变量：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;PATH&#125;</span><span class="hljs-comment"># 变量为大写字母</span><br></code></pre></div></td></tr></table></figure></li><li><p>变量的设定</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1.设定格式：变量名=变量内容$ myname=cwh<span class="hljs-comment">#注意:等号两边不能接空格,若变量内容有空格,使用单或双引号将内容括起来2.还需要其他额外的指令所提供的信息时,可以使用反单引号『`指令`』或 『$(指令)』。如：取得核心版本号：$ version=$(uname -r)3.增加变量：变量名=$&#123;变量名&#125;xxx$ PATH=$&#123;PATH&#125;:/home/bin#因为PATH变量中目录与目录中间以冒号分隔$ name=$&#123;name&#125;yes #在name变量后加上yes4.若该变量需要在其他子程序执行,则需要以 export :$ export PATH5.取消变量：unset 变量名</span><br></code></pre></div></td></tr></table></figure><ul><li>将某一目录加入PATH：(以下方法按效力和作用域递增)</li></ul><ol><li><p>直接修改<code>$PATH</code>值：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span> //查看当前PATH的配置路径$ <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/xxx/xxx //将需配置路径加入<span class="hljs-variable">$PATH</span> 等号两边一定不能有空格<br></code></pre></div></td></tr></table></figure><p> 生效方法：立即生效</p><p> 有效期限：<code>临时改变</code>，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置</p><p> 用户局限：仅对当前用户</p></li><li><p>修改<code>.bashrc</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ code /.bashrc<span class="hljs-comment">#在最后一行添上：$ export PATH=$PATH:/xxx/xxx  </span><br></code></pre></div></td></tr></table></figure><p>生效方法：</p><ul><li><p>关闭当前终端窗口，重新打开一个新终端窗口就能生效</p></li><li><p>输入“source .bashrc”命令，立即生效</p></li></ul><p>有效期限：永久有效</p><p>用户局限：仅对当前用户</p></li><li><p>修改<code>profile</code>文件或<code>environment</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ code /etc/profile <span class="hljs-comment">#在最后一行添上：$ export PATH=$PATH:/xxx/xxx$ code /etc/environment#在 PATH=/········· 中加入“:/xxx/xxx”#个人认为修改profile文件更合适，因为能清晰地看到哪些变量是自己加上的，哪些是系统原有的</span><br></code></pre></div></td></tr></table></figure><p> 生效方法：系统重启</p><p> 有效期限：<code>永久有效</code></p><p> 用户局限：<code>对所有用户</code></p></li></ol></li><li><p>特殊变量: ?</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> $? 显示指令回传的执行后代码<span class="hljs-comment">#指令正常，返回0#执行错误，返回非零</span><br></code></pre></div></td></tr></table></figure></li><li><p>export：引入变量 </p><p>子程序仅会继承父程序的环境变量, 子程序『不会』继承父程序的『自定义变量』。使用export可以将自定义变量变为环境变量。</p></li><li><p>locale：显示语系   发生乱码，设定系统语系编码即可。</p></li></ul><h2 id="Part2-：some-tips"><a href="#Part2-：some-tips" class="headerlink" title="Part2 ：some tips"></a>Part2 ：some tips</h2><ol><li><strong>修改开机默认引导</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /etc/default$ sudo gedit grub  修改GRUB_DEFAULT的值，ubuntu为0，windows为2$ sudo update-grub  //更新配置文件<br></code></pre></div></td></tr></table></figure><ol start="2"><li><strong>关闭sudo密码</strong></li></ol><p>终端输入命令sudo visudo，打开 visudo；</p><p>找到 %sudo ALL=(ALL:ALL) ALL 这一行修改为%sudo ALL=(ALL:ALL) NOPASSWD:ALL<br>有安全风险，请谨慎使用</p><ol start="3"><li> <strong>kill 进程</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ps -x$ <span class="hljs-built_in">kill</span> -9 进程号<br></code></pre></div></td></tr></table></figure><ol start="4"><li><strong>wine字体太小</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ env WINEPREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.deepinwine/软件名&quot;</span> winecfg<br></code></pre></div></td></tr></table></figure><ol start="5"><li><strong>换镜像</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo pacman-mirrors -i -c China -m rank<br></code></pre></div></td></tr></table></figure><ol start="6"><li><strong>使用yay时报错</strong></li></ol><ul><li><p>错误：无法从 mirrors.aliyun.com : The requested URL returned error: 404 获取文件</p><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo pacman-mirrors -i $ sudo pacman -Sy<br></code></pre></div></td></tr></table></figure></li></ul><ol start="7"><li><p><strong>majaro安装node和npm</strong> </p><p>踩坑！不要使用yay！使用nvm</p></li></ol><h2 id="Part3：Linux基本知识"><a href="#Part3：Linux基本知识" class="headerlink" title="Part3：Linux基本知识"></a>Part3：Linux基本知识</h2><h3 id="1-bin文件夹"><a href="#1-bin文件夹" class="headerlink" title="1. bin文件夹"></a>1. bin文件夹</h3><h4 id="（1）存放脚本"><a href="#（1）存放脚本" class="headerlink" title="（1）存放脚本"></a>（1）存放脚本</h4><p><code>~/bin</code>：个人用户的 script<br><code>/usr/local/bin</code>：存放所有用户都可以使用的 script<br><code>/usr/local/sbin</code>： 存放管理员的 script</p><h3 id="（2）存放其他文件"><a href="#（2）存放其他文件" class="headerlink" title="（2）存放其他文件"></a>（2）存放其他文件</h3><p><code>/usr/local/</code>：大部分是本地用户软件<br><code>/bin或/usr/bin</code>：不是用来放软件的，是用来存放 Linux distribution 专用文件的。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
