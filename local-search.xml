<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>十月计划</title>
    <link href="/2021/10/15/%E5%8D%81%E6%9C%88%E8%AE%A1%E5%88%92/"/>
    <url>/2021/10/15/%E5%8D%81%E6%9C%88%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>月计划写晚了，国庆七天有点不在状态，有受保研的影响，不过现在调整过来了，其实只要大三正常学，珍惜时间，尽力去做就行。专业课开满了，全是硬课，加上新来的转专业选手综合成绩在保研边缘，加把劲！</p></blockquote><h2 id="1-学习"><a href="#1-学习" class="headerlink" title="1. 学习"></a>1. 学习</h2><ol><li>专业课实验开了好几个，一定要学好课内知识</li><li>坚持每天背单词</li><li>当天作业当天动笔，当周实验当周做，不拖到ddl，尽量自己完成，不怕花时间，多花时间琢磨，付出总有回报</li><li>减少在宿舍学习的时间，多去教学楼</li><li>空下来了不能忘了csp，10分就是0.1综合成绩，加油！</li><li>保持自己的欲望，时刻提醒自己要有明确的目标</li></ol><h2 id="2-生活习惯"><a href="#2-生活习惯" class="headerlink" title="2. 生活习惯"></a>2. 生活习惯</h2><ol><li>每周去健身房锻炼1-2次，工作日时间晚上下课了可以花几分钟去小跑几圈</li><li>早上7：30之前起床，每周执行5次以上 <del>一周3天早八，我就不信这个我做不到</del></li><li>晚上11：30之前不带手机上床，睡前看会儿kindle，看困了就睡，尽量每天如此 <del>事实证明11点睡觉对于一个大三的计算机学生是不合理的</del></li><li>少吃夜宵，每周不超过3次，睡前饿了牛奶+面包更好 :D</li><li>控制游戏时间，学会驾驭游戏等娱乐方式而不是成为它们的奴隶</li></ol><h2 id="3-心态"><a href="#3-心态" class="headerlink" title="3. 心态"></a>3. 心态</h2><p>不畏难，不怕尴尬，勇敢尝试，敢于迈出第一步 : D</p><p>不怕丢人，不怕暴露自己知识不如同学丰富，acm班本来就卧虎藏龙，不暴露自己的弱点就永远不可能进步</p><p>你根本就没那么多观众  <del>上个课班里都是男的你怕丢啥人</del>  : D</p><p>道阻且长，行则将至 : D</p><p>加油！</p>]]></content>
    
    
    <categories>
      
      <category>月计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex学习笔记</title>
    <link href="/2021/09/27/Latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/09/27/Latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Latex学习笔记"><a href="#Latex学习笔记" class="headerlink" title="Latex学习笔记"></a>Latex学习笔记</h1><p>转载自：原文<a href="https://liam.page/2014/09/08/latex-introduction/">链接</a></p><h2 id="0-简介与模板"><a href="#0-简介与模板" class="headerlink" title="0.简介与模板"></a>0.简介与模板</h2><h3 id="0-1-简介"><a href="#0-1-简介" class="headerlink" title="0.1 简介"></a>0.1 简介</h3><p>TeX - pdfTeX - XeTeX - LuaTeX 都是排版引擎，按照先进程度递增（LuaTeX 尚未完善）。</p><p>LaTeX 是一种格式，基于 TeX 格式定义了很多更方便使用的控制命令。上述四个引擎都有对应的程序将 LaTeX 格式解释成引擎能处理的内容。</p><p>CTeX, MiKTeX, TeX Live 都是 TeX 的发行，他们是许许多多东西的集合。</p><h4 id="遇到问题怎么办"><a href="#遇到问题怎么办" class="headerlink" title="遇到问题怎么办"></a>遇到问题怎么办</h4><ol><li>绝对的新手，先读完一本入门读物，了解基本的知识；</li><li>无论如何，先读文档！绝大部分问题都是文档可以解决的；</li><li>利用 Google 搜索你的问题；</li><li>在各个论坛或者 LaTeX 交流群里聪明地提出你的问题。</li></ol><p>参考：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md</a></p><h3 id="0-2-模板"><a href="#0-2-模板" class="headerlink" title="0.2 模板"></a>0.2 模板</h3><p>一个非常优雅的作业模板: D</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\documentclass[UTF8,12pt]&#123;ctexart&#125;<br>\usepackage[T1]&#123;fontenc&#125;<br>\usepackage&#123;newpxtext,newpxmath&#125; % palatino风格字体<br>\usepackage&#123;geometry&#125; % 调整页边距<br>\geometry&#123;a4paper,scale=0.8&#125; % 调整页边距<br>\ctexset&#123;section=&#123;format=&#123;\large\bfseries\raggedright&#125;&#125;&#125;  % section居左<br><br>\setCJKmainfont[BoldFont=SimHei, ItalicFont=KaiTi]&#123;SimSun&#125; % 字体设置overleaf %SimHei<br><br>\title&#123;\bfseries 文章标题&#125;<br>\author&#123;Henry Chi&#125;<br>\date&#123;\today&#125;<br><br>\begin&#123;document&#125;<br><br>\maketitle<br><br>\section&#123;Hello 世界&#125;<br><br>How are you? 我很好。<br><br>The quick brown fox jumps over a lazy dog.<br><br>\emph&#123;The quick brown fox jumps over a lazy dog.&#125;<br><br>\end&#123;document&#125;<br></code></pre></div></td></tr></table></figure><h2 id="1-第一篇文档"><a href="#1-第一篇文档" class="headerlink" title="1. 第一篇文档"></a>1. 第一篇文档</h2><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world!"></a>Hello, world!</h3><p>在编辑框中，输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">`\documentclass&#123;article&#125;<br>% 这里是导言区<br>\begin&#123;document&#125;<br>Hello, world!<br>\end&#123;document&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>文件名不要包含中文</p></blockquote><ul><li><p><code>TeX</code> 以百分号 <code>%</code> 作为注释标记, 若要输出 <code>%</code> 字符本身，则需要在 <code>%</code> 之前加上反斜杠 <code>\</code> 进行转义</p></li><li><p>从 <code>\documentclass&#123;article&#125;</code> 开始到 <code>\begin&#123;document&#125;</code> 之前的部分被称为导言区。你可以将导言区理解为是对整篇文档进行设置的区域——在导言区出现的控制序列，往往会影响整篇文档的格式。</p><blockquote><p>比如，我们通常在导言区设置页面大小、页眉页脚样式、章节标题样式等等。</p></blockquote></li></ul><h3 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\begin&#123;document&#125;<br>你好，world!<br>\end&#123;document&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>一切教你使用 <code>CJK</code> 宏包的模板、人、网页、书，都是糟糕的、有害的、恼人的、邪恶的和应该摒弃的。</p></li><li><p><code>XeTeX</code> 原生支持 Unicode，并且可以方便地调用系统字体，我们只需要使用几个简单的宏包，就能完成中文支持了, <code>CTeX</code> 宏集一次性解决了这些问题。</p><blockquote><p>请注意，<code>CTeX</code> 宏集和 <code>CTeX</code> 套装是两个不同的东西。<code>CTeX</code> 宏集本质是 <code>LaTeX </code>宏的集合，包含若干文档类（<code>.cls</code> 文件）和宏包（<code>.sty</code> 文件）。<code>CTeX</code> 套装是一个<strong>过时的</strong><code> TeX</code> 系统。</p></blockquote></li></ul><h2 id="2-组织文章"><a href="#2-组织文章" class="headerlink" title="2. 组织文章"></a>2. 组织文章</h2><h3 id="作者、标题、日期"><a href="#作者、标题、日期" class="headerlink" title="作者、标题、日期"></a>作者、标题、日期</h3><p>保存并用<code>XeLaTeX</code> 编译如下文档，查看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>%导言区<br>\title&#123;你好，world!&#125;<br>\author&#123;Liam&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>你好，world!<br>\end&#123;document&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>导言区复杂了很多，但和之前的文档主要的区别只有一处：定义了标题、作者、日期。</p></li><li><p>在 <code>document</code> 环境中，除了原本的<code>你好，world!</code>，还多了一个控制序列 <code>maketitle</code>。这个控制序列能将在导言区中定义的标题、作者、日期按照预定的格式展现出来。</p></li></ul><h3 id="章节和段落"><a href="#章节和段落" class="headerlink" title="章节和段落"></a>章节和段落</h3><p>保存并用 <code>XeLaTeX </code>编译如下文档，查看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好，world!&#125;<br>\author&#123;Liam&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>\section&#123;你好中国&#125;<br>中国在East Asia.<br>\subsection&#123;Hello Beijing&#125;<br>北京是capital of China.<br>\subsubsection&#123;Hello Dongcheng District&#125;<br>\paragraph&#123;Tian&#x27;anmen Square&#125;<br>is in the center of Beijing<br>\subparagraph&#123;Chairman Mao&#125;<br>is in the center of 天安门广场。<br>\subsection&#123;Hello 山东&#125;<br>\paragraph&#123;山东大学&#125; is one of the best university in 山东。<br>\end&#123;document&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p><code>LaTeX</code>将一个换行当做是一个简单的空格来处理，如果需要换行另起一段，则需要用两个换行（一个空行）来实现。</p></li><li><p>在文档类 <code>article</code>/<code>ctexart</code> 中，定义了五个控制序列来调整行文组织结构。他们分别是</p><ul><li><code>\section&#123;·&#125;</code></li><li><code>\subsection&#123;·&#125;</code></li><li><code>\subsubsection&#123;·&#125;</code></li><li><code>\paragraph&#123;·&#125;</code></li><li><code>\subparagraph&#123;·&#125;</code></li></ul></li></ul><h3 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h3><p>​    在上一节的文档中，找到 <code>\maketitle</code>，在它的下面插入控制序列 <code>\tableofcontents</code>，保存并用<code>XeLaTeX</code>编译<strong>两次</strong>，会发现多出了一个目录。如果交换<code>maketitle</code>和<code>tableofcontents</code>的位置，会发现目录和title的先后顺序发生了变化，显而易见。</p><h2 id="3-插入数学公式"><a href="#3-插入数学公式" class="headerlink" title="3. 插入数学公式"></a>3. 插入数学公式</h2><p>为了使用<code>AMS-LaTeX</code>提供的数学功能，我们需要在导言区加载 <code>amsmath</code> 宏包：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\usepackage&#123;amsmath&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-0-数学模式"><a href="#3-0-数学模式" class="headerlink" title="3.0 数学模式"></a>3.0 数学模式</h3><p><code>   LaTeX</code>的数学模式有两种：行内模式 (inline) 和行间模式 (display)。前者在正文的行文中，插入数学公式；后者独立排列单独成行，并自动居中。</p><p>在行文中，<strong>使用 <code>$ ... $</code> 可以插入行内公式，使用 <code>\[ ... \]</code> 可以插入行间公式</strong>，如果需要对行间公式进行编号，则可以使用 <code>equation</code> 环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;equation&#125;<br>...<br>\end&#123;equation&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-1-上下标"><a href="#3-1-上下标" class="headerlink" title="3.1 上下标"></a>3.1 上下标</h3><p>上标：使用 <code>^</code> </p><p>下标：使用 <code>_</code></p><p><strong>注意</strong>： <strong>它默认只作用于之后的一个字符</strong>，如果想对连续的几个字符起作用，请将这些字符用花括号 <code>&#123;&#125;</code> 括起来，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\[ z = r\cdot e^&#123;2\pi i&#125;. \]<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\documentclass&#123;article&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>Einstein &#x27;s $E=mc^2$.%行内公式，注意标点位置<br><br>\[ E=mc^2. \] %行间公式，注意标点位置<br><br>\begin&#123;equation&#125;<br>E=mc^2.<br>\end&#123;equation&#125;<br>\end&#123;document&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>公式标点使用的规范</strong>:  <ul><li>行内公式：放在数学模式<strong>限定符之外</strong></li><li>行间公式：放在数学模式<strong>限定符之内</strong>。</li></ul></li></ul><h3 id="3-2-根式与分式"><a href="#3-2-根式与分式" class="headerlink" title="3.2 根式与分式"></a>3.2 根式与分式</h3><p>根式用 <code>\sqrt&#123;·&#125;</code> 来表示，分式用 <code>\frac&#123;·&#125;&#123;·&#125;</code> 来表示（第一个参数为分子，第二个为分母）</p><blockquote><p>可以发现，在行间公式和行内公式中，分式的输出效果是有差异的。如果要强制行内模式的分式显示为行间模式的大小，可以使用 <code>\dfrac</code>, 反之可以使用 <code>\tfrac</code>。</p></blockquote><h3 id="3-3-运算符"><a href="#3-3-运算符" class="headerlink" title="3.3 运算符"></a>3.3 运算符</h3><p>一些<strong>小的运算符</strong>，可以在数学模式下直接输入；</p><p>另一些需要用控制序列生成，如</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\[ \pm\; \times \; \div\; \cdot\; \cap\; \cup\;<br>\geq\; \leq\; \neq\; \approx \; \equiv \]<br></code></pre></div></td></tr></table></figure><p><strong>连加、连乘、极限、积分</strong>等大型运算符分别用 <code>\sum</code>, <code>\prod</code>, <code>\lim</code>, <code>\int</code> 生成。他们的上下标在行内公式中被压缩，以适应行高。我们可以用 <code>\limits</code> 和 <code>\nolimits</code> 来强制显式地指定是否压缩这些上下标。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$ \sum_&#123;i=1&#125;^n i\quad \prod_&#123;i=1&#125;^n $<br>$ \sum\limits _&#123;i=1&#125;^n i\quad \prod\limits _&#123;i=1&#125;^n $<br>\[ \lim_&#123;x\to0&#125;x^2 \quad \int_a^b x^2 dx \]<br>\[ \lim\nolimits _&#123;x\to0&#125;x^2\quad \int\nolimits_a^b x^2 dx \]<br></code></pre></div></td></tr></table></figure><p><strong>多重积分</strong>可以使用 <code>\iint</code>, <code>\iiint</code>, <code>\iiiint</code>, <code>\idotsint</code> 等命令输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\[ \iint\quad \iiint\quad \iiiint\quad \idotsint \]<br></code></pre></div></td></tr></table></figure><h3 id="3-4-定界符（括号等）"><a href="#3-4-定界符（括号等）" class="headerlink" title="3.4 定界符（括号等）"></a>3.4 定界符（括号等）</h3><p>各种括号用 <code>()</code>, <code>[]</code>, <code>\&#123;\&#125;</code>, <code>\langle\rangle</code> 等命令表示；注意花括号通常用来输入命令和环境的参数，所以在数学公式中它们前面要加 <code>\</code>。</p><p>因为 LaTeX 中 <code>|</code> 和 <code>\|</code> 的应用过于随意，amsmath 宏包推荐用 <code>\lvert\rvert</code> 和 <code>\lVert\rVert</code> 取而代之。</p><p>为了调整这些定界符的大小，amsmath 宏包推荐使用 <code>\big</code>, <code>\Big</code>, <code>\bigg</code>, <code>\Bigg</code> 等一系列命令放在上述括号前面调整大小。</p><h3 id="3-5-省略号"><a href="#3-5-省略号" class="headerlink" title="3.5 省略号"></a>3.5 省略号</h3><p>省略号用 <code>\dots</code>, <code>\cdots</code>, <code>\vdots</code>, <code>\ddots</code> 等命令表示。<code>\dots</code> 和 <code>\cdots</code> 的纵向位置不同(高度)，<strong>前者一般用于有下标的序列</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\[ x_1,x_2,\dots ,x_n\quad 1,2,\cdots ,n\quad<br>\vdots\quad \ddots \]<br></code></pre></div></td></tr></table></figure><h3 id="3-6-矩阵"><a href="#3-6-矩阵" class="headerlink" title="3.6 矩阵"></a>3.6 矩阵</h3><p><code>amsmath</code> 的 <code>pmatrix</code>, <code>bmatrix</code>, <code>Bmatrix</code>, <code>vmatrix</code>, <code>Vmatrix</code> 等环境可以在矩阵两边加上各种分隔符。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\[ \begin&#123;pmatrix&#125; a&amp;b\\c&amp;d \end&#123;pmatrix&#125; \quad %\quad代表一个汉字的空白距离 一般用这种就好，个人喜好<br>\begin&#123;bmatrix&#125; a&amp;b\\c&amp;d \end&#123;bmatrix&#125; \quad<br>\begin&#123;Bmatrix&#125; a&amp;b\\c&amp;d \end&#123;Bmatrix&#125; \quad<br>\begin&#123;vmatrix&#125; a&amp;b\\c&amp;d \end&#123;vmatrix&#125; \quad<br>\begin&#123;Vmatrix&#125; a&amp;b\\c&amp;d \end&#123;Vmatrix&#125; \]<br></code></pre></div></td></tr></table></figure><p>效果图：</p><p><img src="https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44jpqbz2aj208k024744.jpg" alt="img"></p><p>使用 <code>smallmatrix</code> 环境，可以生成行内公式的小矩阵。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">Marry has a little matrix $ ( \begin&#123;smallmatrix&#125; a&amp;b\\c&amp;d \end&#123;smallmatrix&#125; ) $.<br></code></pre></div></td></tr></table></figure><p>效果图：</p><p><img src="https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44jsd9ldbj20680200si.jpg" alt="img"></p><h3 id="3-7-多行公式"><a href="#3-7-多行公式" class="headerlink" title="3.7 多行公式"></a>3.7 多行公式</h3><h4 id="长公式"><a href="#长公式" class="headerlink" title="长公式"></a>长公式</h4><h5 id="不对齐：-multline-环境。"><a href="#不对齐：-multline-环境。" class="headerlink" title="不对齐： multline 环境。"></a>不对齐： <code>multline</code> 环境。</h5><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;multline&#125;<br>x = a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\end&#123;multline&#125;<br></code></pre></div></td></tr></table></figure><p>效果：</p><p><img src="https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44jzfychej20dv02sjr6.jpg" alt="img"></p><p>如果<strong>不需要编号</strong>，可以使用 <code>multline*</code> 环境代替。</p><h5 id="对齐：-aligned-次环境，它必须包含在数学环境之内。"><a href="#对齐：-aligned-次环境，它必须包含在数学环境之内。" class="headerlink" title="对齐： aligned 次环境，它必须包含在数学环境之内。"></a>对齐： <code>aligned</code> <em>次环境</em>，它必须包含在数学环境之内。</h5><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\[\begin&#123;aligned&#125;<br>x =&#123;&#125;&amp; a+b+c+&#123;&#125; \\<br>&amp;d+e+f+g<br>\end&#123;aligned&#125;\]<br></code></pre></div></td></tr></table></figure><p>效果图：</p><p><img src="https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44k2acde4j205g02ft8h.jpg" alt="img"></p><h4 id="公式组"><a href="#公式组" class="headerlink" title="公式组"></a>公式组</h4><p>无需对齐的公式组可以使用 <code>gather</code> 环境，需要对齐的公式组可以使用 <code>align</code> 环境。他们都带有编号，如果不需要编号可以使用带*的版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;gather&#125;<br>a = b+c+d \\<br>x = y+z<br>\end&#123;gather&#125;<br>%对齐<br>\begin&#123;align&#125;<br>a &amp;= b+c+d \\<br>x &amp;= y+z<br>\end&#123;align&#125;<br></code></pre></div></td></tr></table></figure><p>效果：</p><p><img src="https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44k5od3xaj209u04lweb.jpg" alt="img"></p><blockquote><p>请注意，不要使用 <code>eqnarray</code> 环境</p></blockquote><h4 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h4><h5 id="cases次环境，它必须包含在数学环境之内。"><a href="#cases次环境，它必须包含在数学环境之内。" class="headerlink" title="cases次环境，它必须包含在数学环境之内。"></a><code>cases</code>次环境，它必须包含在数学环境之内。</h5><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\[ y= \begin&#123;cases&#125;<br>-x,\quad x\leq 0 \\<br>x,\quad x&gt;0<br>\end&#123;cases&#125; \]<br></code></pre></div></td></tr></table></figure><p>效果图：</p><p><img src="https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44k7zto1wj205o01pt8i.jpg" alt="img"></p><h3 id="3-8-辅助工具"><a href="#3-8-辅助工具" class="headerlink" title="3.8 辅助工具"></a>3.8 辅助工具</h3><p>站在我个人的角度，我建议 LaTeX 用户应当尽可能避免使用辅助工具输入数学公式。但对于急用的初学者而言，适当地使用辅助工具（而不形成依赖）也是有一些收益的。因此这里介绍一些关于数学公式的辅助工具。</p><ul><li><a href="https://mathpix.com/">https://mathpix.com/</a> 能够通过热键呼出截屏，而后将截屏中的公式转换成 LaTeX 数学公式的代码。</li><li><a href="http://detexify.kirelabs.org/classify.html">http://detexify.kirelabs.org/classify.html</a> 允许用户用鼠标在输入区绘制单个数学符号的样式，系统会根据样式返回对应的 LaTeX 代码（和所需的宏包）。这在查询不熟悉的数学符号时特别有用。</li></ul><h2 id="4-插入图片和表格"><a href="#4-插入图片和表格" class="headerlink" title="4. 插入图片和表格"></a>4. 插入图片和表格</h2><h3 id="n图片"><a href="#n图片" class="headerlink" title="n图片"></a>n图片</h3><p>多种方式。最好用的应当属利用 <code>graphicx</code> 宏包提供的 <code>\includegraphics</code> 命令。比如你在你的 TeX <strong>源文件同目录下</strong>，有名为 <code>a.jpg</code> 的图片，你可以用这样的方式将它插入到输出文档中：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\documentclass&#123;article&#125;<br>\usepackage&#123;graphicx&#125;%使用宏包<br>\begin&#123;document&#125;<br>\includegraphics&#123;a.jpg&#125;%插入图片<br>\end&#123;document&#125;<br></code></pre></div></td></tr></table></figure><p>用 <code>\includegraphics</code> 控制序列的可选参数来控制缩放：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\includegraphics[width = .8\textwidth]&#123;a.jpg&#125;<br></code></pre></div></td></tr></table></figure><p>这样图片的宽度会被缩放至页面宽度的百分之八十，图片的总高度会按比例缩放。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><code>tabular</code> 环境提供了最简单的表格功能。它用 <code>\hline</code> 命令表示横线，在列格式中用 <code>|</code> 表示竖线；用 <code>&amp;</code> 来分列，用 <code>\\</code> 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 <code>l</code>、<code>c</code>、<code>r</code> 来表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;tabular&#125;&#123;|l|c|r|&#125;<br> \hline<br>操作系统&amp; 发行版&amp; 编辑器\\<br> \hline<br>Windows &amp; MikTeX &amp; TexMakerX \\<br> \hline<br>Unix/Linux &amp; teTeX &amp; Kile \\<br> \hline<br>Mac OS &amp; MacTeX &amp; TeXShop \\<br> \hline<br>通用&amp; TeX Live &amp; TeXworks \\<br> \hline<br>\end&#123;tabular&#125;<br></code></pre></div></td></tr></table></figure><p>效果：</p><p><img src="https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44ku9n696j20cj05haad.jpg" alt="img"></p><h3 id="浮动体"><a href="#浮动体" class="headerlink" title="浮动体"></a>浮动体</h3><p>插图和表格通常需要占据大块空间，所以在文字处理软件中我们经常需要调整他们的位置。<code>figure</code> 和 <code>table</code> 环境可以自动完成这样的任务；这种自动调整位置的环境称作浮动体(float)。我们以 <code>figure</code> 为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;figure&#125;[htbp]<br>\centering<br>\includegraphics&#123;a.jpg&#125;<br>\caption&#123;有图有真相&#125;<br>\label&#123;fig:myphoto&#125;<br>\end&#123;figure&#125;<br></code></pre></div></td></tr></table></figure><p><code>htbp</code> 选项用来指定插图的理想位置，这几个字母分别代表 here, top, bottom, float page，也就是就这里、页顶、页尾、浮动页（专门放浮动体的单独页面或分栏）。<code>\centering</code> 用来使插图居中；<code>\caption</code> 命令设置插图标题，LaTeX 会自动给浮动体的标题加上编号。注意 <code>\label</code> 应该放在标题命令之后。</p><h2 id="5-版面设置"><a href="#5-版面设置" class="headerlink" title="5. 版面设置"></a>5. 版面设置</h2><h3 id="页边距"><a href="#页边距" class="headerlink" title="页边距"></a>页边距</h3><p>设置页边距，推荐使用 <code>geometry</code> 宏包。可以在<a href="http://texdoc.net/texmf-dist/doc/latex/geometry/geometry.pdf">这里</a>查看它的说明文档。</p><p>比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在导言区加上这样几行：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\usepackage&#123;geometry&#125;<br>\geometry&#123;papersize=&#123;20cm,15cm&#125;&#125;<br>\geometry&#123;left=1cm,right=2cm,top=3cm,bottom=4cm&#125;<br></code></pre></div></td></tr></table></figure><h3 id="页眉页脚"><a href="#页眉页脚" class="headerlink" title="页眉页脚"></a>页眉页脚</h3><p>设置页眉页脚，推荐使用 <code>fancyhdr</code> 宏包。可以在<a href="http://texdoc.net/texmf-dist/doc/latex/fancyhdr/fancyhdr.pdf">这里</a>查看它的说明文档。</p><p>比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在导言区加上如下几行：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\usepackage&#123;fancyhdr&#125;<br>\pagestyle&#123;fancy&#125;<br>\lhead&#123;\author&#125;<br>\chead&#123;\date&#125;<br>\rhead&#123;152xxxxxxxx&#125;<br>\lfoot&#123;&#125;<br>\cfoot&#123;\thepage&#125;<br>\rfoot&#123;&#125;<br>\renewcommand&#123;\headrulewidth&#125;&#123;0.4pt&#125;<br>\renewcommand&#123;\headwidth&#125;&#123;\textwidth&#125;<br>\renewcommand&#123;\footrulewidth&#125;&#123;0pt&#125;<br></code></pre></div></td></tr></table></figure><h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><p>CTeX 宏集已经处理好了首行缩进的问题（自然段前空两格汉字宽度）。因此，使用 CTeX 宏集进行中西文混合排版时，我们不需要关注首行缩进的问题。</p><blockquote><p>如果你因为某些原因选择不适用 CTeX 宏集（不推荐）进行中文支持和版式设置，则你需要做额外的一些工作。</p><ul><li>调用 <code>indentfirst</code> 宏包。具体来说，中文习惯于每个自然段的段首都空出两个中文汉字的长度作为首行缩进，但西文行文习惯于不在逻辑节（<code>\section</code> 等）之后缩进。使用改宏包可使 LaTeX 在每个自然段都首行缩进。</li><li>设置首行缩进长度 <code>\setlength&#123;\parindent&#125;&#123;2\ccwd&#125;</code>。其中 <code>\ccwd</code> 是 <code>xeCJK</code> 定义的宏，它表示当前字号中一个中文汉字的宽度。</li></ul></blockquote><h3 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h3><p>我们可以通过 <code>setspace</code> 宏包提供的命令来调整行间距。比如在导言区添加如下内容，可以将行距设置为字号的 1.5 倍：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\usepackage&#123;setspace&#125;<br>\onehalfspacing<br></code></pre></div></td></tr></table></figure><p>具体可以查看该宏包的<a href="http://texdoc.net/texmf-dist/doc/latex/setspace/README">文档</a>。</p><blockquote><p>请注意用词的差别：</p><ul><li>行距是字号的 1.5 倍；</li><li>1.5 倍行距。</li></ul><p>事实上，这不是设置 1.5 倍行距的正确方法，请参考<a href="https://liam.page/2013/10/17/LaTeX-Linespace/">这篇博文</a>。另外，<a href="https://github.com/RuixiZhang42">RuixiZhang</a> 开发了 <a href="https://github.com/CTeX-org/ctex-kit/tree/master/zhlineskip">zhlineskip</a> 宏包，提供了对中西文混排更细致的行距控制能力。</p></blockquote><h3 id="段间距"><a href="#段间距" class="headerlink" title="段间距"></a>段间距</h3><p>我们可以通过修改长度 <code>\parskip</code> 的值来调整段间距。例如在导言区添加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\addtolength&#123;\parskip&#125;&#123;.4em&#125;<br></code></pre></div></td></tr></table></figure><p>则可以在原有的基础上，增加段间距 0.4em。如果需要减小段间距，只需将该数值改为负值即可。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git操作</title>
    <link href="/2021/09/26/git%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/09/26/git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="1-远程库操作"><a href="#1-远程库操作" class="headerlink" title="1. 远程库操作"></a>1. 远程库操作</h2><h3 id="1-1-关联远程库"><a href="#1-1-关联远程库" class="headerlink" title="1.1 关联远程库"></a>1.1 关联远程库</h3><p>关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p><p>使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，就可以使用命令<code>git push origin master</code>推送最新修改；</p><h3 id="1-2-克隆远程库"><a href="#1-2-克隆远程库" class="headerlink" title="1.2 克隆远程库"></a>1.2 克隆远程库</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">$ git clone git@github.com:用户名/repo-name.git<br></code></pre></div></td></tr></table></figure><p>或者使用http协议：(慢)</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">$ git clone http://<br></code></pre></div></td></tr></table></figure><h2 id="2-git操作"><a href="#2-git操作" class="headerlink" title="2. git操作"></a>2. git操作</h2><ol><li><p>撤销修改</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout -- xxx //让这个文件回到最近一次git commit或git add时的状态。<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git reset HEAD xxx//可以把暂存区的修改撤销掉（unstage），<br></code></pre></div></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习学习笔记</title>
    <link href="/2021/09/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/09/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Part1-小实验"><a href="#Part1-小实验" class="headerlink" title="Part1: 小实验"></a>Part1: 小实验</h1><h2 id="1-实验一"><a href="#1-实验一" class="headerlink" title="1.实验一"></a>1.实验一</h2><h3 id="1-1-KNN基本实现"><a href="#1-1-KNN基本实现" class="headerlink" title="1.1 KNN基本实现"></a>1.1 KNN基本实现</h3><h4 id="KNN基本流程"><a href="#KNN基本流程" class="headerlink" title="KNN基本流程"></a>KNN基本流程</h4><p> （1）收集数据：确定训练样本集合测试数据；</p><p> （2）计算测试数据和训练样本集中每个样本数据的距离(常用欧氏距离和曼哈顿距离)</p><p>   (3）按照距离递增的顺序排序；</p><p>（4）选取距离最近的<strong>k</strong>个点；</p><p>（5）确定这k个点中分类信息的频率；</p><p>（6）返回前k个点中出现频率最高的分类，作为当前测试数据的分类。</p><h4 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#encoding=utf8</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> operator<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">kNNClassifier</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, k</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        初始化函数</span><br><span class="hljs-string">        :param k:kNN算法中的k</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        self.k = k<br>        <span class="hljs-comment"># 用来存放训练数据，类型为ndarray</span><br>        self.train_feature = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 用来存放训练标签，类型为ndarray</span><br>        self.train_label = <span class="hljs-literal">None</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, feature, label</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        kNN算法的训练过程</span><br><span class="hljs-string">        :param feature: 训练集数据，类型为ndarray</span><br><span class="hljs-string">        :param label: 训练集标签，类型为ndarray</span><br><span class="hljs-string">        :return: 无返回</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br><br>        <span class="hljs-comment">#********* Begin *********#</span><br>        self.train_feature=np.array(feature)<br>        self.train_label=np.array(label)<br>        <span class="hljs-comment">#********* End *********#</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self, feature</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        kNN算法的预测过程</span><br><span class="hljs-string">        :param feature: 测试集数据，类型为ndarray</span><br><span class="hljs-string">        :return: 预测结果，类型为ndarray或list</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br><br>        <span class="hljs-comment">#********* Begin *********#</span><br>        final_result=[] <span class="hljs-comment">#保存预测结果的空list</span><br>        <span class="hljs-keyword">for</span> test_feature <span class="hljs-keyword">in</span> feature:<br>            <span class="hljs-comment">#使用np的相关函数求出当前测试数据和每一个训练集数据的欧式距离，保存在distance列表中</span><br>            distance=[np.sqrt(np.<span class="hljs-built_in">sum</span>((test_feature-train_data)**<span class="hljs-number">2</span>)) <span class="hljs-keyword">for</span> train_data <span class="hljs-keyword">in</span> self.train_feature] <br>            <span class="hljs-comment">#也可使用如下的方法进行distance列表的计算,其中sum(axis=1)表示对矩阵的行进行求和 </span><br>            distance_2=((train_feature-test_feature) ** <span class="hljs-number">2</span>).<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) ** <span class="hljs-number">0.5</span><br>            <br>            <span class="hljs-comment">#使用argsort返回升序排序后的distance元素下标，并据此索引得到升序排列后的train_label</span><br>            sorted_index=np.argsort(distance)<br>            sorted_label=self.train_label[sorted_index] <br><span class="hljs-comment">#创建一个空字典，保存label计数结果</span><br>            sorted_dic=&#123;&#125;<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.k):  <span class="hljs-comment">#遍历前k个元素，以label为键值进行计数，结果保存为(label,count)的形式 </span><br>                sorted_dic[sorted_label[i]]=sorted_dic.get(sorted_label[i],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span><br>            <span class="hljs-comment">#调用sorted函数进行排序，得到最近邻，作为预测结果</span><br>            sorted_result=<span class="hljs-built_in">sorted</span>(sorted_dic.items(), key=operator.itemgetter(<span class="hljs-number">1</span>),reverse=<span class="hljs-literal">True</span>) <br>            final_result.append(sorted_result[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> final_result<br>        <span class="hljs-comment">#********* End *********#</span><br></code></pre></div></td></tr></table></figure><h4 id="调库侠"><a href="#调库侠" class="headerlink" title="调库侠"></a>调库侠</h4><p>可以实例化<code>sklearn</code>库中的<code>KNeighborsClassifier</code>和<code>StandardScaler</code>两个类，调用<code>fit_transform()</code>对数据进行标准化处理和<code>fit()</code>训练数据集后，将测试集数据传入<code>predict()</code>后进行数据集的预测。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classification</span>(<span class="hljs-params">train_feature, train_label, test_feature</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    对test_feature进行红酒分类</span><br><span class="hljs-string">    :param train_feature: 训练集数据，类型为ndarray</span><br><span class="hljs-string">    :param train_label: 训练集标签，类型为ndarray</span><br><span class="hljs-string">    :param test_feature: 测试集数据，类型为ndarray</span><br><span class="hljs-string">    :return: 测试集数据的分类结果</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-comment">#********* Begin *********#</span><br>    <span class="hljs-comment">#实例化对象</span><br>    scaler=StandardScaler() <br>    knn_classifier=KNeighborsClassifier() <br>    <span class="hljs-comment">#对数据进行标准化处理</span><br>    scaled_train_feature=scaler.fit_transform(train_feature)<br>    scaled_test_feature=scaler.fit_transform(test_feature)<br>    <span class="hljs-comment">#开始训练数据</span><br>    knn_classifier.fit(scaled_train_feature,train_label)<br>    <span class="hljs-comment">#输入测试数据，得到预测结果</span><br>    <span class="hljs-keyword">return</span> knn_classifier.predict(scaled_test_feature)<br>    <span class="hljs-comment">#********* End **********#</span><br></code></pre></div></td></tr></table></figure><h3 id="1-2-感知机"><a href="#1-2-感知机" class="headerlink" title="1.2 感知机"></a>1.2 感知机</h3><p>超平面的调整过程（调整法向量 ）：</p><p><img src="https://img-blog.csdn.net/20170312223154072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXJ0cHJvZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>机器学习</tag>
      
      <tag>课设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记</title>
    <link href="/2021/09/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/09/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>教程：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰的官方网站</a></p><h2 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1. 基本知识"></a>1. 基本知识</h2><ol><li>编写Python代码时，我们得到的是一个包含Python代码的以<code>.py</code>为扩展名的文本文件。要运行代码，就需要Python解释器去执行<code>.py</code>文件。<ul><li>在命令行下运行<code>python</code>就是启动CPython解释器，用<code>&gt;&gt;&gt;</code>作为提示符</li><li>Python交互模式的代码是输入一行，执行一行，而命令行模式下直接运行<code>.py</code>文件是一次性执行该文件内的所有代码。可见，Python交互模式主要是为了调试Python代码用的，也便于初学者学习，它不是正式运行Python代码的环境。</li></ul></li></ol><blockquote><p>看不下去了。。。转战<a href="https://www.runoob.com/python3">菜鸟</a></p></blockquote><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h2><h3 id="2-1-格式与符号"><a href="#2-1-格式与符号" class="headerlink" title="2.1 格式与符号"></a>2.1 格式与符号</h3><h4 id="1-标识符"><a href="#1-标识符" class="headerlink" title="1. 标识符"></a>1. 标识符</h4><ul><li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符对大小写敏感。</li></ul><p>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。</p><h4 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2. 关键字"></a>2. 关键字</h4><p>Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> keyword<br><span class="hljs-meta">&gt;&gt;&gt; </span>keyword.kwlist<br>[<span class="hljs-string">&#x27;False&#x27;</span>, <span class="hljs-string">&#x27;None&#x27;</span>, <span class="hljs-string">&#x27;True&#x27;</span>, <span class="hljs-string">&#x27;and&#x27;</span>, <span class="hljs-string">&#x27;as&#x27;</span>, <span class="hljs-string">&#x27;assert&#x27;</span>, <span class="hljs-string">&#x27;break&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;continue&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-string">&#x27;elif&#x27;</span>, <span class="hljs-string">&#x27;else&#x27;</span>, <span class="hljs-string">&#x27;except&#x27;</span>, <span class="hljs-string">&#x27;finally&#x27;</span>, <span class="hljs-string">&#x27;for&#x27;</span>, <span class="hljs-string">&#x27;from&#x27;</span>, <span class="hljs-string">&#x27;global&#x27;</span>, <span class="hljs-string">&#x27;if&#x27;</span>, <span class="hljs-string">&#x27;import&#x27;</span>, <span class="hljs-string">&#x27;in&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;lambda&#x27;</span>, <span class="hljs-string">&#x27;nonlocal&#x27;</span>, <span class="hljs-string">&#x27;not&#x27;</span>, <span class="hljs-string">&#x27;or&#x27;</span>, <span class="hljs-string">&#x27;pass&#x27;</span>, <span class="hljs-string">&#x27;raise&#x27;</span>, <span class="hljs-string">&#x27;return&#x27;</span>, <span class="hljs-string">&#x27;try&#x27;</span>, <span class="hljs-string">&#x27;while&#x27;</span>, <span class="hljs-string">&#x27;with&#x27;</span>, <span class="hljs-string">&#x27;yield&#x27;</span>]<br></code></pre></div></td></tr></table></figure><h4 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h4><ul><li>单行注释以 <strong>#</strong> 开头，多行注释用 <strong>‘’’</strong> 或**”””**将注释包裹起来</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure><ul><li>在Linux/Unix系统中，你可以在脚本顶部添加以下命令让Python脚本可以像SHELL脚本一样可直接执行：</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/env python3</span><br><span class="hljs-comment"># 经测试，python2和python3都行，python时不行，大概是版本支持问题 </span><br></code></pre></div></td></tr></table></figure><p>然后修改脚本权限，使其有执行权限，然后输入py文件名即可直接执行。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./hello.py</span><br></code></pre></div></td></tr></table></figure><h4 id="4-缩进和空行"><a href="#4-缩进和空行" class="headerlink" title="4. 缩进和空行"></a>4. 缩进和空行</h4><ul><li><p>python最具特色的就是使用<strong>缩进</strong>来表示代码块，不需要使用大括号 <strong>{}</strong> ，缩进相同的一组语句<strong>构成一个代码块</strong>，我们称之代码组。</p><p>缩进的空格数是可变的，但是<strong>同一个代码块的语句必须包含相同的缩进空格数</strong>。实例如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:    <br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;True&quot;</span>) <br><span class="hljs-keyword">else</span>:    <br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;False&quot;</span>)<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;不一致&quot;</span>)   <span class="hljs-comment">#缩进不一致，会导致运行错误</span><br></code></pre></div></td></tr></table></figure><p>​        像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p><p>​        将首行及后面的代码组称为一个**子句(clause)**。</p><ul><li><p>函数之间或类的方法之间用<strong>空行</strong>分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p><p><strong>记住：</strong>空行也是程序代码的一部分。</p></li></ul><h4 id="5-长语句"><a href="#5-长语句" class="headerlink" title="5. 长语句"></a>5. 长语句</h4><ul><li><p>使用反斜杠 <code>\</code> 来实现多行语句；在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 <code>\</code>。（即括号中的内容不需要使用反斜杠）</p></li><li><p>在同一行中使用多条语句，语句之间使用分号 <code>; </code>分割。</p></li></ul><h4 id="6-输入与输出"><a href="#6-输入与输出" class="headerlink" title="6. 输入与输出"></a>6. 输入与输出</h4><ul><li><code>input</code>用于输入</li><li><code>print</code>用于输出，默认是换行的，如果要实现不换行需要在变量末尾加上<code> end=&quot;&quot;</code></li></ul><h4 id="7-导入"><a href="#7-导入" class="headerlink" title="7.导入"></a>7.导入</h4><p>将整个模块x导入：<code>import x</code></p><p>从某个模块x中导入某个函数y：<code>from x import y</code></p><p>从某个模块x中导入多个函数y, z： <code>from x import y,z</code></p><p>将某个模块x中的全部函数导入：<code>from x import *</code></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys  <span class="hljs-comment"># 导入模块sys</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;================Python import mode==========================&#x27;</span>)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;命令行参数为:&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sys.argv:<br>    <span class="hljs-built_in">print</span> (i)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;\n python 路径为&#x27;</span>,sys.path)<br><br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argv,path  <span class="hljs-comment">#  导入特定的成员</span><br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;================python from import===================================&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;path:&#x27;</span>,path) <span class="hljs-comment"># 因为已经导入path成员，所以此处引用时不需要加sys.path</span><br></code></pre></div></td></tr></table></figure><h3 id="2-2-基本数据类型"><a href="#2-2-基本数据类型" class="headerlink" title="2.2 基本数据类型"></a>2.2 基本数据类型</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p>变量不需要声明。每个变量在使用前都必须赋值，变量赋值（=）以后该变量才会被创建。</p><ul><li><p>允许多变量赋值</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = b = c = <span class="hljs-number">1</span> <span class="hljs-comment"># 创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。</span><br></code></pre></div></td></tr></table></figure></li><li><p>也可以为多个对象指定多个变量。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;runoob&quot;</span> <span class="hljs-comment"># 两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 &quot;runoob&quot; 分配给变量 c。</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>在 Python 中变量<strong>没有类型</strong>，我们所说的”类型”是变量所指的内存中对象的类型。</p></li></ul><h4 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h4><ul><li><p>不可变数据：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>Tuple（元组）</li></ul></li><li><p>可变数据：</p><ul><li>List（列表）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul></li></ul><h5 id="1-不可变数据类型"><a href="#1-不可变数据类型" class="headerlink" title="1. 不可变数据类型"></a>1. 不可变数据类型</h5><h6 id="1-1-Number（数字）"><a href="#1-1-Number（数字）" class="headerlink" title="1.1 Number（数字）"></a>1.1 Number（数字）</h6><p>Python3 支持 <strong>int、float、bool、complex（复数）</strong></p><ul><li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li><li><strong>bool</strong> (布尔), 如 True。</li><li><strong>float</strong> (浮点数), 如 1.23、3E-2</li><li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><blockquote><p>复数可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</p></blockquote><ul><li><p>指定一个值时，Number 对象就会被创建</p></li><li><p>使用<code>del</code>语句删除对象引用。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 语法：del var1[,var2[,var3[....,varN]]]</span><br><span class="hljs-keyword">del</span> var<br><span class="hljs-keyword">del</span> var_a, var_b<br></code></pre></div></td></tr></table></figure></li><li><p><code>type() </code>函数可以用来查询变量所指的对象类型，但不会认为子类是一种父类类型</p></li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="hljs-number">20</span>, <span class="hljs-number">5.5</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">4</span>+<span class="hljs-number">3j</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">type</span>(b), <span class="hljs-built_in">type</span>(c), <span class="hljs-built_in">type</span>(d))<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">int</span>&#x27;&gt; &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">float</span>&#x27;&gt; &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">bool</span>&#x27;&gt; &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">complex</span>&#x27;&gt;</span><br></code></pre></div></td></tr></table></figure><p>​      此外还可以用 <code>isinstance()</code> 来判断，会认为子类是一种父类类型。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">111</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">int</span>)<br><span class="hljs-literal">True</span><br></code></pre></div></td></tr></table></figure><blockquote><p>Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加，可以通过<code>is</code>判断类型</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">issubclass</span>(<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">int</span>) <br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span>==<span class="hljs-number">1</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span>+<span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></div></td></tr></table></figure><h6 id="1-2-String（字符串）"><a href="#1-2-String（字符串）" class="headerlink" title="1.2 String（字符串）"></a>1.2 String（字符串）</h6><blockquote><p>字符串用单引号<code>&#39;</code> 或双引号<code>&quot;</code>括起来，同时使用反斜杠<code>\</code> 转义特殊字符</p></blockquote><ul><li><p>字符串格式化</p><ul><li>使用与 C 中 <code>sprintf</code> 函数一样的语法。</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;我叫 %s 今年 %d 岁!&quot;</span> % (<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">10</span>))<br>&gt;&gt;&gt;我叫 小明 今年 <span class="hljs-number">10</span> 岁!<br></code></pre></div></td></tr></table></figure><ul><li><strong>f-string</strong> 格式化字符串：以 <strong>f</strong> 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去。    </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name = <span class="hljs-string">&#x27;Runoob&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f&#x27;Hello <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>  <span class="hljs-comment"># 替换变量</span><br><span class="hljs-string">&#x27;Hello Runoob&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-number">1</span>+<span class="hljs-number">2</span>&#125;</span>&#x27;</span>         <span class="hljs-comment"># 使用表达式</span><br><span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>w = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;w[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span>: <span class="hljs-subst">&#123;w[<span class="hljs-string">&quot;url&quot;</span>]&#125;</span>&#x27;</span><br><span class="hljs-string">&#x27;Runoob: www.runoob.com&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;x+<span class="hljs-number">1</span>=&#125;</span>&#x27;</span>)   <span class="hljs-comment"># Python 3.8</span><br>x+<span class="hljs-number">1</span>=<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure></li><li><p>python中单引号和双引号使用完全相同。<strong>单引号=双引号</strong></p></li><li><p>使用三引号(<strong>‘’’</strong> 或 <strong>“””</strong>)可以指定一个多行字符串。</p></li><li><p>转义符 <code>\</code>。</p><p>使用r（ raw）可以让反斜杠不发生转义。 如<code>r&quot;this is a line with \n&quot;</code>，则\n会显示，并不是换行。</p></li><li><p>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</p></li><li><p>字符串可以用<code>+</code>运算符连接在一起，用 <code>* </code>运算符复制当前字符串。</p></li><li><p>字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</p></li></ul><img src="https://www.runoob.com/wp-content/uploads/2013/11/python-string-slice.png" alt="两种索引"  /><ul><li><p>字符串<strong>不能改变</strong>，向一个索引位置赋值，比如<code>word[0] = &#39;m&#39;</code>会导致错误。</p></li><li><p><strong>没有单独的字符类型</strong>，一个字符就是长度为 1 的字符串。</p></li><li><p>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></p><blockquote><p>前闭后开，str[0:5]取的是第1个到第5个的字符，str[5]不取</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span>=<span class="hljs-string">&#x27;123456789</span><br><span class="hljs-string"> </span><br><span class="hljs-string">print(str)                 # 输出字符串</span><br><span class="hljs-string">print(str[0:-1])           # 输出第一个到倒数第二个的所有字符</span><br><span class="hljs-string">print(str[0])              # 输出字符串第一个字符</span><br><span class="hljs-string">print(str[2:5])            # 输出从第三个开始到第五个的字符</span><br><span class="hljs-string">print(str[2:])             # 输出从第三个开始后的所有字符</span><br><span class="hljs-string">print(str[1:5:2])          # 输出从第二个开始到第五个且每隔一个的字符（步长为2）</span><br><span class="hljs-string">print(str * 2)             # 输出字符串两次</span><br><span class="hljs-string">print(str + &#x27;</span>你好<span class="hljs-string">&#x27;)         # 连接字符串</span><br><span class="hljs-string"> </span><br><span class="hljs-string">print(&#x27;</span>------------------------------<span class="hljs-string">&#x27;)</span><br><span class="hljs-string"> </span><br><span class="hljs-string">print(&#x27;</span>hello\nrunoo<span class="hljs-string">b&#x27;)      # 使用反斜杠(\)+n转义特殊字符</span><br><span class="hljs-string">print(r&#x27;</span>hello\nrunoo<span class="hljs-string">b&#x27;)     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span><br></code></pre></div></td></tr></table></figure><ul><li>常用函数详见<a href="https://www.runoob.com/python3/python3-string.html">菜鸟教程</a></li></ul><h6 id="1-3-Tuple（元组）-x-y-…"><a href="#1-3-Tuple（元组）-x-y-…" class="headerlink" title="1.3 Tuple（元组）(x, y, …)"></a>1.3 Tuple（元组）(x, y, …)</h6><blockquote><p>元组（tuple）与列表类似，不同之处在于<strong>元组的元素不能修改</strong>。</p><p>元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p><p>元组中的元素类型也可以不相同。</p></blockquote><ul><li><p>索引、截取和连接的方式与字符串、列表相同，可以把字符串看作一种特殊的元组。</p></li><li><p>虽然tuple的元素不可改变，但它<strong>可以包含可变的对象</strong>，比如list列表。</p></li><li><p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">tup1 = ()    <span class="hljs-comment"># 空元组</span><br>tup2 = (<span class="hljs-number">20</span>,) <span class="hljs-comment"># 一个元素，需要在元素后添加逗号</span><br></code></pre></div></td></tr></table></figure><h5 id="2-可变数据类型"><a href="#2-可变数据类型" class="headerlink" title="2.可变数据类型"></a>2.可变数据类型</h5><h6 id="2-1-List（列表）-x-y-…"><a href="#2-1-List（列表）-x-y-…" class="headerlink" title="2.1 List（列表）[x, y, …]"></a>2.1 List（列表）[x, y, …]</h6><blockquote><p>列表是写在方括号<code>[]</code>之间、用逗号分隔开的元素列表。</p></blockquote><p>和<code>String</code>一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><ul><li><p>索引值以 <strong>0</strong> 为开始值，**-1** 为从末尾的开始位置。</p><p>列表截取的语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">变量<span class="hljs-selector-attr">[头下标:尾下标: 步长(可选)]</span><br></code></pre></div></td></tr></table></figure></li></ul><blockquote><p>注意观察下图所给出的四个列表截取的例子</p></blockquote><img src="https://www.runoob.com/wp-content/uploads/2014/08/list_slicing1_new1.png" alt="List索引图" style="zoom: 67%;" /><p>​    如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span><br>inputWords = <span class="hljs-built_in">input</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br><br><span class="hljs-comment"># 翻转字符串</span><br><span class="hljs-comment"># 假设列表 list = [1,2,3,4],  </span><br><span class="hljs-comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span><br><span class="hljs-comment"># inputWords[-1::-1] 有三个参数</span><br><span class="hljs-comment"># 第一个参数 -1 表示最后一个元素</span><br><span class="hljs-comment"># 第二个参数为空，表示移动到列表末尾</span><br><span class="hljs-comment"># 第三个参数为步长，-1 表示逆向</span><br>inputWords=inputWords[-<span class="hljs-number">1</span>::-<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 重新组合字符串</span><br>output = <span class="hljs-string">&#x27; &#x27;</span>.join(inputWords)<br><br><span class="hljs-keyword">return</span> output<br></code></pre></div></td></tr></table></figure><ul><li>加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。</li></ul><blockquote><p> 和<code>String</code>不一样的地方在于<code>List</code>是可变的。</p></blockquote><h6 id="2-2-Set（集合）-x-y-…"><a href="#2-2-Set（集合）-x-y-…" class="headerlink" title="2.2 Set（集合）{x, y, …}"></a>2.2 Set（集合）{x, y, …}</h6><blockquote><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以<strong>使用大括号 { } 或者 set() 函数</strong>创建集合</p></blockquote><p>注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p><p>创建格式：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">parame = &#123;value01,value02,...&#125;<br>或者<br><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(value)</span></span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br>sites = &#123;<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Facebook&#x27;</span>, <span class="hljs-string">&#x27;Zhihu&#x27;</span>, <span class="hljs-string">&#x27;Baidu&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span>(sites)   <span class="hljs-comment"># 输出集合，重复的元素被自动去掉</span><br><br><span class="hljs-comment"># 成员测试</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Runoob&#x27;</span> <span class="hljs-keyword">in</span> sites :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Runoob 在集合中&#x27;</span>)<br><span class="hljs-keyword">else</span> :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Runoob 不在集合中&#x27;</span>)<br><br><span class="hljs-comment"># set可以进行集合运算</span><br>a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;abracadabra&#x27;</span>)<br>b = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;alacazam&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(a - b)     <span class="hljs-comment"># a 和 b 的差集</span><br><span class="hljs-built_in">print</span>(a | b)     <span class="hljs-comment"># a 和 b 的并集</span><br><span class="hljs-built_in">print</span>(a &amp; b)     <span class="hljs-comment"># a 和 b 的交集</span><br><span class="hljs-built_in">print</span>(a ^ b)     <span class="hljs-comment"># a 和 b 中不同时存在的元素</span><br></code></pre></div></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;Zhihu&#x27;</span>, <span class="hljs-string">&#x27;Baidu&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Facebook&#x27;</span>&#125;<br>Runoob 在集合中<br>&#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="2-3-Dictionary（字典）-key-value-…"><a href="#2-3-Dictionary（字典）-key-value-…" class="headerlink" title="2.3 Dictionary（字典）{key: value, …}"></a>2.3 Dictionary（字典）{key: value, …}</h6><blockquote><p>列表是有序的对象集合，字典是<strong>无序的对象集合</strong>。两者之间的区别在于：字典当中的元素是<strong>通过键来存取</strong>的，而不是通过偏移存取。</p><p>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p></blockquote><p>注意： 键(key)必须<strong>使用不可变类型</strong>。在同一个字典中，键(key)<strong>必须是唯一</strong>的。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-built_in">dict</span> = &#123;&#125;<br><span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;one&#x27;</span>] = <span class="hljs-string">&quot;1 - 菜鸟教程&quot;</span><br><span class="hljs-built_in">dict</span>[<span class="hljs-number">2</span>]     = <span class="hljs-string">&quot;2 - 菜鸟工具&quot;</span><br><br>tinydict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;runoob&#x27;</span>,<span class="hljs-string">&#x27;code&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;site&#x27;</span>: <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;one&#x27;</span>])       <span class="hljs-comment"># 输出键为 &#x27;one&#x27; 的值</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">dict</span>[<span class="hljs-number">2</span>])           <span class="hljs-comment"># 输出键为 2 的值</span><br><span class="hljs-built_in">print</span> (tinydict)          <span class="hljs-comment"># 输出完整的字典</span><br><span class="hljs-built_in">print</span> (tinydict.keys())   <span class="hljs-comment"># 输出所有键</span><br><span class="hljs-built_in">print</span> (tinydict.values()) <span class="hljs-comment"># 输出所有值</span><br></code></pre></div></td></tr></table></figure><ul><li><p>构造函数 dict() 可以直接从键值对序列中构建字典</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>([(<span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-number">3</span>)])<br>&#123;<span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)&#125;<br>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">6</span>: <span class="hljs-number">36</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>(Runoob=<span class="hljs-number">1</span>, Google=<span class="hljs-number">2</span>, Taobao=<span class="hljs-number">3</span>)<br>&#123;<span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td align="left">将x转换为一个整数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td align="left">将x转换到一个浮点数</td></tr><tr><td align="left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td align="left">创建一个复数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td align="left">将对象 x 转换为字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td align="left">将对象 x 转换为表达式字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td align="left">将序列 s 转换为一个元组</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td align="left">将序列 s 转换为一个列表</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td align="left">转换为可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td align="left">转换为不可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td align="left">将一个整数转换为一个字符</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td align="left">将一个字符转换为它的整数值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td align="left">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h3 id="2-3-运算符"><a href="#2-3-运算符" class="headerlink" title="2.3 运算符"></a>2.3 运算符</h3><p>大致与C相同，不同之处如下：</p><h4 id="1-逻辑运算符"><a href="#1-逻辑运算符" class="headerlink" title="1. 逻辑运算符"></a>1. 逻辑运算符</h4><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table><blockquote><p>其实本质上和&amp;&amp;还是一样的。这样理解and运算符：x为假时返回x的值，否则返回y的值，这就保证了与运算的逻辑，一定能返回x&amp;&amp;y的值，如果x为真时，表达式的值就由y决定，这和c语言在处理&amp;&amp;时的优化也是一样的。</p></blockquote><h4 id="2-成员运算符"><a href="#2-成员运算符" class="headerlink" title="2. 成员运算符"></a>2. 成员运算符</h4><p>Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h4 id="3-身份运算符"><a href="#3-身份运算符" class="headerlink" title="3. 身份运算符"></a>3. 身份运算符</h4><p>身份运算符用于比较两个对象的存储单元。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><blockquote><p><strong>注：</strong> <a href="https://www.runoob.com/python/python-func-id.html">id()</a> 函数用于获取对象内存地址。</p></blockquote><p><strong>is 与 == 区别：</strong>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p><h4 id="4-算术运算符"><a href="#4-算术运算符" class="headerlink" title="4. 算术运算符"></a>4. 算术运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的21次方</td></tr><tr><td align="left">//</td><td align="left">取整除 - <strong>向下取</strong>接近商的整数</td><td align="left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table><p><strong>注意：</strong>// 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。</p><p>在交互模式中，最后被输出的表达式结果被赋值给变量 <code>_</code> 。例如：</p><figure class="highlight python-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">tax = <span class="hljs-number">12.5</span> / <span class="hljs-number">100</span></span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">price = <span class="hljs-number">100.50</span></span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">price * tax</span><br>12.5625<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">price + _</span><br>113.0625<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">round</span>(_, <span class="hljs-number">2</span>)</span><br>113.06<br></code></pre></div></td></tr></table></figure><p>此处， <strong>_</strong> 变量应被用户视为只读变量。</p><h4 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">指数 (最高优先级)</td></tr><tr><td align="left">~ + -</td><td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td align="left">* / % //</td><td align="left">乘，除，求余数和取整除</td></tr><tr><td align="left">+ -</td><td align="left">加法减法</td></tr><tr><td align="left">&gt;&gt; &lt;&lt;</td><td align="left">右移，左移运算符</td></tr><tr><td align="left">&amp;</td><td align="left">位 ‘AND’</td></tr><tr><td align="left">^ |</td><td align="left">位运算符</td></tr><tr><td align="left">&lt;= &lt; &gt; &gt;=</td><td align="left">比较运算符</td></tr><tr><td align="left">== !=</td><td align="left">等于运算符</td></tr><tr><td align="left">= %= /= //= -= += *= **=</td><td align="left">赋值运算符</td></tr><tr><td align="left">is is not</td><td align="left">身份运算符</td></tr><tr><td align="left">in not in</td><td align="left">成员运算符</td></tr><tr><td align="left">not and or</td><td align="left">逻辑运算符（not&gt;and&gt;or）</td></tr></tbody></table><h3 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h3><h4 id="1-数学函数"><a href="#1-数学函数" class="headerlink" title="1. 数学函数"></a>1. 数学函数</h4><table><thead><tr><th align="left">函数</th><th align="left">返回值 ( 描述 )</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td align="left">返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td><td align="left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td align="left">cmp(x, y)</td><td align="left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td><td align="left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td align="left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td><td align="left">返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td><td align="left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td><td align="left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…)</a></td><td align="left">返回给定参数的最大值，参数可以为序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…)</a></td><td align="left">返回给定参数的最小值，参数可以为序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td><td align="left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td align="left">x**y 运算后的值。</td></tr><tr><td align="left">[round(x <a href="https://www.runoob.com/python3/python3-func-number-round.html">,n])</a></td><td align="left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td><td align="left">返回数字x的平方根。</td></tr></tbody></table><h4 id="2-随机数函数"><a href="#2-随机数函数" class="headerlink" title="2. 随机数函数"></a>2. 随机数函数</h4><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-choice.html">choice(seq)</a></td><td align="left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td align="left">[randrange (<a href="https://www.runoob.com/python3/python3-func-number-randrange.html">start,] stop [,step])</a></td><td align="left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-random.html">random()</a></td><td align="left">随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td align="left">[seed(<a href="https://www.runoob.com/python3/python3-func-number-seed.html">x])</a></td><td align="left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-shuffle.html">shuffle(lst)</a></td><td align="left">将序列的所有元素随机排序</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-uniform.html">uniform(x, y)</a></td><td align="left">随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table><h4 id="3-三角函数"><a href="#3-三角函数" class="headerlink" title="3. 三角函数"></a>3. 三角函数</h4><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-acos.html">acos(x)</a></td><td align="left">返回x的反余弦弧度值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-asin.html">asin(x)</a></td><td align="left">返回x的反正弦弧度值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-atan.html">atan(x)</a></td><td align="left">返回x的反正切弧度值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-atan2.html">atan2(y, x)</a></td><td align="left">返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-cos.html">cos(x)</a></td><td align="left">返回x的弧度的余弦值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-hypot.html">hypot(x, y)</a></td><td align="left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-sin.html">sin(x)</a></td><td align="left">返回的x弧度的正弦值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-tan.html">tan(x)</a></td><td align="left">返回x弧度的正切值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-degrees.html">degrees(x)</a></td><td align="left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-radians.html">radians(x)</a></td><td align="left">将角度转换为弧度</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洛谷刷题日记</title>
    <link href="/2021/09/07/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    <url>/2021/09/07/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="2021-9"><a href="#2021-9" class="headerlink" title="2021/9"></a>2021/9</h2><h3 id="9-24"><a href="#9-24" class="headerlink" title="9/24"></a>9/24</h3><p>今天的题比较简单</p><h3 id="9-23"><a href="#9-23" class="headerlink" title="9/23"></a>9/23</h3><p>​    19号的考试考了180，不算特别满意，但还算中等水平，170常规+10第四题蒙对了一个测试集，考试开始40分钟就拿了170，尝试了一个小时优化第二题，失败了，然后剩下的时间有点不知道在干啥，蒙了一个小时测试集，运气好蒙对一个。但是zhx写了一个小时第四题，用递归做的，拿了20分，说明也不是完全不能做，有点被题目吓到了，下次应该冷静下来思考思考，前几个测试集应该还是不难的。</p><p>​    考完试给自己放了两天假，有点放过猛了hhh，最近两天都没刷题，打了好多游戏。</p><p>​    不过没关系，及时调整就好。从明天开始恢复每日刷题！加油: D</p><h3 id="9-18"><a href="#9-18" class="headerlink" title="9/18"></a>9/18</h3><h4 id="考前复习"><a href="#考前复习" class="headerlink" title="考前复习"></a>考前复习</h4><blockquote><p>看了几个b站视频，在这里梳理一下</p></blockquote><h5 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h5><ul><li><p>注意细节：</p><ul><li>long long：有时候用int可能会爆</li><li>边界</li><li>特殊情况</li></ul></li><li><p>一些技巧：</p><ul><li><p>声明数组大小的时候，最好用const定义伪常量方便修改。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1005</span>;<br><span class="hljs-keyword">int</span> num[N];<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><h5 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h5><ul><li>STL！</li></ul><h5 id="注意点：考场的vsc没网，使用g-编译"><a href="#注意点：考场的vsc没网，使用g-编译" class="headerlink" title="注意点：考场的vsc没网，使用g++编译"></a>注意点：考场的vsc没网，使用g++编译</h5><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ g++ xxx.cpp -o xxx -Wall <span class="hljs-comment">#Wall代表Warning all,列举所有警告的意思</span><br>$ ./xxx <span class="hljs-comment">#执行</span><br></code></pre></div></td></tr></table></figure><h4 id="201912-2-回收站"><a href="#201912-2-回收站" class="headerlink" title="201912-2 回收站"></a>201912-2 回收站</h4><p>题目链接看<a href="http://118.190.20.162/view.page?gpid=T99">这里</a>。</p><blockquote><p>题意概括：给你n（n&lt;=1000）个回收站坐标(x, y)，其中x和y的范围可以达到10的九次方。对于一个点，要求其上下左右都有回收站，求出该点的四个斜角有回收站的数目，分别计入得分0-4分，输出0-4分的回收站数目。</p></blockquote><h5 id="思路记录"><a href="#思路记录" class="headerlink" title="思路记录"></a>思路记录</h5><ul><li>第一反应是用map，因为map处理大量数据感觉很方便，但是map没有一个查找是否存在目标键值对的函数，只有查找键值的函数<code>find()</code>, 所以不适合本题这种一个键值x有多个映射、且需要多次遍历上下左右点的题型。</li><li>然后就想到开一个二维数组，<code>(x, y)</code>对应<code>pos[x][y]=1</code>，但是因为x和y的范围为10^9^，显然内存开销过大，但是因为一下子没有想到其他方法，还以为本题需要用到前缀和这种知识，一下子没想到怎么转换dp, 就想着先写一个1000大小的二维数组再说。只拿了50分。<del>至少50分到手</del></li><li>然后就去百度了，以为会有什么高级的技巧，没想到搜到的是：不要用<code>pos[x][y]=1</code>来记录，而是用<code>pos[i][0]=x,pos[i][1]=y</code>的方式记录第i个点的信息。<del>我怎么没想到。。</del> 这样做虽然不像之前那样可以直接通过<code>pos[i+1][j]</code>访问到上面的元素，但是写一个for循环逐个遍历也不算太耗时间。改了改顺利拿到100。</li></ul><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,i,j,pos[<span class="hljs-number">1005</span>][<span class="hljs-number">2</span>],x,y,s[<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x=pos[t][<span class="hljs-number">0</span>],y=pos[t][<span class="hljs-number">1</span>],num=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//这里不要偷懒，最好不要用和主函数中一样的循环变量，真的容易一下子搞错。。。mn,ij都行，别偷懒！</span><br>        <span class="hljs-keyword">if</span>((pos[i][<span class="hljs-number">0</span>]==x)&amp;&amp;(pos[i][<span class="hljs-number">1</span>]==(y+<span class="hljs-number">1</span>)||pos[i][<span class="hljs-number">1</span>]==(y<span class="hljs-number">-1</span>))) num++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((pos[i][<span class="hljs-number">1</span>]==y)&amp;&amp;(pos[i][<span class="hljs-number">0</span>]==(x+<span class="hljs-number">1</span>)||pos[i][<span class="hljs-number">0</span>]==(x<span class="hljs-number">-1</span>))) num++;<br>    &#125;<br>    <span class="hljs-comment">//cout &lt;&lt; num &lt;&lt;endl;</span><br>    <span class="hljs-keyword">if</span> (num==<span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//说明合格选址，开始计算周围的垃圾</span><br>        num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>((pos[i][<span class="hljs-number">0</span>]==(x<span class="hljs-number">-1</span>))&amp;&amp;(pos[i][<span class="hljs-number">1</span>]==(y+<span class="hljs-number">1</span>)||pos[i][<span class="hljs-number">1</span>]==(y<span class="hljs-number">-1</span>))) num++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((pos[i][<span class="hljs-number">0</span>]==(x+<span class="hljs-number">1</span>))&amp;&amp;(pos[i][<span class="hljs-number">1</span>]==(y+<span class="hljs-number">1</span>)||pos[i][<span class="hljs-number">1</span>]==(y<span class="hljs-number">-1</span>))) num++;<br>        &#125;<br>        s[num]++;<br>    &#125;<br>    cout &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(pos,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pos));<br>    <span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s));<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);<br>        pos[i][<span class="hljs-number">0</span>]=x;<br>        pos[i][<span class="hljs-number">1</span>]=y;<span class="hljs-comment">//优化空间配置，避免开一个很大的数组浪费空间</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">judge</span>(i);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) cout &lt;&lt; s[i]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-17"><a href="#9-17" class="headerlink" title="9/17"></a>9/17</h3><h4 id="202006-2-稀疏向量"><a href="#202006-2-稀疏向量" class="headerlink" title="202006-2 稀疏向量"></a>202006-2 稀疏向量</h4><p>题目链接看<a href="http://118.190.20.162/view.page?gpid=T104">这里</a>。</p><blockquote><p>题意概括：给你两个稀疏向量，向量的每一维用(index, value)这样的键值对来表示，求出向量的内积</p></blockquote><h5 id="思路记录-1"><a href="#思路记录-1" class="headerlink" title="思路记录"></a>思路记录</h5><ul><li><p>首先想到的是先录入一个向量，然后在录入第二个向量的同时判断当前的index在第一个向量中有没有匹配的，但是这样还是有些麻烦。观察到给出的数值都非常大，向量的维度达到了10^5^量级，而限时2s,说明是不能使用双重循环的。然后就想到之前看到的<code>set</code>有<code>count</code>这个方法，能够快速查出当前集合中是否含有某个数值——这就启发我可以使用stl。</p></li><li><p>使用set有个问题，就算查到了存有这个index, 但是也不知道index对应的value, 思考了下使用数组记录，感觉不太行的样子。然后就想到了使用map（从来没用过）。百度了下基本的用法：</p><ul><li><code>map&lt;int,int&gt; idx</code>：创建一个map</li><li><code>idx.insert(pair&lt;int,int&gt;(1,10))</code>：插入（1，10）这个键值对</li><li><code>idx.find(idx0)</code>：若容器内存在键为<code>idx0</code>的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</li><li>迭代器：<ul><li><code>map&lt;int, int&gt;::iterator iter</code>：map的元素需要使用迭代器访问，这里创建了<code>map&lt;int,int&gt;</code>的迭代器<code>iter</code></li><li><code>*iter</code>：对迭代器解引用后即可得到键值对</li><li><code>(*iter).first</code>：得到键值对的第一个元素，同理，second得到第二个</li></ul></li></ul></li><li><p>然后就可以写了。但第一次提交只得到了60分，看了下测试集分布，后四个数据量很大，一开始怀疑是map爆了，使用<code>max_size()</code>方法输出了map的最大容量（10^18^量级），大得很。然后就可能是用于累加内积结果的变量溢出了，把其变量类型改为<code>long long</code>后拿到了100分。: D</p></li></ul><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; idx; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,a,b,idx0,val0;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; a&gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;idx0,&amp;val0);<br>        idx.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(idx0,val0));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;b;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;idx0,&amp;val0);<br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator iter;<br>        iter = idx.<span class="hljs-built_in">find</span>(idx0);<br>        <span class="hljs-keyword">if</span>(iter!=idx.<span class="hljs-built_in">end</span>())&#123;<br>            res+=val0*(*iter).second;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//cout &lt;&lt; idx.max_size()&lt;&lt;endl;//这里是测试map的最大容量</span><br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-16"><a href="#9-16" class="headerlink" title="9/16"></a>9/16</h3><h4 id="202009-2-风险人群筛查"><a href="#202009-2-风险人群筛查" class="headerlink" title="202009-2 风险人群筛查"></a>202009-2 风险人群筛查</h4><p>题目链接看<a href="http://118.190.20.162/view.page?gpid=T112">这里</a>。</p><blockquote><p>题意概括：给你n个人的t个坐标，若这些坐标连续k个以上落在给定的区间内，则计数。</p></blockquote><h5 id="思路记录-2"><a href="#思路记录-2" class="headerlink" title="思路记录"></a>思路记录</h5><p>暴力模拟能拿满分</p><blockquote><p>吐槽：看错了输出格式，用空格间隔而没用换行，就给我判全错。。非常智能</p></blockquote><h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,k,t,xl,yd,xr,yu,i,j,danger_in=<span class="hljs-number">0</span>,danger_stay=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> flag=<span class="hljs-literal">false</span>,flag2=<span class="hljs-literal">false</span>;<span class="hljs-comment">//用来标记该人是否已经被计入过</span><br>    cin &gt;&gt; n &gt;&gt; k &gt;&gt; t &gt;&gt; xl &gt;&gt; yd &gt;&gt; xr &gt;&gt; yu;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<br>        flag=<span class="hljs-literal">false</span>;<br>        flag2=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;t;j++)&#123;<br>            <span class="hljs-keyword">int</span> x,y;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);<br>            <span class="hljs-keyword">if</span>((x&gt;=xl&amp;&amp;x&lt;=xr)&amp;&amp;(y&gt;=yd&amp;&amp;y&lt;=yu)) num++;<br>            <span class="hljs-keyword">else</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//连续计数</span><br>            <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">0</span>&amp;&amp;!flag) &#123;<br>                danger_in++;<br>                flag=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num&gt;=k&amp;&amp;!flag2) &#123;<br>                danger_stay++;<br>                flag2=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; danger_in &lt;&lt; endl &lt;&lt; danger_stay;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-15"><a href="#9-15" class="headerlink" title="9/15"></a>9/15</h3><h4 id="202009-1-称检测点查询"><a href="#202009-1-称检测点查询" class="headerlink" title="202009-1 称检测点查询"></a>202009-1 称检测点查询</h4><p>题目链接看<a href="http://118.190.20.162/view.page?gpid=T113">这里</a>。</p><blockquote><p>题意概括：给你n个(x,y)坐标，找出离给定的(x0,y0)最近的前三个坐标的编号。</p><p>注意：距离相等时，优先输出编号小的。</p></blockquote><h5 id="思路记录-3"><a href="#思路记录-3" class="headerlink" title="思路记录"></a>思路记录</h5><p>很简单的模拟题，但是还是犯了小错误。</p><h5 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h5><ul><li><p>错误的使用了^2表示乘方。。。<del>傻逼</del></p></li><li><p>没有处理距离相等时，优先输出编号小的情况。其实想到了这一点，但是不理解sort函数的cmp比较函数的具体处理，在cmp函数中加入if语句处理距离相等的情况后满分通过。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(postion a,postion b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.dis==b.dis) <span class="hljs-keyword">return</span> a.num&lt;b.num;<span class="hljs-comment">//不加这个只有60分</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.dis &lt; b.dis;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="9-14"><a href="#9-14" class="headerlink" title="9/14"></a>9/14</h3><h4 id="202012-2-期末预测——还是前缀和"><a href="#202012-2-期末预测——还是前缀和" class="headerlink" title="202012-2 期末预测——还是前缀和"></a>202012-2 期末预测——还是前缀和</h4><p>题目链接看<a href="http://118.190.20.162/view.page?gpid=T122">这里</a></p><blockquote><p>题意概括：输入为多个同学的特殊得分和对应的挂科情况，求出符合人数最多的挂科阈值</p></blockquote><h5 id="思路记录-4"><a href="#思路记录-4" class="headerlink" title="思路记录"></a>思路记录</h5><ul><li><p>第一反应还是暴力，需要两层循环（遍历每个值，求出该情况下的预测准确个数），但是一看m最大能到10^5^，掐指一算，两层至少有10^10^的数量级的指令，而一般认为cpu每秒处理两三千万条指令，再掐指一算，10^7^数量级，题目限时1s，显然会超时。果然最后只有50分。</p><blockquote><p>经验：看到<strong>10^5^</strong>，就要条件反射不能两层循环！</p></blockquote></li><li><p>所以用前缀和。</p></li></ul><h5 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">int</span> score;<br>    <span class="hljs-keyword">int</span> res;<br>&#125; s[<span class="hljs-number">100005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(stu a,stu b)</span></span>&#123;<span class="hljs-comment">//此处定义的是sort的比较函数cmp</span><br>    <span class="hljs-keyword">return</span> a.score&lt;b.score; <span class="hljs-comment">//升序排列</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> m,sum[<span class="hljs-number">100005</span>],num=<span class="hljs-number">0</span>,num1=<span class="hljs-number">0</span>,max=<span class="hljs-number">0</span>,theata=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s));<br>    <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sum));<br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;= m;i++)&#123;<br>        cin &gt;&gt; s[i].score&gt;&gt; s[i].res;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+m+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        sum[i]=sum[i<span class="hljs-number">-1</span>]+s[i].res;<span class="hljs-comment">//统计小于等于本score下标的1的个数</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        num=<span class="hljs-number">0</span>;<br>        theata=s[i].score;<br>        num=i-sum[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>+s[i].res;<br>        <span class="hljs-keyword">while</span>(s[i+<span class="hljs-number">1</span>].score==theata)&#123;<br>            num+=s[i+<span class="hljs-number">1</span>].res;<br>            i++;<span class="hljs-comment">//这里对同等的score的情况做特殊处理</span><br>        &#125;<br>        num1=sum[m]-sum[i];<span class="hljs-comment">//表示s[i]之后，因为对相等的情况做了处理，所以s[i]之后的一定都是比它大的，直接计算1的个数，计入</span><br>        num+=num1;<br>        <span class="hljs-keyword">if</span>(num&gt;=max) &#123;<br>            ans=theata;<br>            max=num;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-13"><a href="#9-13" class="headerlink" title="9/13"></a>9/13</h3><blockquote><p>这周日去考csp了，做出签到题就是胜利！</p></blockquote><h4 id="202104-2-邻域均值——前缀和"><a href="#202104-2-邻域均值——前缀和" class="headerlink" title="202104-2 邻域均值——前缀和"></a>202104-2 邻域均值——前缀和</h4><p>题目链接看<a href="http://118.190.20.162/view.page?gpid=T127">这里</a></p><blockquote><p>题意概括：给一个矩阵，求每个点对应邻域(半径r由输入决定)的平均值，然后判断是否小于等于给定的阈值t，计数。</p></blockquote><h5 id="思路记录-5"><a href="#思路记录-5" class="headerlink" title="思路记录"></a>思路记录</h5><ul><li><p>第一反应是暴力遍历。但在写之前就感觉会超时，不过也不知道其他的办法，就先试试。首先需要遍历矩阵的每一个点，这里需要两重循环，然后对于该点，还需要两重循环来遍历，以确定在领域内的点，累加这些点的值，最后除以点的个数，与阈值t判断即可。</p><blockquote><p>这里粗心了，在计算平均值时没有使用浮点数除法，从而导致漏了几个点。修改后，不出所料，只有70分。</p></blockquote></li><li><p>于是去网上学习了一番，知道了<strong>前缀和</strong>这么个东西。根据题意做一点加加减减，这题就迎刃而解了。</p></li></ul><h5 id="知识点：前缀和"><a href="#知识点：前缀和" class="headerlink" title="知识点：前缀和"></a>知识点：前缀和</h5><blockquote><p>定义：前缀和是一个数组的<strong>某项下标之前</strong>(包括此项元素)的所有数组元素的和。</p><p>核心定义：某项下标之前！</p></blockquote><p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。<br>最简单的一道题就是给定 n 个数和 m 次询问，每次询问一段区间的和，求一个 O(n + m) 的做法。</p><blockquote><p>用 O(n) 前缀和预处理，O(m) 询问。</p></blockquote><p>设 <code>b[]</code> 为前缀和数组，<code>a[]</code> 为原数组，根据这句话可以得到前缀和的定义式和递推式：</p><table><thead><tr><th align="center"></th><th align="center">定义式</th><th align="center">递推式</th></tr></thead><tbody><tr><td align="center">一维前缀和</td><td align="center"><img src="https://math.jianshu.com/math?formula=b%5Bi%5D%20=%20%5Csum_%7Bj=0%7D%5E%7Bi%7Da%5Bj%5D"></td><td align="center"><img src="https://math.jianshu.com/math?formula=b%5Bi%5D%20=%20b%5Bi-1%5D%20+%20a%5Bi%5D"></td></tr><tr><td align="center">二维前缀和</td><td align="center"><img src="https://math.jianshu.com/math?formula=b%5Bx%5D%5By%5D%20=%20%5Csum_%7Bi=0%7D%5E%7Bx%7D%5Csum_%7Bj=0%7D%5E%7By%7Da%5Bi%5D%5Bj%5D"></td><td align="center"><img src="https://math.jianshu.com/math?formula=b%5Bx%5D%5By%5D%20=%20b%5Bx-1%5D%5By%5D%20+%20b%5Bx%5D%5By-1%5D%20-%20b%5Bx-1%5D%5By-1%5D%20+%20b%5Bx%5D%5By%5D"></td></tr></tbody></table><h5 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>],n,L,r,t,res=<span class="hljs-number">0</span>,tmp,i,j,cal=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(sum, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sum));<br>    cin &gt;&gt; n &gt;&gt; L &gt;&gt; r &gt;&gt; t;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;=n;j++)&#123;<br>            cin &gt;&gt; tmp;<br>            sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+tmp;<span class="hljs-comment">//前缀和数组sum</span><br>            <span class="hljs-comment">//一开始下标从0开始，导致出错，注意此处的i-1,并且数组应该全部初始化为0</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n;j++)&#123;<br>            <span class="hljs-keyword">int</span> x=i-r&gt;<span class="hljs-number">0</span>?i-r:<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> y=j-r&gt;<span class="hljs-number">0</span>?j-r:<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> x1=i+r&lt;=n?i+r:n;<br>            <span class="hljs-keyword">int</span> y1=j+r&lt;=n?j+r:n;<span class="hljs-comment">//这里的四个变量用于控制边界，个人认为比较巧妙</span><br>            tmp=sum[x1][y1]-sum[x<span class="hljs-number">-1</span>][y1]-sum[x1][y<span class="hljs-number">-1</span>]+sum[x<span class="hljs-number">-1</span>][y<span class="hljs-number">-1</span>];<br>            cal=(x1-x+<span class="hljs-number">1</span>)*(y1-y+<span class="hljs-number">1</span>);<span class="hljs-comment">//同理</span><br>            <span class="hljs-keyword">if</span>(tmp*<span class="hljs-number">1.0</span>/cal &lt;= t) res++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-10"><a href="#9-10" class="headerlink" title="9/10"></a>9/10</h3><blockquote><p>咕几天，学python    : D</p></blockquote><h3 id="9-9"><a href="#9-9" class="headerlink" title="9/9"></a>9/9</h3><h4 id="P1322-logo语言"><a href="#P1322-logo语言" class="headerlink" title="P1322 logo语言"></a>P1322 logo语言</h4><blockquote><p>难度：普及/提高-</p></blockquote><blockquote><p>题意概括：输入一行字符串，输出海龟在屏幕中离开原来位子的距离；三个语句：前进FD ,倒退BK 和重复REPEAT，直线移动。</p></blockquote><h5 id="思路记录-6"><a href="#思路记录-6" class="headerlink" title="思路记录"></a>思路记录</h5><ul><li>首先观察测试集，看到有<code> REPEAT 5[FD 100 BK 50]</code>，如果是字符串读取，从左到右，读到repeat时什么操作也无法进行，只能继续读取，说明需要使用递归，从内而外地处理。可以将repeat类比为乘法操作，其余为加法和减法操作。</li><li>一开始想要使用cin读取字符串，即将<code>FD</code>这种指令和<code>[]</code>分开处理，不过在写的过程中很快就感受到不便于处理。所以我们可以一律采用cin读取char,如果读取到指令的首字母，说明接下来的是指令，则再使用一个<code>string</code>类型的变量<code>trash</code>过滤掉其余的字母即可。</li></ul><h5 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//REPEAT 5[ FD 50 REPEAT 10[FD 100]]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,tmp;<br>    <span class="hljs-keyword">char</span> ch;<br>    string trash;<br>    <span class="hljs-keyword">while</span> (cin&gt;&gt;ch)&#123;<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//特判 REPEAT 5[]这种情况</span><br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>            cin &gt;&gt; trash &gt;&gt;tmp;<br>            res+=tmp;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;B&#x27;</span>)&#123;<br>            cin &gt;&gt; trash &gt;&gt;tmp;<br>            res-=tmp;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;R&#x27;</span>)&#123;<br>            cin &gt;&gt; trash &gt;&gt;tmp;<br>            <span class="hljs-built_in">getchar</span>();<span class="hljs-comment">// 去除[</span><br>            res+=tmp*<span class="hljs-built_in">logo</span>();<br>        &#125;<br>        ch=<span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//单层深度的递归调用只处理一对括号</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">logo</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-8"><a href="#9-8" class="headerlink" title="9/8"></a>9/8</h3><h4 id="P1886-滑动窗口-【模板】单调队列"><a href="#P1886-滑动窗口-【模板】单调队列" class="headerlink" title="P1886 滑动窗口 /【模板】单调队列"></a>P1886 滑动窗口 /【模板】单调队列</h4><blockquote><p>难度：普及/提高-</p></blockquote><blockquote><p>题意概括：有一个长为 n 的序列a，以及一个大小为k的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p></blockquote><h5 id="思路记录-7"><a href="#思路记录-7" class="headerlink" title="思路记录"></a>思路记录</h5><ul><li><p>第一反应是暴力，但是一看数据集，显然会TLE，而且效率很低，大部分元素都会被访问n次。没学过单调队列，但是能从单调栈类推过来。初始思路是想用一个队列同时解决最大值和最小值，但是很快就被否决了，一方面这变成了排序问题，另一方面这和输出格式有冲突——输出要求最大和最小分行输出。按照现有的单调栈的知识，我认为这个单调的魅力就在于：输入数据的同时，利用单调性，维护栈/队列，对元素进行push、pop操作，从而使得需要的答案为top或head/tail元素。</p></li><li><p>所以这道题需要遍历两次数组，分别处理最大值和最小值，显然搞清楚最大值，最小值就是换个比较符号的事情。很容易看出每个元素只会被访问一次，所以能达到<code>O(N)</code>的复杂度。</p><blockquote><p>有思路了，但是好累，晚上去了健身房，昏昏沉沉的，效率太低了，先睡了: D，明天上午补上代码。咕咕咕</p></blockquote></li></ul><h5 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h5><p>现在来考虑最小值。很容易想到的是，想要求最小值，我们只需要维护一个单调递增的单调队列即可，队首元素即为当前的最小值。我们使用两个指针<code>head</code>和<code>tail</code>来标记队列的队首和队尾。我们需要考虑三点：</p><ul><li>何时出队？<ul><li>队首元素：因为我们会对队伍元素频繁进行出入队操作，所以需要再开一个数组p，记录一下队首元素的下标。从当前遍历的第i个元素往后数，不在<code>k</code>个数的范围内时，即<code>p[head]&lt;=i-k</code>。<code>head++</code></li><li>队尾元素：<code>a[i]</code>的加入破坏了队列的单调递增性。<code>tail--</code></li></ul></li><li>何时入队？<ul><li><code>a[i]</code>比队尾元素大：如果<code>a[i+1]</code>和<code>a[i+2]</code>都比<code>a[i]</code>大，那么<code>a[i]</code>还是有可能成为最小值的；而且<code>a[i]</code>的加入并不会影响队首元素（输出最小值只和队首元素有关），所以<code>a[i]</code>入队/</li><li><code>a[i]</code>比队尾元素小：此时队尾元素就需要出队了，直到<code>a[i]</code>比队尾元素大或队列为空时，入队。</li></ul></li><li>何时输出？<ul><li><code>i&lt;k</code>时，我们还没完成对第一个窗口的处理，所以不需要输出。</li><li><code>i&gt;=k</code>时，每遍历一个元素（i++），就要输出一次结果。</li></ul></li></ul><h5 id="源代码-6"><a href="#源代码-6" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,k,i,a[<span class="hljs-number">1000001</span>],head,tail,q[<span class="hljs-number">1000001</span>],p[<span class="hljs-number">1000001</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monoQueue_min</span><span class="hljs-params">()</span></span>&#123;<br>    head=<span class="hljs-number">1</span>;<br>    tail=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//维护一个递增的单调队列，队首元素即为最小值</span><br>        <span class="hljs-keyword">while</span>(head&lt;=tail &amp;&amp; a[i]&lt;=q[tail])&#123;<br>            tail--;<br>        &#125;<br>        q[++tail]=a[i];<br>        p[tail]=i;<br>        <span class="hljs-keyword">while</span>(p[head]&lt;=i-k) head++;<span class="hljs-comment">//如果队首元素已经&quot;过时&quot;，出队。</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k) cout&lt;&lt; q[head]&lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monoQueue_max</span><span class="hljs-params">()</span></span>&#123;<br>    head=<span class="hljs-number">1</span>;<br>    tail=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//同理，维护一个递减的单调队列，队首元素即为最值</span><br>        <span class="hljs-keyword">while</span>(head&lt;=tail &amp;&amp; a[i]&gt;=q[tail])&#123;<br>            tail--;<br>        &#125;<br>        q[++tail]=a[i];<br>        p[tail]=i;<br>        <span class="hljs-keyword">while</span>(p[head]&lt;=i-k) head++;<span class="hljs-comment">//如果队首元素已经&quot;过时&quot;，出队。</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k) cout&lt;&lt; q[head] &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">monoQueue_min</span>();<br>    cout &lt;&lt;endl;<br>    <span class="hljs-built_in">monoQueue_max</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-7"><a href="#9-7" class="headerlink" title="9/7"></a>9/7</h3><h4 id="P1918-保龄球"><a href="#P1918-保龄球" class="headerlink" title="P1918 保龄球"></a>P1918 保龄球</h4><blockquote><p>难度：普及-</p></blockquote><blockquote><p>题意概括：给你一组数字，再给你一组目标数字，求目标数字在原数组中的位置。原题面看<a href="https://www.luogu.com.cn/problem/P1918">这里</a></p></blockquote><h5 id="思路记录-8"><a href="#思路记录-8" class="headerlink" title="思路记录"></a>思路记录</h5><ul><li><p>第一反应是桶，即用数组的下标表示数字，值表示位置，如pos[goal]=pos， 这样在输入数据后就能直接通过数字得到位置。但是本题的数据范围很大（10^9），空间消耗太大，显然不合适。也肯定不能直接遍历，效率太低。</p></li><li><p>考虑二分查找，但是由于二分查找需要先对原数组进行排序，这会破坏元素在原数组中的位置，所以想到<strong>结构体</strong>。对于结构体元素使用STL的sort函数进行排序时需要额外定义比较函数（指明比较结构体的哪些元素，即给出比较两个结构体大小的方式），这样这道题就做完了，具体代码如下。</p></li><li><p>因为题目指明了每个位置的球数不同，所以使用map更简单（其实就是桶的思维），直接无脑解决。</p></li></ul><h5 id="源代码-7"><a href="#源代码-7" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,Q,goal,i;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ball_struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">int</span> pos;<br>&#125;ball[<span class="hljs-number">1000001</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ball_struct a,ball_struct b)</span></span>&#123;<span class="hljs-comment">//此处定义的是sort的比较函数cmp</span><br>    <span class="hljs-keyword">return</span> a.num&lt;b.num; <span class="hljs-comment">//升序排列</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> mid,start=<span class="hljs-number">0</span>,end=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(start&lt;=end) &#123;<br>        mid = start+((end-start)&gt;&gt;<span class="hljs-number">1</span>);<span class="hljs-comment">//注意此处采用位操作防止溢出，同时提高执行速度</span><br>        <span class="hljs-keyword">if</span>(key&gt;ball[mid].num) start=mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;ball[mid].num) end=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ball[mid].pos;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;ball[i].num);<br>        ball[i].pos=i+<span class="hljs-number">1</span>;<br>    &#125;<br>    cin &gt;&gt; Q;<br>    <span class="hljs-built_in">sort</span>(ball,ball+n,cmp);<br>    <span class="hljs-keyword">while</span>(Q--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;goal);<br>        cout &lt;&lt; <span class="hljs-built_in">binary_search</span>(goal) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2021-8"><a href="#2021-8" class="headerlink" title="2021/8"></a>2021/8</h2><h3 id="0-STL"><a href="#0-STL" class="headerlink" title="0. STL"></a>0. STL</h3><h4 id="0-1-sort函数"><a href="#0-1-sort函数" class="headerlink" title="0.1 sort函数"></a>0.1 sort函数</h4><ul><li><p>sort (first, last)：对容器或普通数组中 <strong>[first, last)</strong> 范围内的元素进行排序，默认进行升序排序。</p><blockquote><p>注意范围：sort(a,a+10)是对a[0]-a[9]的元素排序</p></blockquote></li><li><p>sort(first, last, cmp)：采用<code>cmp</code>函数指定的比较方式对元素进行排序</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(mystruct a,mystruct b)</span></span>&#123;<span class="hljs-comment">//此处定义的是sort的比较函数cmp</span><br>    <span class="hljs-keyword">return</span> a.num&lt;b.num; <span class="hljs-comment">//升序排列</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="0-2-map"><a href="#0-2-map" class="headerlink" title="0.2 map"></a>0.2 map</h4><h5 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h5><ul><li><code>map&lt;int,int&gt; idx</code>：创建一个map</li><li><code>idx.insert(pair&lt;int,int&gt;(1,10))</code>：插入（1，10）这个键值对</li><li><code>idx.find(idx0)</code>：若容器内存在键为<code>idx0</code>的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</li><li>迭代器：<ul><li><code>map&lt;int, int&gt;::iterator iter</code>：map的元素需要使用迭代器访问，这里创建了<code>map&lt;int,int&gt;</code>的迭代器<code>iter</code></li><li><code>*iter</code>：对迭代器解引用后即可得到键值对</li><li><code>(*iter).first</code>：得到键值对的第一个元素，同理，second得到第二个</li></ul></li></ul><h5 id="OI-WIKI-给出的简介："><a href="#OI-WIKI-给出的简介：" class="headerlink" title="OI WIKI 给出的简介："></a>OI WIKI 给出的简介：</h5><p><code>map</code> 重载了 <code>operator[]</code>，可以用任意定义了 <code>operator &lt;</code> 的类型作为下标（在 <code>map</code> 中叫做 <code>key</code>，也就是索引）：</p><p><code> map&lt;Key, T&gt; yourMap;</code></p><p><code>map</code> 中不会存在键相同的元素，<code>multimap</code> 中允许多个元素拥有同一键。<code>multimap</code> 的使用方法与 <code>map</code> 的使用方法基本相同。</p><blockquote><p> Warning: 正是因为 <code>multimap</code> 允许多个元素拥有同一键的特点，<code>multimap</code> 并没有提供给出键访问其对应值的方法。</p></blockquote><h6 id="插入与删除操作¶"><a href="#插入与删除操作¶" class="headerlink" title="插入与删除操作¶"></a>插入与删除操作<a href="https://oi-wiki.org/lang/csl/associative-container/#_5">¶</a></h6><ul><li>可以直接通过下标访问来进行查询或插入操作。例如 <code>mp[&quot;Alan&quot;]=100</code>。</li><li>通过向 <code>map</code> 中插入一个类型为 <code>pair&lt;Key, T&gt;</code> 的值可以达到插入元素的目的</li><li><code>erase(key)</code> 函数会删除键为 <code>key</code> 的 <strong>所有</strong> 元素。返回值为删除元素的数量。</li><li><code>erase(pos)</code>: 删除迭代器为 pos 的元素，要求迭代器必须合法。</li><li><code>erase(first,last)</code>: 删除迭代器在 范围内的所有元素。</li><li><code>clear()</code> 函数会清空整个容器。</li></ul><details class="note" open="open" style="box-sizing: inherit; box-shadow: rgba(0, 0, 0, 0.14) 0px 2px 2px 0px, rgba(0, 0, 0, 0.12) 0px 1px 5px 0px, rgba(0, 0, 0, 0.2) 0px 3px 1px -2px; position: relative; margin: 1.5625em 0px; padding: 0px 0.6rem; border-left: 0.2rem solid rgb(68, 138, 255); border-radius: 0.1rem; font-size: 0.64rem; overflow: auto; display: block; color: rgba(0, 0, 0, 0.87); font-family: &quot;Fira Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: inherit; display: block; outline: none; cursor: pointer; margin: 0px -0.6rem; padding: 0.4rem 2rem; border-bottom: 0.05rem solid rgba(68, 138, 255, 0.1); background-color: rgba(68, 138, 255, 0.1); font-weight: 700;">下标访问中的注意事项</summary><p style="box-sizing: inherit; margin: 1em 0px;">在利用下标访问<span>&nbsp;</span><code style="box-sizing: inherit; color: rgb(55, 71, 79); font-feature-settings: &quot;kern&quot;; font-family: &quot;Fira Mono&quot;, &quot;Courier New&quot;, Courier, monospace; background-color: rgba(236, 236, 236, 0.5); font-size: 12px; direction: ltr; margin: 0px 0.29412em; padding: 0.07353em 0px; border-radius: 0.1rem; box-shadow: rgba(236, 236, 236, 0.5) 0.29412em 0px 0px, rgba(236, 236, 236, 0.5) -0.29412em 0px 0px; word-break: break-word; -webkit-box-decoration-break: clone;">map</code><span>&nbsp;</span>中的某个元素时，如果<span>&nbsp;</span><code style="box-sizing: inherit; color: rgb(55, 71, 79); font-feature-settings: &quot;kern&quot;; font-family: &quot;Fira Mono&quot;, &quot;Courier New&quot;, Courier, monospace; background-color: rgba(236, 236, 236, 0.5); font-size: 12px; direction: ltr; margin: 0px 0.29412em; padding: 0.07353em 0px; border-radius: 0.1rem; box-shadow: rgba(236, 236, 236, 0.5) 0.29412em 0px 0px, rgba(236, 236, 236, 0.5) -0.29412em 0px 0px; word-break: break-word; -webkit-box-decoration-break: clone;">map</code><span>&nbsp;</span>中不存在相应键的元素，会自动在<span>&nbsp;</span><code style="box-sizing: inherit; color: rgb(55, 71, 79); font-feature-settings: &quot;kern&quot;; font-family: &quot;Fira Mono&quot;, &quot;Courier New&quot;, Courier, monospace; background-color: rgba(236, 236, 236, 0.5); font-size: 12px; direction: ltr; margin: 0px 0.29412em; padding: 0.07353em 0px; border-radius: 0.1rem; box-shadow: rgba(236, 236, 236, 0.5) 0.29412em 0px 0px, rgba(236, 236, 236, 0.5) -0.29412em 0px 0px; word-break: break-word; -webkit-box-decoration-break: clone;">map</code><span>&nbsp;</span>中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）。</p><p style="box-sizing: inherit; margin: 1em 0px 0.6rem;">当下标访问操作过于频繁时，容器中会出现大量无意义元素，影响<span>&nbsp;</span><code style="box-sizing: inherit; color: rgb(55, 71, 79); font-feature-settings: &quot;kern&quot;; font-family: &quot;Fira Mono&quot;, &quot;Courier New&quot;, Courier, monospace; background-color: rgba(236, 236, 236, 0.5); font-size: 12px; direction: ltr; margin: 0px 0.29412em; padding: 0.07353em 0px; border-radius: 0.1rem; box-shadow: rgba(236, 236, 236, 0.5) 0.29412em 0px 0px, rgba(236, 236, 236, 0.5) -0.29412em 0px 0px; word-break: break-word; -webkit-box-decoration-break: clone;">map</code><span>&nbsp;</span>的效率。因此一般情况下推荐使用<span>&nbsp;</span><code style="box-sizing: inherit; color: rgb(55, 71, 79); font-feature-settings: &quot;kern&quot;; font-family: &quot;Fira Mono&quot;, &quot;Courier New&quot;, Courier, monospace; background-color: rgba(236, 236, 236, 0.5); font-size: 12px; direction: ltr; margin: 0px 0.29412em; padding: 0.07353em 0px; border-radius: 0.1rem; box-shadow: rgba(236, 236, 236, 0.5) 0.29412em 0px 0px, rgba(236, 236, 236, 0.5) -0.29412em 0px 0px; word-break: break-word; -webkit-box-decoration-break: clone;">find()</code><span>&nbsp;</span>函数来寻找特定键的元素。</p></details><h6 id="查询操作¶"><a href="#查询操作¶" class="headerlink" title="查询操作¶"></a>查询操作<a href="https://oi-wiki.org/lang/csl/associative-container/#_6">¶</a></h6><ul><li><code>count(x)</code>: 返回容器内键为 x 的元素数量。复杂度为 （关于容器大小对数复杂度，加上匹配个数）。</li><li><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</li><li><code>lower_bound(x)</code>: 返回指向首个不小于给定键的元素的迭代器。</li><li><code>upper_bound(x)</code>: 返回指向首个大于给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</li><li><code>empty()</code>: 返回容器是否为空。</li><li><code>size()</code>: 返回容器内元素个数。</li></ul><blockquote><p>set用起来也差不多</p></blockquote><h3 id="1-技巧"><a href="#1-技巧" class="headerlink" title="1. 技巧"></a>1. 技巧</h3><h4 id="1-1-P2367-区间修改"><a href="#1-1-P2367-区间修改" class="headerlink" title="1.1 P2367 区间修改"></a>1.1 P2367 区间修改</h4><blockquote><p>一开始使用暴力遍历, 在跑大数据集时超时, 于是学习了差分数组</p></blockquote><p><em><strong>差分数组</strong></em>——用于对数组进行区间修改（元素同步变化）的辅助数组</p><p>差分即原始数组的<strong>相邻元素之间的差</strong>，令<code>d[i]=a[i+1]-a[i]</code>，遍历一次即可得到差分数组</p><blockquote><p><strong>规律</strong>：当对一个区间进行增减某个值的时候，他的差分数组对应的区间左端点的值会同步变化，而他的右端点的后一个值则会<strong>相反</strong>地变化</p></blockquote><p>例：将区间[1, 4]的数全加上3</p><p><img src="/img/post/%E5%B7%AE%E5%88%861.png"></p><p><img src="/img/post/%E5%B7%AE%E5%88%862.png"></p><blockquote><p>**注意点: ** 在完成修改后，原数组元素的值由初始值和差分数组的值得到</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(...)&#123;<br>    a[i]=a[i<span class="hljs-number">-1</span>]+d[i];<span class="hljs-comment">//注意后续元素的更新依赖于前面元素的更新，所以需要一个循环来遍历完成</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h3><h4 id="2-1-P1044卡特兰数"><a href="#2-1-P1044卡特兰数" class="headerlink" title="2.1 P1044卡特兰数"></a>2.1 P1044卡特兰数</h4><p>本题的描述十分简单。n个数依次进栈，可随机出栈。求有几种可能。</p><p>dfs可以解，但是递推更简单一些。</p><p><strong>原理</strong>：</p><p>建立数组f。f[i]表示i个数的全部可能性。</p><blockquote><p>f[0] = 1, f[1] = 1;</p></blockquote><p>设 x 为当前出栈序列的最后一个，则x有n种取值</p><p>由于x是最后一个出栈的，所以可以将已经出栈的数分成两部分</p><ol><li>比x小</li><li>比x大</li></ol><p>比x小的数有x-1个，所以这些数的全部出栈可能为f[x-1]</p><p>比x大的数有n-x个，所以这些数的全部出栈可能为f[n-x]</p><p>这两部分互相影响，所以一个x的取值能够得到的所有可能性为f[x-1] * f[n-x]</p><p>另外，由于x有n个取值，所以</p><p>ans = f[0]*f[n-1] + f[1]*f[n-2] + … + f[n-1]*f[0];</p><h4 id="2-2-P1981-表达式求值"><a href="#2-2-P1981-表达式求值" class="headerlink" title="2.2 P1981 表达式求值"></a>2.2 P1981 表达式求值</h4><p>同样是使用了栈的思想</p><p>只包含+和*的表达式，读入第一个数后，后续的数据都可以看作是1个int+1个运算符</p><p>只处理乘法，结果压栈，最后遍历堆栈求加法</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//P1981 后缀表达式</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    stack &lt;<span class="hljs-keyword">int</span>&gt; t;<br>    <span class="hljs-keyword">int</span> a,b,tmp,res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> op;<br>    cin &gt;&gt; a;<br>    t.<span class="hljs-built_in">push</span>(a%<span class="hljs-number">10000</span>);<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; op &gt;&gt;b)&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            t.<span class="hljs-built_in">push</span>(b%<span class="hljs-number">10000</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            tmp=t.<span class="hljs-built_in">top</span>();<br>            t.<span class="hljs-built_in">pop</span>();<br>            t.<span class="hljs-built_in">push</span>(tmp* b%<span class="hljs-number">10000</span>);<br>        &#125;<br>    &#125;<br>   <span class="hljs-keyword">while</span>(t.<span class="hljs-built_in">size</span>())&#123;<br>        res+=t.<span class="hljs-built_in">top</span>();<br>        res%=<span class="hljs-number">10000</span>;<br>        t.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout&lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-3-P1165-日志分析"><a href="#2-3-P1165-日志分析" class="headerlink" title="2.3 P1165 日志分析"></a>2.3 P1165 日志分析</h4><blockquote><p>包含N+1 行：</p><p>第一行为11 个正整数N，对应于日志内所含操作的总数。</p><p>接下来的<em>N</em>行，分别属于以下三种格式之一：</p><p>格式1: 0 X//一次集装箱入库操作，正整数X<em>X</em>表示该次入库的集装箱的重量</p><p>格式2: 1 //一次集装箱出库操作，（就当时而言）最后入库的集装箱出库</p><p>格式3: 2 //一次查询操作，要求<strong>分析程序输出当前仓库内最大集装箱的重量</strong></p><p>当仓库为空时你应该忽略出库操作，当仓库为空查询时你应该输出00。</p></blockquote><p>同样也是使用栈。</p><p>第一次采用了暴力模拟的方法，将所有的集装箱压栈或出栈，查询操作时再遍历最大值。逻辑上没有问题，但是部分测试集超时，因为做了很多无用功，并不需要保存所有的货物信息，我们关心的只是最大重量。</p><p>于是，可以将查询的寻找最大重量环节合并到步骤1中，即永远保存最大重量在栈顶，这样查询时直接top即可。</p><p><strong>如何实现呢？</strong></p><p>我们只需要在压栈操作时，将当前的货物重量与栈顶的最大重量进行比较，如果大于，则压栈；如果小于，则再次将最大重量压栈。这样做的目的是在计算货物出入库数目增减的同时，还间接求出了最大重量，从而免去了查询操作环节的遍历，极大的提高了程序运行效率。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//P1165 日志分析</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; repo;<br>    <span class="hljs-keyword">int</span> N,op,x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;t&lt;N;t++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>            <span class="hljs-keyword">if</span>(repo.<span class="hljs-built_in">empty</span>()) repo.<span class="hljs-built_in">push</span>(x);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (x&gt;repo.<span class="hljs-built_in">top</span>()) repo.<span class="hljs-built_in">push</span>(x);<br>                <span class="hljs-keyword">else</span> repo.<span class="hljs-built_in">push</span>(repo.<span class="hljs-built_in">top</span>());<span class="hljs-comment">//比较，保持最大值在栈顶，非常妙！</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) repo.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span>(repo.<span class="hljs-built_in">empty</span>()) cout&lt;&lt; <span class="hljs-number">0</span>&lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; repo.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-4-单调栈"><a href="#2-4-单调栈" class="headerlink" title="2.4 单调栈"></a>2.4 单调栈</h4><blockquote><p> 定义：字面意思。单调增还是单调减取决于<strong>出栈顺序</strong>。</p><p> 如果出栈的元素是单调增的，那就是单调递增栈，如果出栈的元素是单调减的，那就是单调递减栈。</p></blockquote><p>e.g  [1,2,3,4] 就是一个单调递减栈（因为此时的出栈顺序是 4，3，2，1。）</p><p><em><strong>适用场景</strong></em>：求解<strong>下一个大于 xxx</strong>或者<strong>下一个小于 xxx</strong>。</p><ul><li><p>如果有的题目需要用到所有数组的信息，那么很有可能因没有考虑边界而不能通过所有的测试用例。 使用<strong>哨兵法</strong>解决，这个技巧经常用在单调栈的算法中。</p><p>例如：在原数组 [1,3,4,5,2,9,6] 的右侧添加一个小于数组中最小值的项，比如 -1。此时的数组是 [1,3,4,5,2,9,6,-1]。这种技巧可以简化代码逻辑.</p></li></ul><p><strong>P5788 求下一个大于x的元素</strong></p><p><strong>1.解法1:使用递减栈</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">int</span> ans[<span class="hljs-number">3000001</span>],data[<span class="hljs-number">3000001</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data[i]);<br>    <span class="hljs-comment">//单调栈模板：</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()||data[i]&lt;data[s.<span class="hljs-built_in">top</span>()]) s.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">//入栈</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;data[s.<span class="hljs-built_in">top</span>()]&lt;data[i])&#123;<span class="hljs-comment">//对于不满足单调性的元素（这里需要根据题目要求，选择递增还是递减，不满足单调性的即为第一个大于xxx的元素，），出栈，更新res数组，保存下标直到满足为止;</span><br>                ans[s.<span class="hljs-built_in">top</span>()]=i;<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]);<br>    &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>上述解法虽然可行，但对于大数据集会报超时，所以还能进一步简化。代码如下：</p></blockquote><p><strong>2. 解法2：解法1简化版(从后往前扫描)</strong></p><p>如何理解？</p><p>可以用人的高矮来理解。</p><p>例如，一队人，从左往右看，求看到的第一个比他高的人。</p><p>通过观察，我们会发现，在她后面的，比她矮的，一定会被她遮住。那么，这个点就没用了。而根据现实生活和刚才的推断，我们看到的人肯定是一个比一个高的，而没看到的，留着也没用，直接扔。这就是符合单调性的。再看，那些没用的人什么时候扔掉？当然是遇到比她高的人了。那么就可以一个一个地走掉，而且肯定是在已经判断过的人的前面（中间和后面的在之前就走掉了），所以就直接从前面弹出。</p><img src="https://i.loli.net/2020/01/07/8LB6ZW5qg7m9y1c.png" alt="img" style="zoom:50%;" /><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">int</span> ans[<span class="hljs-number">3000100</span>],data[<span class="hljs-number">3000100</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;data[s.<span class="hljs-built_in">top</span>()]&lt;=data[i]) s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//一定要注意这里的小于等于！一开始漏了等于，过不了，还一直没发现，但分析之后，显然需要等于，因为题目要求的是从左往右的第一个大于的数，从后往前扫描时需要更新相等的数，这才是第一个大于。</span><br>        ans[i]=s.<span class="hljs-built_in">empty</span>()?<span class="hljs-number">0</span>:s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h3><h4 id="3-1-队列安排"><a href="#3-1-队列安排" class="headerlink" title="3.1 队列安排"></a>3.1 队列安排</h4><p>多次提到插入、删除，显然要想到<strong>链表</strong></p><blockquote><p>链表的实质是一个节点指向另一个节点，其中涉及储存地址的指针 </p><p>我们也可以<strong>使用数组来模拟链表</strong>，用数组的索引来代替地址！更为方便</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//P1160</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-keyword">int</span> k,p,head=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> s[<span class="hljs-number">100001</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">//s[k][2] left; s[k][3] right; s[k][1] 在队伍中</span><br>    <span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s));<br>    s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;k,&amp;p);<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//在左边插入</span><br>            s[s[k][<span class="hljs-number">2</span>]][<span class="hljs-number">3</span>]=i;<br>            s[i][<span class="hljs-number">2</span>]=s[k][<span class="hljs-number">2</span>];<br>            s[i][<span class="hljs-number">3</span>]=k;<br>            s[k][<span class="hljs-number">2</span>]=i;<br>            <span class="hljs-comment">//插入操作，更新左右节点的指针</span><br>            s[i][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(k==head) head=i;<span class="hljs-comment">//更新链表头</span><br><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//在右边插入</span><br>            s[s[k][<span class="hljs-number">3</span>]][<span class="hljs-number">2</span>]=i;<br>            s[i][<span class="hljs-number">2</span>]=k;<br>            s[i][<span class="hljs-number">3</span>]=s[k][<span class="hljs-number">3</span>];<br>            s[k][<span class="hljs-number">3</span>]=i;<br>            <span class="hljs-comment">//插入操作，更新左右节点的指针</span><br>            s[i][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br>        <span class="hljs-keyword">if</span>(s[k][<span class="hljs-number">1</span>])&#123;<br>            s[s[k][<span class="hljs-number">2</span>]][<span class="hljs-number">3</span>]=s[k][<span class="hljs-number">3</span>];<br>            s[s[k][<span class="hljs-number">3</span>]][<span class="hljs-number">2</span>]=s[k][<span class="hljs-number">2</span>];<br>            s[k][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>            n--;<br>        &#125;<br>    &#125;<br>    k=head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,k);<br>        k=s[k][<span class="hljs-number">3</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h3><h4 id="4-1-经典问题：UVA540-排队"><a href="#4-1-经典问题：UVA540-排队" class="headerlink" title="4.1 经典问题：UVA540 排队"></a>4.1 经典问题：UVA540 排队</h4><p><strong>问题描述：</strong></p><p>排队，队伍中有自己同队的，可以直接排到他的后面（插队），没有就老老实实排到最后。</p><p>出队，队头的人出队。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t,member,cal=<span class="hljs-number">0</span>;<br>    string op;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; t)&#123;<br>        <span class="hljs-keyword">if</span>(!t) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//初始化</span><br>        cal++;<br>        <span class="hljs-keyword">int</span> team[<span class="hljs-number">1000000</span>];<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; total;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; qt[<span class="hljs-number">1000</span>];<br>        <span class="hljs-comment">//读取队员信息</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;<br>            <span class="hljs-keyword">int</span> num,m;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;num;j++)&#123;<br>                cin &gt;&gt; m;<br>                team[m]=i;<span class="hljs-comment">//i表示该队员所属的队伍编号，类似于桶排的思想</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//读取操作序列</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Scenario #&quot;</span> &lt;&lt; cal &lt;&lt; endl;<br>        <span class="hljs-keyword">while</span>(cin&gt;&gt;op&amp;&amp;op!=<span class="hljs-string">&quot;STOP&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;ENQUEUE&quot;</span>)&#123;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;member);<br>                <span class="hljs-keyword">if</span>(qt[team[member]].<span class="hljs-built_in">empty</span>())&#123;<br>                    total.<span class="hljs-built_in">push</span>(team[member]);<br>                    qt[team[member]].<span class="hljs-built_in">push</span>(member);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    qt[team[member]].<span class="hljs-built_in">push</span>(member);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;DEQUEUE&quot;</span>)&#123;<br>                cout &lt;&lt; qt[total.<span class="hljs-built_in">front</span>()].<span class="hljs-built_in">front</span>()&lt;&lt;endl;<br>                qt[total.<span class="hljs-built_in">front</span>()].<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(qt[total.<span class="hljs-built_in">front</span>()].<span class="hljs-built_in">empty</span>()) total.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        cout &lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>巧妙之处</strong>：</p><ol><li>对于输入的大量队员信息，采用类似桶排的思想，使用数组team，每一个元素team[member]保存的是队员所属的队伍</li><li>使用两种queue,一个是total队列，用于保存队伍名的整体排列顺序；另一个是qt[1000]队列数组，用于保存整个队伍中各个小团体的排列顺序。</li></ol><h3 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h3><h4 id="5-1-树的遍历"><a href="#5-1-树的遍历" class="headerlink" title="5.1 树的遍历"></a>5.1 树的遍历</h4><h5 id="5-1-1-已知先序、中序求后序；已知中序、后序，求先序"><a href="#5-1-1-已知先序、中序求后序；已知中序、后序，求先序" class="headerlink" title="5.1.1 已知先序、中序求后序；已知中序、后序，求先序"></a>5.1.1 已知先序、中序求后序；已知中序、后序，求先序</h5><blockquote><p>题目要求：给中序和后序排列，求先序排列</p><p>这种类型的题目思路都很相似。基础题</p><p>根据先序或者后序找到根节点，然后将中序参照这个节点一分为二，再对其左右子树递归即可，区别只是输出根节点的先后。</p></blockquote><p>首先，一点基本常识，给你一个后序遍历，那么最后一个就是根（如ABCD，则根为D）。</p><p>因为题目求先序，意味着要不断找根。</p><p>那么我们来看这道题方法：（示例）</p><p>中序ACGDBHZKX，后序CDGAHXKZB，首先可找到主根B；</p><p>那么我们找到中序遍历中的B，由这种遍历的性质，可将中序遍历分为ACGD和HZKX两棵子树，</p><p>那么对应可找到后序遍历CDGA和HXKZ（从头找即可）</p><p>从而问题就变成求1.中序遍历ACGD，后序遍历CDGA的树 2.中序遍历HZKX，后序遍历HXKZ的树；</p><p>接着递归，按照原先方法，找到1.子根A，再分为两棵子树2.子根Z，再分为两棵子树。</p><p>就按这样一直做下去（先输出根，再递归）；</p><p>模板概括为step1:找到根并输出</p><p>step2:将中序，后序各分为左右两棵子树；</p><p>step3:递归，重复step1,2；</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">beford</span><span class="hljs-params">(string in,string after)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (in.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">char</span> ch=after[after.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>        cout&lt;&lt;ch;<span class="hljs-comment">//找根输出</span><br>        <span class="hljs-keyword">int</span> k=in.<span class="hljs-built_in">find</span>(ch);<br>        <span class="hljs-built_in">beford</span>(in.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,k),after.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,k));<br>        <span class="hljs-built_in">beford</span>(in.<span class="hljs-built_in">substr</span>(k+<span class="hljs-number">1</span>),after.<span class="hljs-built_in">substr</span>(k,in.<span class="hljs-built_in">size</span>()-k<span class="hljs-number">-1</span>));<span class="hljs-comment">//递归左右子树；</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string inord,aftord;<br>    cin&gt;&gt;inord;cin&gt;&gt;aftord;<span class="hljs-comment">//读入</span><br>    <span class="hljs-built_in">beford</span>(inord,aftord);cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-图"><a href="#6-图" class="headerlink" title="6. 图"></a>6. 图</h3><h4 id="6-0-图的基本知识"><a href="#6-0-图的基本知识" class="headerlink" title="6.0 图的基本知识"></a>6.0 图的基本知识</h4><h5 id="6-0-1-图的存储"><a href="#6-0-1-图的存储" class="headerlink" title="6.0.1 图的存储"></a>6.0.1 图的存储</h5><p>(具体可看<a href="https://oi-wiki.org/graph/save/">OI WIKI</a>)</p><ol><li>邻接矩阵——空间复杂度高，适合存储稠密图</li><li>邻接表</li><li><a href="https://blog.csdn.net/sugarbliss/article/details/86495945#commentBox">链式前向星</a>——本质上是用链表实现的邻接表</li></ol><blockquote><p><strong>如果说邻接表是不好写但效率好，邻接矩阵是好写但效率低的话，前向星就是一个相对中庸的数据结构。前向星固然好写，但效率并不高。而在优化为链式前向星后，效率也得到了较大的提升。</strong></p></blockquote><h5 id="6-0-2-图的遍历"><a href="#6-0-2-图的遍历" class="headerlink" title="6.0.2 图的遍历"></a>6.0.2 图的遍历</h5><p>每个顶点仅被访问一次（使用辅助数组visited[n]标记）</p><h6 id="1-深度优先搜索（DFS）"><a href="#1-深度优先搜索（DFS）" class="headerlink" title="1.深度优先搜索（DFS）"></a>1.深度优先搜索（DFS）</h6><p>例子：点亮迷宫中所有的灯——一条道走到黑</p><p>应用：</p><ul><li><p><strong>连通块问题</strong>（图也有DFS和BFS遍历。由于DFS更容易编写，一般用DFS找连通块）</p><p>​        从每个格子出发，递归遍历它周围的格子。每次访问一个格子时就给它写上一个“连通分量编号”（即染色），这样就可以在访问之前检查它是否已经有了编号，从而避免同一个格子访问多次。</p><p><strong>例子</strong>: <a href="https://www.luogu.com.cn/problem/P1162">P1162 填涂颜色</a></p><p>题目要求：将圈（用1表示）中的0涂为2，圈外的0不变</p><p><strong>思路</strong>：采用染色法，使用dfs递归遍历，碰到0就染色，碰到1或者越界就直接return。遍历完成后，再进行遍历，如果染过色，说明是圈外的0或者边界1，仍然输出0或1，如果没染过色，说明是圈内的0，要输出2。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">31</span>][<span class="hljs-number">31</span>];<br><span class="hljs-keyword">int</span> x[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,y[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;n+<span class="hljs-number">1</span>||i&lt;<span class="hljs-number">0</span>||j&gt;n+<span class="hljs-number">1</span>||j&lt;<span class="hljs-number">0</span>||a[i][j]) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//边界为n+1,套上一圈0</span><br>    a[i][j]=<span class="hljs-number">2</span>;<span class="hljs-comment">//此处用2表示染色，并不是最后的结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;t&lt;<span class="hljs-number">4</span>;t++) <span class="hljs-built_in">dfs</span>(i+x[t],j+y[t]);<span class="hljs-comment">//向四个方向搜索</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        cin &gt;&gt; a[i][j];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//从（0,0）开始遍历，但实际的图存放在1—n的数组元素中，相当于在原来的图外面套上一圈0,便于边界的判断</span><br>   <span class="hljs-comment">//否则，当墙为图的边界时，另一头的0将无法被染色，可以理解为水无法漫过去。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">2</span>) cout &lt;&lt;<span class="hljs-number">0</span> &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//对是否染过色进行判断</span><br>            <span class="hljs-keyword">else</span> cout &lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h6 id="2-广度优先搜索（BFS）"><a href="#2-广度优先搜索（BFS）" class="headerlink" title="2.广度优先搜索（BFS）"></a>2.广度优先搜索（BFS）</h6><h4 id="6-1-最短路"><a href="#6-1-最短路" class="headerlink" title="6.1 最短路"></a>6.1 最短路</h4><p>两类问题：</p><ol><li>两点最短路径（所有顶点间的最短路径——Floyd）</li><li>某源点到其他各点的最短路径（单源最短路径——Dijkstra）</li></ol><p>三种算法：</p><ul><li><a href="http://blog.csdn.net/qq_35644234/article/details/60870719">迪杰斯特拉算法（Dijkstra算法）</a></li><li><a href="https://blog.csdn.net/qq_35644234/article/details/60875818">弗洛伊德算法（Floyd算法）</a></li><li><a href="http://blog.csdn.net/qq_35644234/article/details/61614581">SPFA算法</a></li></ul><h5 id="6-1-1-Floyd"><a href="#6-1-1-Floyd" class="headerlink" title="6.1.1 Floyd"></a>6.1.1 Floyd</h5><blockquote><p>以正确处理有向图或有向图或<strong>负权</strong>（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包</p></blockquote><p>时间复杂度—— O(n^3)</p><p>中心思想：按顺序遍历各个顶点，依次将其( 用k表示)作为中心点，计算i和j两点经过k的距离，如果更小，更新即可。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//核心代码</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(path[i][k]+path[k][j]&lt;path[i][j])&#123;<br>                path[i][j]=path[i][k]+path[k][j];<span class="hljs-comment">//更新距离矩阵</span><br>                D[i][j]=D[i][k];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="6-1-2-Dijkstra"><a href="#6-1-2-Dijkstra" class="headerlink" title="6.1.2 Dijkstra"></a>6.1.2 Dijkstra</h5><blockquote><p>不可处理负权</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INFINITE 2147483647;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> w;<br>    <span class="hljs-keyword">int</span> end;<br>    <span class="hljs-keyword">int</span> next;<br>&#125;edge[<span class="hljs-number">1000000</span>];<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>,head[<span class="hljs-number">1000000</span>],visit[<span class="hljs-number">10001</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> w)</span></span>&#123;<br>    edge[cnt].end=end;<br>    edge[cnt].w=w;<br>    edge[cnt].next=head[begin];<br>    head[begin]=cnt++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m,s;<br>    <span class="hljs-keyword">int</span> begin,end,w,pos,i;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dis[<span class="hljs-number">10001</span>];<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=m;i++) head[i]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;<br>        dis[i]=INFINITE;<br>        visit[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin &gt;&gt; begin &gt;&gt; end &gt;&gt; w;<br>        <span class="hljs-built_in">addEdge</span>(begin,end,w);<span class="hljs-comment">//使用前向星存图</span><br>    &#125;<br>    <span class="hljs-comment">//Dijkstra核心代码</span><br>    pos=s;<br>    dis[pos]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!visit[pos])&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> min=INFINITE;<br>        visit[pos]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(i=head[pos];i!=<span class="hljs-number">-1</span>;i=edge[i].next)&#123;<span class="hljs-comment">//遍历用链式前向星存储的起点为pos的所有edge</span><br>            <span class="hljs-keyword">int</span> edgeEnd=edge[i].end;<br>            <span class="hljs-keyword">if</span>(!visit[edgeEnd]&amp;&amp;dis[edgeEnd]&gt;dis[pos]+edge[i].w)&#123;<span class="hljs-comment">//如果该边最小，则更新距离值</span><br>                dis[edgeEnd]=dis[pos]+edge[i].w;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!visit[i]&amp;&amp;dis[i]&lt;min)&#123;<br>                min=dis[i];<br>                pos=i;<span class="hljs-comment">//查找最小权的边，将其终点加入dijkstra云</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cout&lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="6-2-最小生成树"><a href="#6-2-最小生成树" class="headerlink" title="6.2 最小生成树"></a>6.2 最小生成树</h4><p>具体看<a href="https://blog.csdn.net/luoshixian099/article/details/51908175">这里</a></p><ul><li><strong>生成树</strong>：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li><li><strong>最小生成树</strong>：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</li></ul><p><strong>两种算法：Kruskal和Prim</strong></p><p><strong>两者区别：</strong></p><ol><li>Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣。</li><li>Prim是以更新过的节点的连边找最小值，Kruskal是直接将边排序。</li></ol><h5 id="6-2-1-Kruskal——“加边法”"><a href="#6-2-1-Kruskal——“加边法”" class="headerlink" title="6.2.1 Kruskal——“加边法”"></a>6.2.1 Kruskal——“加边法”</h5><p>初始最小生成树边数为0，每迭代一次就<strong>选择</strong>一条满足条件的<strong>最小代价边</strong>，加入到最小生成树的边集合里。（选最小边）</p><ol><li>把图中的所有边按代价从小到大排序，并把图中的n个顶点看成独立的n棵树组成的森林；</li><li>按权值从小到大选择边，所选的边连接的两个顶点ui,vi应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。</li><li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li></ol><p><img src="https://img-blog.csdn.net/20160714144315409" alt="这里写图片描述"></p><h5 id="6-2-2-Prim——”加点法“"><a href="#6-2-2-Prim——”加点法“" class="headerlink" title="6.2.2. Prim——”加点法“"></a>6.2.2. Prim——”加点法“</h5><p>每次迭代<strong>选择代价最小的边对应的点</strong>，加入到最小生成树中。（选最小边对应的点）</p><p>算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><ol><li>图的所有顶点集合为V；初始令集合u={s},v=V−u</li><li>在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中</li><li>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//1.Prim算法的数据结构，即（顶点，更新的最小代价）</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> vertexData   <span class="hljs-comment">//表示u中顶点信息</span><br>  UINT lowestcost   <span class="hljs-comment">//最小代价</span><br>&#125;closedge[vexCounts]<br><span class="hljs-comment">//2.或者使用dis数组来保存最小代价，加入一个新的顶点后更新即可。</span><br></code></pre></div></td></tr></table></figure><img src="https://img-blog.csdn.net/20160714161107576" alt="这里写图片描述"  /><p>算法实现：和Dijkstra很相似</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 2147483647</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> end;<br>    <span class="hljs-keyword">int</span> weight;<br>    <span class="hljs-keyword">int</span> next;<br>&#125;edge[<span class="hljs-number">2000000</span>];<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>,head[<span class="hljs-number">30001</span>],visit[<span class="hljs-number">30001</span>],dis[<span class="hljs-number">30001</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> e,<span class="hljs-keyword">int</span> w )</span></span>&#123;<br>    edge[cnt].end=e;<br>    edge[cnt].weight=w;<br>    edge[cnt].next=head[b];<br>    head[b]=cnt++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m,i,begin,end,weight,res=<span class="hljs-number">0</span>,pos,num=<span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(head));<br>    <span class="hljs-built_in">memset</span>(visit,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visit));<br>    <span class="hljs-built_in">fill</span>(dis,dis+<span class="hljs-number">30001</span>,INF);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin &gt;&gt; begin &gt;&gt;end &gt;&gt; weight;<br>        <span class="hljs-built_in">addEdge</span>(begin, end, weight);<br>        <span class="hljs-built_in">addEdge</span>(end,begin,weight);<span class="hljs-comment">//因为是无向图，所以保存两个方向</span><br>    &#125;<span class="hljs-comment">//使用链式前向星保存图</span><br>    <span class="hljs-keyword">for</span>(i=head[<span class="hljs-number">1</span>];i!=<span class="hljs-number">-1</span>;i=edge[i].next)&#123;<span class="hljs-comment">//初始化,首先将dis数组更新为各个节点到节点1的距离</span><br>        dis[edge[i].end]=<span class="hljs-built_in">min</span>(dis[edge[i].end],edge[i].weight);<br>    &#125;<br>    pos=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(++num&lt;n)&#123;<br>        <span class="hljs-keyword">int</span> minn=INF;<br>        visit[pos]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//找到代价最小点，保存节点编号和最小值</span><br>            <span class="hljs-keyword">if</span>(dis[i]&lt;minn&amp;&amp;!visit[i])&#123;<br>                pos=i;<br>                minn=dis[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(minn==INF) &#123;cout &lt;&lt;<span class="hljs-string">&quot;orz&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//这里要注意，如果循环结束后minn的值没有变化，说明该图不是连通图</span><br>        res+=minn;<br>        <span class="hljs-keyword">for</span>(i=head[pos];i!=<span class="hljs-number">-1</span>;i=edge[i].next)&#123;<span class="hljs-comment">//更新dis数组</span><br>            dis[edge[i].end]=<span class="hljs-built_in">min</span>(dis[edge[i].end],edge[i].weight);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>刷题</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九月计划</title>
    <link href="/2021/09/06/%E4%B9%9D%E6%9C%88%E8%AE%A1%E5%88%92/"/>
    <url>/2021/09/06/%E4%B9%9D%E6%9C%88%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="1-学习"><a href="#1-学习" class="headerlink" title="1. 学习"></a>1. 学习</h2><ol><li>坚持每天刷一道以上oj，以每空闲半天为单位，每周执行5天以上。</li><li>坚持每天背30个单词</li><li>当天作业当天动笔，尽力完成</li><li>减少在宿舍学习的时间，多去教学楼</li></ol><h2 id="2-生活习惯"><a href="#2-生活习惯" class="headerlink" title="2. 生活习惯"></a>2. 生活习惯</h2><ol><li>每周去健身房锻炼2次</li><li>早上7：30起床，每周执行5次以上</li><li>晚上11点不带手机上床睡觉，每周执行5次以上</li><li>少吃夜宵，每周不超过3次，睡前饿了牛奶+面包更好 :D</li></ol><h2 id="3-心态"><a href="#3-心态" class="headerlink" title="3. 心态"></a>3. 心态</h2><p>不畏难，不怕尴尬，勇敢尝试，敢于迈出第一步 : D</p><p>持之以恒 : D</p><p>道阻且长，行则将至 : D</p>]]></content>
    
    
    <categories>
      
      <category>月计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab学习笔记</title>
    <link href="/2021/08/31/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>入门网站推荐<a href="https://matlabacademy.mathworks.com/cn/details/matlab-onramp/gettingstarted">官网教程</a>，跟着敲一遍就会了。: D</p></blockquote><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h2><ol><li><p><code>clear</code> 函数清理工作区。<code>clc</code> 命令清理<strong>命令行窗口</strong>。</p></li><li><p>使用 <code>format</code> 函数控制显示的精度：</p><p>输入 <code>format long</code> 显示更多小数。</p><p>输入 <code>format short</code> 可切换回默认显示。</p></li><li><p>使用 <code>:</code> 运算符并仅指定起始值和最终值。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">y = <span class="hljs-number">5</span>:<span class="hljs-number">8</span><br>y = <br>    <span class="hljs-number">5</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span>    <span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure></li></ol><p>运算符使用默认的间距 <code>1</code>，但是您可以指定您自己的间距，如下所示。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = <span class="hljs-number">20</span>:<span class="hljs-number">2</span>:<span class="hljs-number">26</span><br>x = <br>    <span class="hljs-number">20</span>    <span class="hljs-number">22</span>    <span class="hljs-number">24</span>    <span class="hljs-number">26</span><br></code></pre></div></td></tr></table></figure><p>如果您知道向量中所需的元素数目（而不是每个元素之间的间距），则可以改用 <code>linspace</code> 函数：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">linspace</span>(first,last,number_of_elements)<br></code></pre></div></td></tr></table></figure><ol start="4"><li>转置：x = x’</li></ol><p>您可以通过在一条命令中创建行向量并将其全部转置来创建列向量。注意此处使用圆括号来指定运算的顺序。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = (<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">5</span>)&#x27;<br>x = <br>    <span class="hljs-number">1</span><br>    <span class="hljs-number">3</span><br>    <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><ol start="5"><li><p><code>rand(2)</code> 命令中的 <code>2</code> 指定输出将为一个 2×2 的随机数矩阵。</p><p><code>rand(2,3)</code> 2 x 3矩阵</p></li><li><p>如何知道现有矩阵的大小？您可以使用 <code>size</code> 函数。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">size</span>(x)<br></code></pre></div></td></tr></table></figure><p>您也可以使用一行代码创建与现有矩阵大小相同的矩阵。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">rand</span>(<span class="hljs-built_in">size</span>(x))<br></code></pre></div></td></tr></table></figure><p><code>numel(y)</code>函数可以获得y中元素的个数</p></li><li><p>使用类似c语言的方式获得数组元素</p></li><li><p>用作索引时，冒号运算符 (<code>:</code>) 可指代该维度中的所有元素。以下语法</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = A(<span class="hljs-number">2</span>,:)<br>会创建一个包含A中第 <span class="hljs-number">2</span> 行上所有元素的行向量。<br></code></pre></div></td></tr></table></figure></li></ol><p>冒号运算符可以引用某个值范围。以下语法会创建一个包含矩阵 <code>A</code> 的第 1 行、第 2 行和第 3 行所有元素的矩阵。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = A(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,:)<br></code></pre></div></td></tr></table></figure><ol start="9"><li><p>单个索引值可用于引用向量元素。例如</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x = v(<span class="hljs-number">3</span>)会返回向量 `v` 的第 <span class="hljs-number">3</span> 个元素<br></code></pre></div></td></tr></table></figure></li><li><p>您可以结合使用索引与赋值，将数组值更改为与其他元素相等。例如，以下代码将 <code>x(1)</code> 的值更改为 <code>x(2)</code> 的值：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x(<span class="hljs-number">1</span>) = x(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure></li><li><p>MATLAB 的设计让您能够自然地处理数组。例如，您可以将一个标量值与数组中的所有元素相加。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">y = x + <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>您可以将任意两个大小相同的数组相加。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z = x + y<br></code></pre></div></td></tr></table></figure><p>您可以将数组中的所有元素与某个标量相乘或相除。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z = <span class="hljs-number">2</span>*xy = x/<span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>MATLAB 的函数可在单个命令中对整个向量或值数组执行数学运算。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">xSqrt = <span class="hljs-built_in">sqrt</span>(x)<br></code></pre></div></td></tr></table></figure></li><li><p><code>*</code> 运算符执行<a href="http://www.mathworks.com/help/matlab/ref/mtimes.html">矩阵乘法</a>。因此，如果您使用 <code>*</code> 将两个大小相同的向量相乘，则由于内部维度不一致，您将会收到一条错误消息。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z = [<span class="hljs-number">3</span> <span class="hljs-number">4</span>] * [<span class="hljs-number">10</span> <span class="hljs-number">20</span>]<br></code></pre></div></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">错误使用  * 用于矩阵乘法的维度不正确。 <br></code></pre></div></td></tr></table></figure><p>而 <code>.*</code> 运算符执行按元素乘法，允许您将两个大小相同的数组的对应元素相乘。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z = [<span class="hljs-number">3</span> <span class="hljs-number">4</span>] .* [<span class="hljs-number">10</span> <span class="hljs-number">20</span>]<br></code></pre></div></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">z =     <span class="hljs-number">30</span>    <span class="hljs-number">80</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>size</code> 函数可以应用于矩阵，以生成单个输出变量或两个输出变量。使用方括号 (<code>[ ]</code>) 获得多个输出。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">[xrow,xcol] = <span class="hljs-built_in">size</span>(x)<br></code></pre></div></td></tr></table></figure><p>可以使用 <code>max</code> 函数确定向量的最大值及其对应的索引值。<code>max</code> 函数的第一个输出为输入向量的最大值。执行带两个输出的调用时，第二个输出为索引值。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">[xMax,idx] = <span class="hljs-built_in">max</span>(x)<br></code></pre></div></td></tr></table></figure><p>可以使用波浪号字符 (<code>~</code>) 忽略特定输出。</p></li><li><p>您可以使用关系运算符将某个向量或矩阵与单个标量值进行比较。结果是与原始数组相同大小的逻辑数组。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">[<span class="hljs-number">5</span> <span class="hljs-number">10</span> <span class="hljs-number">15</span>] &gt; <span class="hljs-number">12</span><span class="hljs-built_in">ans</span> =     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>您可以使用逻辑数组作为数组索引，在这种情况下，MATLAB 会提取索引为 <code>true</code> 的数组元素。以下示例将会提取 <code>v1</code> 中大于 6 的所有元素。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">v = v1(v1 &gt; <span class="hljs-number">6</span>)v =    <span class="hljs-number">6.6678</span>    <span class="hljs-number">9.0698</span><br></code></pre></div></td></tr></table></figure><p>使用逻辑索引在数组中重新赋值。例如，如果您要将数组 <code>x</code> 中等于 <code>999</code> 的所有值都替换为值 <code>1</code>，请使用以下语法。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">x(x==<span class="hljs-number">999</span>) = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="2-画图"><a href="#2-画图" class="headerlink" title="2. 画图"></a>2. 画图</h2><h3 id="2-1-plot函数"><a href="#2-1-plot函数" class="headerlink" title="2.1 plot函数"></a>2.1 plot函数</h3><ol><li><p>可以使用 <code>plot</code> 函数在一张图上绘制两个相同长度的向量。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(x,y)<br></code></pre></div></td></tr></table></figure></li><li><p><code>plot</code> 函数接受一个附加参数。使用该参数，您可以通过在引号中包含不同符号的方式来指定与之对应的颜色、线型和标记样式。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(x,y,<span class="hljs-string">&quot;r--o&quot;</span>)<br></code></pre></div></td></tr></table></figure></li></ol><p>   以上命令将会绘制一条红色 (<code>r</code>) 虚线 (<code>--</code>)，并使用圆圈 (<code>o</code>) 作为标记。您可以在<a href="http://www.mathworks.com/help/matlab/ref/linespec.html">线条设定</a>的文档中了解有关可用符号的详细信息。</p><ol start="3"><li><p>每个绘图命令都创建了一个单独的绘图。要在一张图上先后绘制两条线，请使用 <code>hold on</code> 命令保留之前的绘图，然后添加另一条线。</p><p>启用保留状态时，将继续在同一坐标区上绘图。要恢复默认绘图行为，即其中每个绘图都有自己的坐标区，请输入 <code>hold off</code>。</p><p>任务</p></li><li><p>单独绘制一个向量时，MATLAB 会使用向量值作为 y 轴数据，并将 x 轴数据的范围设置为从 <code>1</code> 到 <code>n</code>（向量中的元素数目）。</p></li><li><p><code>plot</code> 函数接受可选的附加输入，这些输入由一个属性名称和一个关联的值组成。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(y,<span class="hljs-string">&quot;LineWidth&quot;</span>,<span class="hljs-number">5</span>)<br></code></pre></div></td></tr></table></figure></li></ol><p>   以上命令将绘制一条粗线。您可以在<a href="https://www.mathworks.com/help/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">线条属性</a>文档中了解更多可用属性的详细信息。</p><p>   使用 <code>plot</code> 函数时，您可在绘图参数和线条设定符之后添加属性名称-属性值对组。</p>   <figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(x,y,<span class="hljs-string">&quot;ro-&quot;</span>,<span class="hljs-string">&quot;LineWidth&quot;</span>,<span class="hljs-number">5</span>)<br></code></pre></div></td></tr></table></figure><h3 id="2-2-其他函数"><a href="#2-2-其他函数" class="headerlink" title="2.2 其他函数"></a>2.2 其他函数</h3><ol><li><p>使用 <code>xlim</code> 函数放大所关注的区域。（在画图函数之后）</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">xlim([xmin xmax])例子：<span class="hljs-built_in">plot</span>(f,yfft)xlim([<span class="hljs-number">0</span> <span class="hljs-number">1000</span>])<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="2-3-在图像中添加注释"><a href="#2-3-在图像中添加注释" class="headerlink" title="2.3 在图像中添加注释"></a>2.3 在图像中添加注释</h3><ol><li><p>使用绘图注释函数（例如 <code>title</code>）在绘图中添加标签。</p><p>此类函数的输入是一个字符串。MATLAB 中的字符串是用双引号 (<code>&quot;</code>) 引起来的。</p></li></ol><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">title(<span class="hljs-string">&quot;Plot Title&quot;</span>)<br></code></pre></div></td></tr></table></figure><ol start="2"><li><p>使用 <code>ylabel</code> 函数给y轴添加标签 </p></li><li><p>使用 <code>legend</code> 函数为绘图添加图例。</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">legend</span>(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>)<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="3-导入数据"><a href="#3-导入数据" class="headerlink" title="3.  导入数据"></a>3.  导入数据</h2><ol><li><p>要提取表变量，可以使用<em>圆点表示法</em>：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">data.VariableName<br></code></pre></div></td></tr></table></figure></li><li><p>您可以通过在实时脚本的输出窗格中点击表来与表进行交互。例如，您可以使用表的一个变量对表进行排序。<br><img src="https://matlabacademy-content.mathworks.com/4.30/R2021a/cn/content/Importing%20Data/Importing%20Data%20as%20a%20Table/images/sorttablesmall.jpg" alt="img"><br>在您对表感到满意时，您可以通过更新代码使更改永久化。</p></li><li><p>圆点表示法用于提取表变量。要提取行，可以使用常规数组索引。</p><p>尝试提取表的前三行：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">top3 = elements(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,:)<br></code></pre></div></td></tr></table></figure><p>请注意，<code>top3</code> 也是一个表。</p></li></ol><h1 id="MATLAB-入门之旅摘要"><a href="#MATLAB-入门之旅摘要" class="headerlink" title="MATLAB 入门之旅摘要"></a>MATLAB 入门之旅摘要</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/matlab_env/create-and-edit-variables.html"><code>x = pi</code></a></td><td align="center">使用等号 (<code>=</code>) 创建变量。 左侧 (<code>x</code>) 是变量的名称，其值为右侧 (<code>pi</code>) 的值。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/learn_matlab/calling-functions.html"><code>y = sin(-5)</code></a></td><td align="center">您可以使用括号提供函数的输入。</td></tr></tbody></table><h2 id="桌面管理"><a href="#桌面管理" class="headerlink" title="桌面管理"></a>桌面管理</h2><table><thead><tr><th align="center">函数</th><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/save.html"><code>save</code></a></td><td align="center"><code>save data.mat</code></td><td align="center">将当前工作区保存到 MAT 文件中。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/load.html"><code>load</code></a></td><td align="center"><code>load data.mat</code></td><td align="center">将 MAT 文件中的变量加载到工作区。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/clear.html"><code>clear</code></a></td><td align="center"><code>clear</code></td><td align="center">清除工作区中的所有变量。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/clc.html"><code>clc</code></a></td><td align="center"><code>clc</code></td><td align="center">清除命令行窗口中的所有文本。</td></tr><tr><td align="center"><a href="https://www.mathworks.com/help/matlab/ref/format.html"><code>format</code></a></td><td align="center"><code>format long</code></td><td align="center">更改数值输出的显示方式。</td></tr></tbody></table><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>4</code></td><td align="center">标量</td></tr><tr><td align="center"><code>[3 5]</code></td><td align="center">行向量</td></tr><tr><td align="center"><code>[1;3]</code></td><td align="center">列向量</td></tr><tr><td align="center"><code>[3 4 5;6 7 8]</code></td><td align="center">矩阵</td></tr></tbody></table><h2 id="等间距向量"><a href="#等间距向量" class="headerlink" title="等间距向量"></a>等间距向量</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>1:4</code></td><td align="center">使用<a href="https://www.mathworks.com/help/matlab/ref/colon.html">冒号 (<code>:</code>)</a> 运算符，创建一个从 <code>1</code> 到 <code>4</code>，间距为 <code>1</code> 的向量。</td></tr><tr><td align="center"><code>1:0.5:4</code></td><td align="center">创建一个从 <code>1</code> 到 <code>4</code>，间距为 <code>0.5</code> 的向量。</td></tr><tr><td align="center"><code>linspace(1,10,5)</code></td><td align="center">创建一个包含 <code>5</code> 个元素的向量。这些值从 <code>1</code> 到 <code>10</code> 均匀间隔。</td></tr></tbody></table><h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>rand(2)</code></td><td align="center">创建一个 <code>2</code> 行 <code>2</code> 列的方阵。</td></tr><tr><td align="center"><code>zeros(2,3)</code></td><td align="center">创建一个 <code>2</code> 行 <code>3</code> 列的矩形矩阵。</td></tr></tbody></table><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>A(end,2)</code></td><td align="center">访问最后一行的第二列中的元素。</td></tr><tr><td align="center"><code>A(2,:)</code></td><td align="center">访问第二行所有元素。</td></tr><tr><td align="center"><code>A(1:3,:)</code></td><td align="center">访问前三行的所有列。</td></tr><tr><td align="center"><code>A(2) = 11</code></td><td align="center">将数组中第二个元素的值更改为 <code>11</code>。</td></tr></tbody></table><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>[1 1; 1 1]*[2 2;2 2] ans =     4    4     4    4</code></td><td align="center">执行<a href="https://www.mathworks.com/help/matlab/matlab_prog/array-vs-matrix-operations.html#btyv9yp-4">矩阵乘法</a>。</td></tr><tr><td align="center"><code>[1 1; 1 1].*[2 2;2 2] ans =     2    2     2    2</code></td><td align="center">执行<a href="https://www.mathworks.com/help/matlab/matlab_prog/array-vs-matrix-operations.html#bu90xxy-1">按元素乘法</a>。</td></tr></tbody></table><h2 id="多个输出"><a href="#多个输出" class="headerlink" title="多个输出"></a>多个输出</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>[xrow,xcol] = size(x)</code></td><td align="center">将 <code>x</code> 中的行数和列数保存为两个不同变量。</td></tr><tr><td align="center"><code>[xMax,idx] = max(x)</code></td><td align="center">计算 <code>x</code> 的最大值及其对应的索引值。</td></tr></tbody></table><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>doc randi</code></td><td align="center">打开 <code>randi</code> 函数的文档页。</td></tr></tbody></table><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>plot(x,y,&quot;ro-&quot;,&quot;LineWidth&quot;,5)</code></td><td align="center">绘制一条红色 (<code>r</code>) 虚线 (<code>--</code>) 并使用圆圈 (<code>o</code>) 标记，线宽很大。</td></tr><tr><td align="center"><code>hold on</code></td><td align="center">在现有绘图中新增一行。</td></tr><tr><td align="center"><code>hold off</code></td><td align="center">为下一个绘图线条创建一个新坐标区。</td></tr><tr><td align="center"><code>title(&quot;My Title&quot;)</code></td><td align="center">为绘图添加标签。</td></tr></tbody></table><h2 id="使用表"><a href="#使用表" class="headerlink" title="使用表"></a>使用表</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>data.HeightYards</code></td><td align="center">从表 <code>data</code> 中提取变量 <code>HeightYards</code>。</td></tr><tr><td align="center"><code>data.HeightMeters = data.HeightYards*0.9144</code></td><td align="center">从现有数据中派生一个表变量。</td></tr></tbody></table><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>[5 10 15] &gt; 12</code></td><td align="center">将向量与值 <code>12</code> 进行比较。</td></tr><tr><td align="center"><code>v1(v1 &gt; 6)</code></td><td align="center">提取 <code>v1</code> 中大于 <code>6</code> 的所有元素。</td></tr><tr><td align="center"><code>x(x==999) = 1</code></td><td align="center">用值 <code>1</code> 替换 <code>x</code> 中等于 <code>999</code> 的所有值。</td></tr></tbody></table><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><table><thead><tr><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>if x &gt; 0.5    y = 3 else    y = 4 end</code></td><td align="center">如果 <code>x</code> 大于 <code>0.5</code>，则将 <code>y</code> 的值设置为 <code>3</code>。  否则，将 <code>y</code> 的值设置为 <code>4</code>。</td></tr><tr><td align="center"><code>for c = 1:3    disp(c) end</code></td><td align="center">循环计数器 (<code>c</code>) 遍历 值 <code>1:3</code>（<code>1</code>、<code>2</code> 和 <code>3</code>）。  循环体显示 <code>c</code> 的每个值。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="/2021/08/31/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-用-的个数来表示标题的大小"><a href="#1-用-的个数来表示标题的大小" class="headerlink" title="1.用#的个数来表示标题的大小"></a>1.用#的个数来表示标题的大小</h3><blockquote><p>Tips:标题的上下两行都必须是空行</p></blockquote><h3 id="2-表示下划线"><a href="#2-表示下划线" class="headerlink" title="2.表示下划线"></a>2.<u>表示下划线</u></h3><blockquote><p>语法格式如下：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>表示下划线<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><h3 id="3-分行符"><a href="#3-分行符" class="headerlink" title="3.分行符"></a>3.分行符</h3><blockquote><p>语法格式如下：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">--- //表示分行符<br></code></pre></div></td></tr></table></figure><blockquote><p>效果如下:</p></blockquote><hr><h3 id="4-创建脚注"><a href="#4-创建脚注" class="headerlink" title="4.创建脚注"></a>4.创建脚注</h3><h4 id="想要创建一个脚注类似这样-脚注"><a href="#想要创建一个脚注类似这样-脚注" class="headerlink" title="想要创建一个脚注类似这样[^脚注]"></a>想要创建一个脚注类似这样[^脚注]</h4><blockquote><p>语法格式如下：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">这是一句话[^1]<br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">这是对应的脚注</span><br></code></pre></div></td></tr></table></figure><p>更优雅的使用方式，是将脚注写在文末，比如：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">正文<br><br><span class="hljs-section">## 参考</span><br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">参考资料1</span><br>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">参考资料2</span><br></code></pre></div></td></tr></table></figure><h3 id="5-代码的显示"><a href="#5-代码的显示" class="headerlink" title="5.代码的显示"></a>5.代码的显示</h3><ul><li>在段落中显示代码用``将其包围</li></ul><blockquote><p>eg.<code>printf(&quot;%d&quot;)</code>函数</p></blockquote><ul><li>使用```</li></ul><h3 id="6-使用-表示列表-但是整篇文档只能使用一种符号"><a href="#6-使用-表示列表-但是整篇文档只能使用一种符号" class="headerlink" title="6.使用+/-/*表示列表(但是整篇文档只能使用一种符号)"></a>6.使用+/-/*表示列表(但是整篇文档只能使用一种符号)</h3><blockquote><p>eg:</p><ul><li>列表第一行</li><li>列表第二行<br><em>列表嵌套:</em> 子列表前面需要四个空格(一个Tab)  </li></ul></blockquote><p>eg:</p><ol><li>父列表<ul><li>子列表第一行</li><li>子列表第二行</li></ul></li></ol><h3 id="7-插入链接"><a href="#7-插入链接" class="headerlink" title="7.插入链接"></a>7.插入链接</h3><blockquote><p>语法格式如下：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">[<span class="hljs-string">xxx</span>](<span class="hljs-link">http:xxx</span>)<br></code></pre></div></td></tr></table></figure><blockquote><p>效果如下:</p></blockquote><p>这里有一个<a href="https://www.bing.com/">链接</a></p><h3 id="8-插入图片"><a href="#8-插入图片" class="headerlink" title="8.插入图片"></a>8.插入图片</h3><blockquote><p>语法格式如下：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">![<span class="hljs-string">xxx</span>](<span class="hljs-link">xxx</span>)<br></code></pre></div></td></tr></table></figure><blockquote><p>效果如下:</p></blockquote><p>这里有一个图片<img src="..." alt="图片"></p><h3 id="9-删除线"><a href="#9-删除线" class="headerlink" title="9.删除线"></a>9.删除线</h3><blockquote><p>语法格式如下：</p></blockquote><p>前后分别用两个<code>～</code>包围</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">~~xxx~~ <br></code></pre></div></td></tr></table></figure><blockquote><p>效果如下:</p></blockquote><p><del>这里没有删除线</del></p><h3 id="10-如果要在列表项目内放进区块，那么就需要在-gt-前添加四个空格的缩进。"><a href="#10-如果要在列表项目内放进区块，那么就需要在-gt-前添加四个空格的缩进。" class="headerlink" title="10.如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。"></a>10.如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</h3><p>区块中使用列表实例如下：</p><ul><li><p>第一项</p><blockquote><p>啊哈<br>啊哈</p></blockquote></li><li><p>第二项</p></li></ul><h3 id="11-表格"><a href="#11-表格" class="headerlink" title="11.表格"></a>11.表格</h3><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><blockquote><p>语法格式如下：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">| 表头   | 表头   |<br>| ------ | ------ |<br>| 单元格 | 单元格 |<br>| 单元格 | 单元格 |<br></code></pre></div></td></tr></table></figure><blockquote><p>效果如下:</p></blockquote><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>我们还可以设置表格的<code>对齐方式</code></p><ul><li>-: 设置内容和标题栏居右对齐</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ul><h3 id="12-输入公式"><a href="#12-输入公式" class="headerlink" title="12. 输入公式"></a>12. 输入公式</h3><h4 id="1-上下标"><a href="#1-上下标" class="headerlink" title="(1) 上下标"></a>(1) 上下标</h4><p>使用<code>^</code>表示上标, 用<code>_</code>表示下标.</p><ul><li>上下标有多个字符时. 要用<code>&#123; &#125;</code>括起来</li></ul><h4 id="2-求和-sum-下标-上标"><a href="#2-求和-sum-下标-上标" class="headerlink" title="(2) 求和 : $$\sum_{下标}^{上标}$$"></a>(2) 求和 : $$\sum_{下标}^{上标}$$</h4><p>公式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$$\sum_&#123;下标&#125;^&#123;上标&#125;$$<br></code></pre></div></td></tr></table></figure><ul><li><p>连乘将sum换成prod即可</p></li><li><p>若想要这种效果: $$\displaystyle\sum_{i=0}^{n}$$, 在<code>\sum</code>前加上<code>\displaystyle</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$$\displaystyle\sum_&#123;i=0&#125;^&#123;n&#125;$$<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="3-分式-根式"><a href="#3-分式-根式" class="headerlink" title="(3) 分式 根式"></a>(3) 分式 根式</h4><p>使用<code>\frac&#123;分子&#125;&#123;分母&#125;</code>来表示分式</p><p>使用<code>\sqrt[开方次数]&#123;被开方公式&#125;</code>来表示分式 </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记</title>
    <link href="/2021/08/31/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Part-1：语法"><a href="#Part-1：语法" class="headerlink" title="Part 1：语法"></a>Part 1：语法</h2><h3 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1. 关键字"></a>1. 关键字</h3><h4 id="lt-1-gt-static关键字"><a href="#lt-1-gt-static关键字" class="headerlink" title="&lt;1&gt; static关键字"></a>&lt;1&gt; static关键字</h4><h5 id="1-static修饰方法："><a href="#1-static修饰方法：" class="headerlink" title="(1) static修饰方法："></a>(1) static修饰方法：</h5><p>分为静态方法和非静态方法：</p><ul><li><p><strong>静态方法</strong>是在类中使用<code>staitc</code>修饰的方法，在类定义的时候已经被装载和分配。</p></li><li><p><strong>非静态方法</strong>是不加<code>static</code>关键字的方法，在类定义时没有占用内存，非静态方法只有在类被实例化成对象时，对象调用该方法才被分配内存.</p></li></ul><blockquote><p>注意: <strong>静态方法只能访问静态成员</strong>，<strong>实例方法可以访问静态和实例成员</strong>。</p><p>因为实例成员和变量属于某个对象的, 而静态方法在使用时,不一定存在对象, 所以不允许访问.</p></blockquote><p>调用静态方法可以<strong>无需创建对象</strong> </p><p>而调用实例方法则<strong>需要创建对象</strong></p><h5 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h5><ul><li>所有静态方法: <code> 类名.方法名</code></li><li>实例方法: <ul><li>当前类: <code>this.方法名 </code>(this可省略)</li><li>其他类:<code>对象名.方法名</code><ul><li>子类调用父类: <code>super.方法名</code></li></ul></li></ul></li></ul><h5 id="2-static修饰变量"><a href="#2-static修饰变量" class="headerlink" title="(2)static修饰变量"></a>(2)static修饰变量</h5><p>也称为<strong>静态变量</strong>。</p><ul><li><p>静态变量<strong>被所有对象共享</strong>，内存中只有<strong>一个副本</strong>，在<strong>类初次加载的时候</strong>才会初始化</p></li><li><p>非静态变量是<strong>对象所拥有的</strong>，在<strong>创建对象的时候</strong>被初始化，存在多个副本，各个对象拥有的副本互不影响</p></li><li><p>static不允许用来修饰局部变量</p></li></ul><blockquote><p>与C/C++中的static不同，Java中的static关键字<strong>不会影响到变量或者方法的作用域</strong></p><p>静态成员变量虽然独立于对象，但是<strong>不代表不可以通过对象去访问</strong>，所有的静态方法和静态变量<strong>都可以通过对象访问</strong>（只要访问权限足够）。</p></blockquote><h4 id="lt-2-gt-final-关键字"><a href="#lt-2-gt-final-关键字" class="headerlink" title="&lt;2&gt; final 关键字"></a>&lt;2&gt; final 关键字</h4><ul><li><p>声明类: 表示该类<strong>不能继承</strong>，即最终类；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<span class="hljs-comment">//类体&#125;</span><br></code></pre></div></td></tr></table></figure></li><li><p>声明方法: 表示该方法<strong>不能被子类重写</strong>, 即最终方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">修饰符(<span class="hljs-keyword">public</span>/<span class="hljs-keyword">protected</span>/<span class="hljs-keyword">default</span>/<span class="hljs-keyword">private</span>) <span class="hljs-keyword">final</span> 返回值类型 方法名()&#123;<span class="hljs-comment">//方法体&#125;</span><br></code></pre></div></td></tr></table></figure></li><li><p>声明变量: 表示该变量不可修改, 即最终变量</p></li></ul><h4 id="lt-3-gt-this-关键字"><a href="#lt-3-gt-this-关键字" class="headerlink" title="&lt;3&gt;this 关键字"></a>&lt;3&gt;this 关键字</h4><ul><li><p><code>this.属性名称</code>: 访问本类的成员变量, 用来区分成员变量和局部变量</p></li><li><p><code>this.方法名称</code>: 访问本类的成员方法</p><ul><li><p>特例: <code>this(参数)</code>: 访问本类的构造方法,但注意:</p><blockquote><p>1.不能在普通方法中使用, 只能写在构造方法中</p><ol start="2"><li>必须是构造方法的第一条语句</li></ol></blockquote></li></ul></li></ul><h3 id="2-修饰符"><a href="#2-修饰符" class="headerlink" title="2.修饰符"></a>2.修饰符</h3><p>public &gt; protected &gt; package &gt; private</p><h4 id="lt-1-gt-protected修饰符"><a href="#lt-1-gt-protected修饰符" class="headerlink" title="&lt;1&gt;protected修饰符"></a>&lt;1&gt;protected修饰符</h4><blockquote><p>被protected 修饰的成员对于<strong>本包和其子类</strong>可见</p></blockquote><p><strong>详解</strong>: protected的可见性在于:</p><ul><li>父类的 protected 成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例<strong>可以访问</strong>其从父类<strong>继承而来</strong>的protected成员（子类的），而<strong>不能访问</strong>父类实例的protected成员（父类的）。</li></ul><p>例子: 第9章作业题</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> homework.ch9.p1;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> homework.ch9.p2;<br><span class="hljs-keyword">import</span> homework.ch9.p1.A;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> A().j = <span class="hljs-number">10</span>;<span class="hljs-comment">//不同包中,父类的protected变量不可访问</span><br>        <span class="hljs-keyword">this</span>.j = <span class="hljs-number">10</span>;<span class="hljs-comment">//指当前类B的继承来的protected变量,可以访问</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-可变参数"><a href="#3-可变参数" class="headerlink" title="3.可变参数"></a>3.可变参数</h3><p>可变参数用类型<code>...</code>定义，可变参数<strong>相当于数组类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Group</span> </span>&#123;<br><span class="hljs-keyword">private</span> String[] names;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNames</span><span class="hljs-params">(String... names)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.names = names;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h3><h4 id="4-1-向上转型"><a href="#4-1-向上转型" class="headerlink" title="4.1 向上转型"></a>4.1 向上转型</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Person p= <span class="hljs-keyword">new</span> Student();<span class="hljs-comment">//Student是Person的子类</span><br>p是一个引用类型为Person，实际类型为Student的变量<br></code></pre></div></td></tr></table></figure><p>​        这种指向是允许的，因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。所以说，<code>Person</code>类型的变量<code>p</code>，指向<code>Student</code>类型的实例，对<code>p</code>做任何<code>Person</code>的操作, <code>Student</code>实例都能实现。</p><p>​        变量p指向的还是一个<code>Student</code>类型的实例对象，只是p的操作被局限在<code>Person</code> 所具有的内容中。</p><blockquote><p>与之相反的就是向下转型: 把父类类型强制转型为子类类型</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Student s=<span class="hljs-keyword">new</span> Person();<br></code></pre></div></td></tr></table></figure><p><strong>很可能会失败!</strong> 因为s为student类型的变量, 而<code>Person</code>很可能没有<code>Student</code>的部分内容。</p></blockquote><ul><li>从现实的角度来理解：一个Student，说他是个Person那肯定没错；但一个Person不一定是Student</li></ul><h4 id="4-2-多态"><a href="#4-2-多态" class="headerlink" title="4.2 多态"></a>4.2 多态</h4><p>由4.1中的例子，对于变量p，其实际类型为Student，而引用类型为Person，那么p.run()调用的是谁的方法？</p><p>答案是：<code>Student</code></p><p>这说明：Java的<em><strong>实例方法</strong></em>调用是<strong>基于运行时的实际类型</strong>的动态调用，<strong>而非变量的声明类型</strong>。　　　　（１）</p><p>这就是<strong>多态</strong></p><blockquote><p>多态的特性就是，<strong>运行期才能动态决定</strong>调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法</p><p>多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p></blockquote><ul><li>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用.</li></ul><h5 id="注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）"><a href="#注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）" class="headerlink" title="注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）"></a>注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）</h5><h4 id="4-3-抽象类"><a href="#4-3-抽象类" class="headerlink" title="4.3 抽象类"></a>4.3 抽象类</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类。</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。</p><p>即<code>Person</code>的子类必须覆写<code>run()</code>方法。</p><ul><li>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Person s = <span class="hljs-keyword">new</span> Student();<br>Person t = <span class="hljs-keyword">new</span> Teacher();<br></code></pre></div></td></tr></table></figure><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型。这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><h4 id="4-4-接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）"><a href="#4-4-接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）" class="headerlink" title="4.4 接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）"></a>4.4 接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）</h4><h5 id="4-4-1-定义"><a href="#4-4-1-定义" class="headerlink" title="4.4.1 定义"></a>4.4.1 定义</h5><p>​        所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p><p>​        当一个<code>class</code>去实现一个接口时, 使用<code>implement</code>关键字</p><p>​        与继承不同, 一个类只能继承自一个父类, 但一个类却能实现<strong>多个接口</strong></p><h5 id="4-4-2-接口继承"><a href="#4-4-2-接口继承" class="headerlink" title="4.4.2 接口继承"></a>4.4.2 接口继承</h5><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。</p><h5 id="4-4-3-default方法"><a href="#4-4-3-default方法" class="headerlink" title="4.4.3 default方法"></a>4.4.3 default方法</h5><p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(getName() + <span class="hljs-string">&quot; run&quot;</span>);    &#125;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="５-异常"><a href="#５-异常" class="headerlink" title="５.异常"></a>５.异常</h3><h4 id="5-1-抛出异常"><a href="#5-1-抛出异常" class="headerlink" title="5.1 抛出异常"></a>5.1 抛出异常</h4><p>抛出异常分两步：</p><ol><li>创建某个<code>Exception</code>的实例；</li><li>用<code>throw</code>语句抛出。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s==<span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    &#125;&#125;<br></code></pre></div></td></tr></table></figure><ul><li>JVM先执行<code>finally</code>中的语句, 再抛出异常; 但若<code>finally</code>中也抛出了异常, catch抛出的异常会被屏蔽。绝大多数情况下，在<code>finally</code>中不要抛出异常。若真有需求，使用<code>Throwable.addSuppressed()</code>, 具体自行百度.</li></ul><h4 id="5-2捕获异常"><a href="#5-2捕获异常" class="headerlink" title="5.2捕获异常"></a>5.2捕获异常</h4><p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明.</p><ul><li><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类。</p><ul><li>使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<strong>不再</strong>继续匹配。即：多个<code>catch</code>语句<strong>只有一个能被执行</strong>。所以顺序很重要，要把子类放前面。</li><li><code>try ... catch</code>还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。</li><li>catch语句和finally语句至少得有一个，可以理解为两个同级的出口</li></ul></li><li><p>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。</p><blockquote><p>某个方法抛出了异常时，若当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try ... catch</code>被捕获为止</p></blockquote><ul><li>调用方在调用这些方法的时候，必须强制捕获这些异常，否则编译器会报错。</li><li>我们也可以不捕获它，而是在调用了这些方法的方法定义处加上<code>throws xxx</code></li></ul></li><li><p>可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在<strong>更高的调用层捕获</strong>。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会。</p><p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>。</p><blockquote><p>因为<code>main()</code>方法声明了可能抛出<code>Exception</code>，也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p></blockquote></li><li><p>所有异常都可以<strong>调用<code>printStackTrace()</code>方法打印异常栈</strong>，这是一个简单有用的快速打印异常的方法。</p></li></ul><h4 id="5-3-最常见的NullPointerException"><a href="#5-3-最常见的NullPointerException" class="headerlink" title="5.3 最常见的NullPointerException"></a>5.3 最常见的NullPointerException</h4><p>好的编码习惯可以极大地降低<code>NullPointerException</code>的产生:</p><ol><li>成员变量在定义时初始化：</li></ol><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name = <span class="hljs-string">&quot;&quot;</span>;&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li><p>使用空字符串<code>&quot;&quot;</code>而不是默认的<code>null</code>可避免很多<code>NullPointerException</code>.</p></li><li><p>返回空字符串<code>&quot;&quot;</code>、空数组而不是<code>null</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">public <span class="hljs-keyword">String</span>[] readLinesFromFile(<span class="hljs-keyword">String</span> <span class="hljs-keyword">file</span>) &#123;    <span class="hljs-keyword">if</span> (getFileSize(<span class="hljs-keyword">file</span>) == <span class="hljs-number">0</span>) &#123;        // 返回空数组而不是null:        <span class="hljs-keyword">return</span> new <span class="hljs-keyword">String</span>[<span class="hljs-number">0</span>];    &#125;    ...&#125;<br></code></pre></div></td></tr></table></figure><p>这样可以使得调用方无需检查结果是否为<code>null</code>。</p></li></ol><blockquote><p> 如果调用方一定要根据<code>null</code>判断，比如返回<code>null</code>表示文件不存在，那么考虑返回<code>Optional&lt;T&gt;</code></p></blockquote><p><strong>定位NullPointerException</strong></p><p>可以启用Java 14的增强异常信息来查看<code>NullPointerException</code>的详细错误信息。</p><p>这种增强的<code>NullPointerException</code>详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个<code>-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java -XX:+ShowCodeDetailsInExceptionMessages Main.java<br></code></pre></div></td></tr></table></figure><h3 id="6-I-O"><a href="#6-I-O" class="headerlink" title="6.I/O"></a>6.I/O</h3><p>Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符</p><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl">// 假设当前目录是C:\DocsFile f1 = new File(<span class="hljs-string">&quot;sub\\javac&quot;</span>); <span class="hljs-regexp">//</span> 绝对路径是C:\Docs\<span class="hljs-function"><span class="hljs-keyword">sub</span>\<span class="hljs-title">javacFile</span> <span class="hljs-title">f3</span> = <span class="hljs-title">new</span> <span class="hljs-title">File</span></span>(&quot;.\\<span class="hljs-keyword">sub</span>\\javac&quot;); // 绝对路径是C:\Docs\<span class="hljs-function"><span class="hljs-keyword">sub</span>\<span class="hljs-title">javac</span></span><br></code></pre></div></td></tr></table></figure><p>可以用<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p><h3 id="7-覆写clone（）"><a href="#7-覆写clone（）" class="headerlink" title="7.覆写clone（）"></a>7.覆写clone（）</h3><h4 id="7-1-List深拷贝"><a href="#7-1-List深拷贝" class="headerlink" title="7.1 List深拷贝"></a>7.1 List深拷贝</h4><p><a href="https://blog.csdn.net/DeMonliuhui/article/details/54572908">看这里</a></p><h3 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8. 泛型"></a>8. 泛型</h3><h4 id="8-1-使用通配符"><a href="#8-1-使用通配符" class="headerlink" title="8.1 使用通配符"></a>8.1 使用通配符</h4><h5 id="1-extends"><a href="#1-extends" class="headerlink" title="1. extends"></a>1. extends</h5><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p><h5 id="2-super"><a href="#2-super" class="headerlink" title="2. super"></a>2. super</h5><p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p><ul><li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li><li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li></ul><p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p><p>换句话说，使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p><h5 id="3-PECS-原则"><a href="#3-PECS-原则" class="headerlink" title="3. PECS 原则"></a>3. PECS 原则</h5><p>ECS原则：Producer Extends Consumer Super。</p><p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p><h4 id="8-2-擦拭法"><a href="#8-2-擦拭法" class="headerlink" title="8.2 擦拭法"></a>8.2 擦拭法</h4><p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code>int</code>；</li><li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li></ul><h3 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="# 零碎知识点"></a># 零碎知识点</h3><h5 id="（1）既对字段进行初始化，又在构造方法中对字段进行初始化："><a href="#（1）既对字段进行初始化，又在构造方法中对字段进行初始化：" class="headerlink" title="（1）既对字段进行初始化，又在构造方法中对字段进行初始化："></a>（1）既对字段进行初始化，又在构造方法中对字段进行初始化：</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;Unamed&quot;</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age =<span class="hljs-number">10</span>;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;            <span class="hljs-keyword">this</span>.name=name;            <span class="hljs-keyword">this</span>.age=age;        &#125;        &#125;<br></code></pre></div></td></tr></table></figure><p><strong>Q:</strong> 当我们创建对象的时候，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>得到的对象实例，字段的初始值是啥？</p><p>**A: **在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p><ol><li><p>先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；</p></li><li><p>执行构造方法的代码进行初始化。</p></li></ol><p>因此，构造方法的代码由于后运行，所以，new Person(“Xiao Ming”, 12)的字段值最终由构造方法的代码确定。</p><h5 id="（2）增强for循环（for-each）"><a href="#（2）增强for循环（for-each）" class="headerlink" title="（2）增强for循环（for each）"></a>（2）增强for循环（for each）</h5><p>增强for循环不会修改原数组的值</p><blockquote><p>因为每一次loop你只是获得了当前元素的值，却没有获得当前元素在数组中的对象句柄。这样就无法直接操作对应的句柄。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] s=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v: s)&#123;    ++v;&#125;<span class="hljs-comment">//s数组的值不会变化!</span><br></code></pre></div></td></tr></table></figure><blockquote><p>想遍历数组并只想获得元素值的时候才用for-each</p><p>其他的时候比如想修改数组，或者想获得index的时候就别用for-each</p></blockquote><h5 id="（3）字符串相加"><a href="#（3）字符串相加" class="headerlink" title="（3）字符串相加"></a>（3）字符串相加</h5><ul><li><p><strong>都是静态字符串</strong>的结果会添加到字符串池;</p></li><li><p>如果其中<strong>含有变量</strong>则<strong>不会</strong>进入字符串池中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;Hello&quot;</span>;String b = a+<span class="hljs-string">&quot;world&quot;</span>;    <span class="hljs-comment">//含有变量a，不会进入String c = &quot;Hello&quot;+&quot; world&quot;;//进入常量池String d = &quot;Hello world&quot;;//c==d, 但b不等于d//注意，final修饰的字符串当作静态字符串来看，不是变量final String s1=&quot;Hello&quot;;final String s2=&quot; world&quot;;s1+s2==d;//结果为ture</span><br></code></pre></div></td></tr></table></figure></li><li><p>字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。</p></li></ul><h2 id="Part-2：Tips"><a href="#Part-2：Tips" class="headerlink" title="Part 2：Tips"></a>Part 2：Tips</h2><h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h4><blockquote><p>多行注释和单行注释与c相同 </p></blockquote><h5 id="文档注释-可以使用javadoc提取注释-自动形成API文档"><a href="#文档注释-可以使用javadoc提取注释-自动形成API文档" class="headerlink" title="文档注释: 可以使用javadoc提取注释, 自动形成API文档"></a>文档注释: 可以使用<code>javadoc</code>提取注释, 自动形成API文档</h5><p>点击<code>Tools</code> -&gt; <code>Generate JavaDoc</code> 选择output 文件夹为doc目录(需要新建)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">特点:第一个斜杠后两个*注释对象:紧跟其后的代码块<span class="hljs-comment">/**注释内容   注释内容*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>&#123;    xxx&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>形成写文档注释的习惯</p></blockquote><h4 id="2-注意import"><a href="#2-注意import" class="headerlink" title="2. 注意import"></a>2. 注意import</h4><h2 id="Part-3：IDE及命令行"><a href="#Part-3：IDE及命令行" class="headerlink" title="Part 3：IDE及命令行"></a>Part 3：IDE及命令行</h2><h3 id="一、Idea的使用"><a href="#一、Idea的使用" class="headerlink" title="一、Idea的使用"></a>一、Idea的使用</h3><h4 id="1-基本流程"><a href="#1-基本流程" class="headerlink" title="1. 基本流程"></a>1. 基本流程</h4><p><code>new project</code> -&gt; <code>在src下创建一个package</code> -&gt; <code>在package下创建class</code>  </p><blockquote><p>在项目文件夹下创建一个bin目录, 用于存放编译成功的.class文件</p><p>创建后需要到<code>File</code> -&gt; <code>Project Structure</code> 中修改<code>Project compiler output</code></p></blockquote><h4 id="2-奇技淫巧"><a href="#2-奇技淫巧" class="headerlink" title="2. 奇技淫巧"></a>2. 奇技淫巧</h4><h5 id="2-1-生成弹出对话框"><a href="#2-1-生成弹出对话框" class="headerlink" title="2.1 生成弹出对话框"></a>2.1 生成弹出对话框</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.swing.JOp<br></code></pre></div></td></tr></table></figure><h3 id="二、命令行的使用"><a href="#二、命令行的使用" class="headerlink" title="二、命令行的使用"></a>二、命令行的使用</h3><h4 id="1-注意"><a href="#1-注意" class="headerlink" title="1. 注意"></a>1. 注意</h4><ul><li><p>在使用<code>javac</code> 编译时, shell目前所处的目录应为package的顶级目录,即<code>src</code>目录</p><p>例如：package名为 homework.ch1, 则在该目录系统中, class文件夹就相当于 src文件夹</p><ul><li>文件的目录结构如下：<img src="C:\Users\池炜恒\AppData\Roaming\Typora\typora-user-images\image-20210305163509008.png" alt="image-20210305163509008"></li></ul><p>​        那么 shell所处的目录应为：./chapter1/class</p><p>​    </p><ul><li><p>运行Welcome.class时, 类名要打全! 要带上package名,这样jvm才找得到</p><blockquote><p>这是因为JVM只看完整类名 , 编译器编译出的class文件也只使用完整类名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$  java homework.ch1.Welcome<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><h2 id="Part-4-：作业知识点"><a href="#Part-4-：作业知识点" class="headerlink" title="Part 4 ：作业知识点"></a>Part 4 ：作业知识点</h2><h4 id="4-1-chapter-2-3"><a href="#4-1-chapter-2-3" class="headerlink" title="4.1 chapter 2-3"></a>4.1 chapter 2-3</h4><ol><li><p>switch 语句的判断条件expression的计算结果只能是__不大于int__的类型</p></li><li><p>Java源程序经过编译后生成被称为 <strong>字节码</strong> 的特殊机器语言码</p></li><li><p>&amp;&amp;为条件逻辑运算符，&amp;为无条件逻辑运算符，有区别</p></li><li><p>Java中所有的方法都__必须在类内定义__</p></li><li><p>一些规则:</p><ul><li><p>一个源文件中__只能有一个public类__。</p></li><li><p>一个源文件__可以有多个非public类__。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span></span>&#123; <span class="hljs-comment">//只能有一个public class,且该文件必须命名为C1.java    ...&#125;class C2 &#123;&#125;final class C3&#123;&#125;...//可以有任意个 class</span><br></code></pre></div></td></tr></table></figure></li><li><p>源文件的名称应该__和public类的类名保持一致__。例如：源文件中public类的类名是Employee，那么源文件应该命名Employee.java。</p></li><li><p>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</p></li><li><p>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</p></li></ul></li><li><p>java标识符__严格区分大小写__, __不能__以数字开头</p></li></ol><h4 id="4-2-Chapter-4-5"><a href="#4-2-Chapter-4-5" class="headerlink" title="4.2 Chapter 4-5"></a>4.2 Chapter 4-5</h4><ol><li><p>字符串函数：</p><ul><li><p>indexof(): 返回某个字符串在字符串中<strong>首次出现</strong>的位置，从0开始计数（用数组下标理解）</p></li><li><p>lastIndexof(): <strong>最后一次</strong>出现的位置</p><ul><li><p><strong>public int lastIndexOf(int ch):</strong> 返回指定字符在此字符串中<strong>最后一次</strong>出现处的索引，如果此字符串中没有这样的字符，则<strong>返回 -1</strong>。</p></li><li><p><strong>public int lastIndexOf(int ch, int fromIndex):</strong> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行<strong>反向搜索</strong>，如果此字符串中没有这样的字符，则返回 -1。</p><blockquote><p>fromIndex: 开始搜索的索引位置</p></blockquote></li></ul></li><li><p>substring(): 用于截取字符串的一部分，返回新字符串</p><ul><li>substring(0,11): 表示0-<strong>10</strong>的子串</li><li>substring(11): 表示从11-末尾的子串</li></ul></li></ul><blockquote><p>注意: 字符串函数中,若参数为(int, int), 如substring(0,11),则一般为数组下标0 - <strong>(11-1)<strong>的字符的范围, 即</strong>不含后一个参数</strong>的范围</p><p>如何理解? </p><p>非常容易。可以把这两个数字看成地址，地址0-1之间的内存储存第一个字符，那么显然0-11的地址范围不包括位置11上的字符</p></blockquote><ul><li>int length(): 返回字符串的长度，（字符数）</li><li>concat(String s): 将s连接到当前字符串上</li></ul></li></ol><ul><li>清空StringBuffer s：s.delete(0,length()-1);  或者  s.setLength(0);</li></ul><h4 id="4-3-Chapter-6-7"><a href="#4-3-Chapter-6-7" class="headerlink" title="4.3 Chapter 6-7"></a>4.3 Chapter 6-7</h4><ol><li><p><code>length</code>和<code>length()</code>是不同的</p><ol><li>length用于求<strong>数组</strong>的长度, 即数组元素个数 </li><li>length()用于求<strong>字符串对象</strong>的长度</li></ol></li><li><p>数组声明和初始化语句</p><ul><li><p><code>int a[]=null</code>等效于<code>int[] b=&#123;&#125;</code>;</p></li><li><p><code>int[] c=&#123;1,2,3,4&#125; </code>等效于<code>int[] c</code>= new <strong>int[]</strong>{1,2,3,4} </p><p><strong>注意：</strong>此处<code>new int[]</code>的<code>[]</code>不能少！</p><p>int[ ] c=new int{1,2,3,4} 错误!</p></li><li><p>int[ ] d[ ]=new int[5][ ]</p></li></ul></li><li><p>判断：局部变量在使用前必须通过初始化或者赋值语句显式地给一个值。( √ )</p><p>原因：<strong>局部变量必须初始化</strong>,而类的成员变量有默认值0,不用初始化</p><blockquote><p>注意: 成员变量和局部变量<strong>不同</strong>! 区别如下: </p></blockquote><p><strong>1.在类中的位置不同</strong></p><p>成员变量: 在类中, 方法外</p><p>局部变量: 在方法中, 代码块, 或形参列表中</p><p><strong>2.在内存中的位置不同</strong></p><p>成员变量: 堆中(与<strong>对象</strong>共存亡)</p><p>局部变量: 栈中(与<strong>方法调用或代码块的执行</strong>共存亡)</p><p><strong>3.初始值</strong></p><p>成员变量: 有默认初始值</p><p>局部变量: 没有默认初始值, 使用前<strong>必须初始化</strong></p></li><li><p>仅返回类型不同的方法不是合法的重载</p><blockquote><p><strong>方法重载</strong>：指方法名称相同，但<strong>形参列表不同</strong>的方法</p></blockquote></li></ol><h4 id="4-4-Chapter-9"><a href="#4-4-Chapter-9" class="headerlink" title="4.4 Chapter 9"></a>4.4 Chapter 9</h4><ol><li><p>静态方法不能访问实例变量</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;    m =<span class="hljs-number">1</span>;<span class="hljs-comment">//会报错，因为fun()为静态方法&#125; //将m改为static即可</span><br></code></pre></div></td></tr></table></figure></li><li><p>private权限</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AA</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//注意i为privateAA(int i)&#123;this.i =i;&#125;String AA(long i) &#123;this.i = i;return  &quot;i = &quot; + this.i;&#125;&#125;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>在其他类中,使用<code>new AA(10)</code>创建一个实例对象<code>test</code></p><p>因为<code>i</code>为<code>private</code>(仅类内能访问), 所以不能通过<code>test.i</code>在其他类中访问<code>i</code>；</p><p>但是可以通过调用<code>String AA(long i)函数</code>来<strong>间接修改</strong><code>i</code>的值！</p><p>因为AA函数位于类AA中, 可以访问i. 且权限为<code>package</code>，同一包的实例对象都可以调用</p></blockquote></li></ol><h4 id="4-5-Chapter-11-13"><a href="#4-5-Chapter-11-13" class="headerlink" title="4.5 Chapter 11-13"></a>4.5 Chapter 11-13</h4><ol><li><p>抽象类：<strong>含有</strong>抽象方法的类，可以有非抽象方法（包括构造方法）和实例字段，也可以是非抽象类的子类</p><p>与接口的区别：</p><p>1）接口不能有构造方法，抽象类可以有。</p><p>2）接口不能有方法体，抽象类可以有。</p><p>3）接口不能有静态方法，抽象类可以有。</p></li><li><p>接口可以继承多个父接口，而类只能继承一个父类</p><blockquote><p>不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？</p><p>但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。</p></blockquote></li><li><p>使用父类的引用变量指向子类实例，若父类的实例方法被覆盖，则调用子类的实例方法（多态性）；若没被覆盖，则调用子类的实例方法。</p></li></ol><h4 id="4-6-Chapter-19"><a href="#4-6-Chapter-19" class="headerlink" title="4.6 Chapter 19"></a>4.6 Chapter 19</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s2</span><span class="hljs-params">(T i)</span> </span>&#123;&#125; <span class="hljs-comment">//编译报错，类型变量T无法在静态上下文中被引用</span><br></code></pre></div></td></tr></table></figure><h4 id="4-7-Chapter-30"><a href="#4-7-Chapter-30" class="headerlink" title="4.7 Chapter 30"></a>4.7 Chapter 30</h4><ol><li>sleep不会释放锁，await会</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习笔记</title>
    <link href="/2021/08/31/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Part1：菜鸟教程"><a href="#Part1：菜鸟教程" class="headerlink" title="Part1：菜鸟教程"></a>Part1：菜鸟教程</h2><h3 id="1-C-基本数据类型"><a href="#1-C-基本数据类型" class="headerlink" title="1. C++基本数据类型"></a>1. C++基本数据类型</h3><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p><table><thead><tr><th align="center">类型</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">布尔型</td><td align="center">bool</td></tr><tr><td align="center">字符型</td><td align="center">char</td></tr><tr><td align="center">整型</td><td align="center">int</td></tr><tr><td align="center">浮点型</td><td align="center">float</td></tr><tr><td align="center">双浮点型</td><td align="center">double</td></tr><tr><td align="center">无类型</td><td align="center">void</td></tr><tr><td align="center">宽字符型</td><td align="center">wchar_t</td></tr></tbody></table><blockquote><p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p></blockquote><h3 id="2-C-修饰符类型"><a href="#2-C-修饰符类型" class="headerlink" title="2. C++修饰符类型"></a>2. C++修饰符类型</h3><p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p><p>下面列出了数据类型修饰符：</p><ul><li>signed</li><li>unsigned</li><li>long</li><li>short</li></ul><p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p><p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p><p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>unsigned、long</strong>，<code>int</code> 是隐含的。</p><h3 id="3-C-储存类"><a href="#3-C-储存类" class="headerlink" title="3.C++储存类"></a>3.C++储存类</h3><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。</p><p>因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h3><p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5.引用"></a>5.引用</h3><p>引用变量是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><h4 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h4><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p>我们可以为 i 声明引用变量，如下所示：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">int<span class="hljs-meta">&amp;  r = i;</span><br></code></pre></div></td></tr></table></figure><p>之后，r就可以当作正常的变量使用</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; x, <span class="hljs-keyword">int</span>&amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">int</span> temp;<br>   temp = x; <span class="hljs-comment">/* 保存地址 x 的值 */</span><br>   x = y;    <span class="hljs-comment">/* 把 y 赋值给 x */</span><br>   y = temp; <span class="hljs-comment">/* 把 x 赋值给 y  */</span><br>   <span class="hljs-keyword">return</span>;<br>&#125;<span class="hljs-comment">//通过引用的方式传入参数，既可以免去指针操作的繁琐，又可以修改原参数</span><br></code></pre></div></td></tr></table></figure><h1 id="Part2：OI-WIKI"><a href="#Part2：OI-WIKI" class="headerlink" title="Part2：OI WIKI"></a>Part2：OI WIKI</h1><h2 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1. 内存分配"></a>1. 内存分配</h2><p>​        C++ 中新增了 <code>new</code> 和 <code>delete</code> 关键字用来在“自由存储区”上分配空间，这个自由存储区可以是堆也可以是静态存储区，他们是为了配合“类”而出现的。其中 <code>delete[]</code> 还能够直接释放动态数组的内存，非常方便。<code>new</code> 和 <code>delete</code> 关键字会调用类型的构造函数和析构函数，相比 C 中的 <code>malloc()</code>、<code>realloc()</code>、<code>free()</code> 函数，他们对类型有更完善的支持，<strong>但是效率不如 C 中的这些函数</strong>。</p><p>​        简而言之，如果你需要动态分配内存的对象是<strong>基础类型或他们的数组</strong>，那么你可以**使用 <code>malloc()</code> **进行更高效的内存分配；但如果你新建的对象是非基础的类型，那么建议使用 <code>new</code> 以获得安全性检查。值得注意的是尽管 <code>new</code> 和 <code>malloc()</code> 都是返回指针，但是 <code>new</code> 出来的指针 <strong>只能</strong> 用 <code>delete</code> 回收，而 <code>malloc()</code> 出来的指针也只能用 <code>free()</code> 回收，否则会有内存泄漏的风险</p><h2 id="2-struct"><a href="#2-struct" class="headerlink" title="2. struct"></a>2. struct</h2><p>​    尽管在 C 和 C++ 中都有 struct 的概念，但是他们对应的东西是不能混用的！C 中的 struct 用来描述一种固定的内存组织结构，而 <strong>C++ 中的 struct 就是一种类</strong>，<strong>它与类唯一的区别就是它的成员和继承行为默认是 public 的</strong>，而一般类的默认成员是 private 的。这一点在写 C/C++ 混合代码时尤其致命。</p><p>另外，声明 struct 时 C++ 也不需要像 C 那么繁琐，</p><p>C 版本：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node_t</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node_t</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">int</span> key;<br>&#125; Node;<br></code></pre></div></td></tr></table></figure><p>C++ 版本</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  Node *next;<br>  <span class="hljs-keyword">int</span> key;<br>&#125;;<span class="hljs-comment">//和类的声明非常类似</span><br></code></pre></div></td></tr></table></figure><h2 id="3-类"><a href="#3-类" class="headerlink" title="3. 类"></a>3. 类</h2><p>类（class）是结构体的拓展，不仅能够拥有成员元素，还拥有成员函数。</p><p>C++ 中 <code>struct</code> 关键字定义的也是类，上文中的 <strong>结构体</strong> 的定义来自 C。因为某些历史原因，C++ 保留并拓展了 <code>struct</code>。</p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>类使用关键字 <code>class</code> 或者 <code>struct</code> 定义，下文以 <code>class</code> 举例。</p><h3 id="访问说明符"><a href="#访问说明符" class="headerlink" title="访问说明符"></a>访问说明符</h3><ul><li><code>public</code>：<strong>类内</strong> 还是 <strong>类外</strong> 都可以访问。</li><li><code>protected</code>：可以被<strong>类内、派生类</strong>或者友元的成员访问，但类外<strong>不能访问</strong>。</li><li><code>private</code>：只能被 <strong>类内</strong> 成员或者友元的成员访问，<strong>不能</strong> 被从类外或者派生类中访问。</li></ul><p>对于 <code>struct</code>，它的所有成员都是默认 <code>public</code>。对于 <code>class</code>，它的所有成员都是默认 <code>private</code>。</p><blockquote><p>友元：使用 <code>friend</code> 关键字修饰某个函数或者类。</p><p>简单来说就是只要带有这个类的 <code>friend</code> 标记，就<strong>可以访问私有</strong>或<strong>受保护</strong>的成员元素。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下使用命令行打开网页</title>
    <link href="/2021/08/31/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5/"/>
    <url>/2021/08/31/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>部分应用没有Linux版本，而使用wine版本又存在bug，对于有网页版的应用，我们可以使用如下的方式。</p><p>以下以test为例</p></blockquote><ol><li><p>创建文件夹test</p></li><li><p>cd进该文件夹，执行<code>yarn init</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ code index.js<br><span class="hljs-comment">#输入以下内容</span><br>const &#123; app, BrowserWindow, Menu &#125; = require(<span class="hljs-string">&#x27;electron&#x27;</span>)<br>Menu.setApplicationMenu(null);<br>app.on(<span class="hljs-string">&#x27;ready&#x27;</span>, ()=&gt;&#123;<br><span class="hljs-built_in">let</span> win = new BrowserWindow()<br>win.loadURL(<span class="hljs-string">&#x27;目标网址&#x27;</span>)<br>&#125;)<br>$ electron .<br><span class="hljs-comment">#或者 </span><br>$ electron ~/Code/linux_app_repo/<span class="hljs-built_in">test</span> <span class="hljs-comment">#绝对路径（这里是我的绝对路径，以实际情况为准）</span><br></code></pre></div></td></tr></table></figure></li><li><p>将上述的electron指令写入到xxx.sh文件中，并将该sh文件<code>mv</code>到<code>/usr/local/bin</code>下</p></li><li><p>编辑<code>～/.zshrc</code>，使用<code>alias</code>指令将xxx.sh转换为想要的指令名，然后<code>source</code>一下即可生效</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OI Wiki学习笔记</title>
    <link href="/2021/08/31/OI-Wiki%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/31/OI-Wiki%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Part1：语言基础"><a href="#Part1：语言基础" class="headerlink" title="Part1：语言基础"></a>Part1：语言基础</h2><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h4><ol><li>应该尽量将较大的数组定义为全局变量。因为局部变量会被创建在栈区中，过大（大于栈的大小）的数组会爆栈，进而导致 RE。</li><li>可以通过下标运算符 <code>[]</code> 来访问数组内元素，数组的索引（即方括号中的值）从 0 开始。以一个包含 10 个元素的数组为例，它的索引为 0 到 9，而非 1 到 10。但在 OI 中，为了使用方便，我们通常会将数组开大一点，不使用数组的第一个元素，从下标 1 开始访问数组元素。</li></ol><h4 id="2-文件读写"><a href="#2-文件读写" class="headerlink" title="2. 文件读写"></a>2. 文件读写</h4><ol><li><p><strong>freopen</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">FILE* <span class="hljs-title">freopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* mode, FILE* stream)</span></span>;<span class="hljs-comment">//stream即为stdin和stdout</span><br></code></pre></div></td></tr></table></figure><p>将指定输入输出流以指定方式重定向到文件，包含于头文件 <code>stdio.h (cstdio)</code> 中。</p><p>该函数可以在不改变代码原貌的情况下改变输入输出环境</p><p>配合<code>scanf</code>、<code>printf</code>即可直接实现文件读写</p></li><li><p><strong>fopen</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">FILE* <span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* mode)</span></span><br></code></pre></div></td></tr></table></figure><p>配合<code>fscanf</code>、<code>fprintf</code></p><p>还需要定义File指针</p></li></ol><h2 id="Part2：算法基础"><a href="#Part2：算法基础" class="headerlink" title="Part2：算法基础"></a>Part2：算法基础</h2><h4 id="1-递归要点"><a href="#1-递归要点" class="headerlink" title="1. 递归要点"></a>1. 递归要点</h4><p><strong>明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，</strong> 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。以遍历二叉树为例。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">traverse</span>(root-&gt;left);<br>  <span class="hljs-built_in">traverse</span>(root-&gt;right);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        这几行代码就足以遍历任何一棵二叉树了。对于递归函数 <code>traverse(root)</code>，只要相信给它一个根节点 <code>root</code>，它就能遍历这棵树。所以只需要把这个节点的左右节点再传给这个函数就行了。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo+github搭建个人博客并发布文章</title>
    <link href="/2021/08/30/%E4%BD%BF%E7%94%A8Hexo-github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/08/30/%E4%BD%BF%E7%94%A8Hexo-github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>具体教程自行google</p></blockquote><h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h2><p>在安装<code>nodejs</code>和<code>npm</code>时踩坑，一开始使用<code>yay</code>安装，但<code>npm</code>无法使用，一直报错缺少<code>module</code>.</p><p>解决：使用<code>nvm</code>安装，具体做法自行google</p><h2 id="2-hexo命令"><a href="#2-hexo命令" class="headerlink" title="2. hexo命令"></a>2. hexo命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs hexo">hexo init #初始化博客<br>命令简写<br>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy #部署<br><br>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令<br></code></pre></div></td></tr></table></figure><h3 id="发布新文章"><a href="#发布新文章" class="headerlink" title="发布新文章"></a>发布新文章</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo clean <span class="hljs-comment">#本来不需要这一步，但是加上总没错</span><br>$ hexo g<br>$ hexo d<br><span class="hljs-comment">#或者直接生成并部署</span><br>$ hexo g -d<br></code></pre></div></td></tr></table></figure><blockquote><p>如果看不到网页更新，尝试使用<code>Shift</code>+<code>F5</code>清空浏览器缓存后重试</p></blockquote><h3 id="关于hexo部署有时卡住的问题"><a href="#关于hexo部署有时卡住的问题" class="headerlink" title="关于hexo部署有时卡住的问题"></a>关于hexo部署有时卡住的问题</h3><p>个人认为是github的问题，让git走代理后解决</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 打开用户主目录下的.gitconfig文件，加入如下配置</span><br><span class="hljs-comment"># 注意：7891是本人的socks5端口，请以本机为准</span><br>[http]<br>        proxy = socks5://127.0.0.1:7891<br>[https]<br>        proxy = socks5://127.0.0.1:7891<br></code></pre></div></td></tr></table></figure><h2 id="3-主题配置"><a href="#3-主题配置" class="headerlink" title="3. 主题配置"></a>3. 主题配置</h2><p>本网站使用的主题为fluid,配置文档<a href="https://hexo.fluid-dev.com/docs/guide">看这里</a></p><p>其他功能定制<a href="https://www.erenship.com/posts/40222.html">看这里</a></p><h2 id="4-文章编写"><a href="#4-文章编写" class="headerlink" title="4. 文章编写"></a>4. 文章编写</h2><h3 id="4-1-Front-matter"><a href="#4-1-Front-matter" class="headerlink" title="4.1  Front-matter"></a>4.1  <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a></h3><ul><li><p>添加标签</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">tags:</span> <span class="hljs-string">a</span> <span class="hljs-comment">#添加a标签</span><br><span class="hljs-string">tags:[a,</span> <span class="hljs-string">b]</span> <span class="hljs-comment">#添加a和b两个标签</span><br></code></pre></div></td></tr></table></figure></li><li><p>为首页的文章配封面图</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br></code></pre></div></td></tr></table></figure><p>如果想统一给文章设置一个默认图片（文章不设置 <code>index_img</code> 则默认使用这张图片），可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">default_index_img:</span> <span class="hljs-string">/img/example.jpg</span><br></code></pre></div></td></tr></table></figure></li><li><p>文章页顶部大图</p><p>默认显示<strong>主题配置</strong>中的 <code>post.banner_img</code></p><p>如需要设置单个文章的 Banner，在 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter (opens new window)</a>中指定 <code>banner_img</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">banner_img：</span> <span class="hljs-string">/img/xxx.jpg</span><br></code></pre></div></td></tr></table></figure></li><li><p>参数表</p></li></ul><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>sticky</code></td><td align="left">给文章排序，100代表置顶，数字越小越靠后</td><td align="left"></td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能(boolen值)</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">自定义文章摘要</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td><td align="left"></td></tr><tr><td align="left"><code>lang</code></td><td align="left">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td><td align="left">Inherited from <code>_config.yml</code></td></tr></tbody></table><h2 id="4-2-添加评论功能"><a href="#4-2-添加评论功能" class="headerlink" title="4.2 添加评论功能"></a>4.2 添加评论功能</h2><p><a href="https://lovelijunyi.gitee.io/posts/e52c.html">详细配置</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记</title>
    <link href="/2021/08/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>推荐阅读：《鸟叔的Linux私房菜》</p></blockquote><h2 id="Part-1：-bash"><a href="#Part-1：-bash" class="headerlink" title="Part 1： bash"></a>Part 1： bash</h2><h3 id="1-压缩文件"><a href="#1-压缩文件" class="headerlink" title="1. 压缩文件"></a>1. 压缩文件</h3><p>*.zip          zip 程序压缩的文件;<br>*.gz           gzip 程序压缩的文件;#windows中的WinRaR/7Zip可解压<br>*.bz2          bzip2 程序压缩的文件;#比gzip更好<br>*.xz           xz 程序压缩的文件;#压缩比更高<br>#因为上述程序通常只能压缩一个文件，所以在压缩多个文件时非常不方便<br>#所以产生了tar这个打包程序，将多个文件打包成一个文件！<br>*.tar          tar 程序打包的数据,#并没有压缩过;<br>*.tar.gz      tar 程序打包的文件,其中并且经过 gzip 的压缩<br>*.tar.bz2      tar 程序打包的文件,其中并且经过 bzip2 的压缩<br>*.tar.xz      tar 程序打包的文件,其中并且经过 xz 的压缩</p><h4 id="1-单个文件-gz-bz2-xz"><a href="#1-单个文件-gz-bz2-xz" class="headerlink" title="(1) 单个文件: .gz   .bz2   xz"></a>(1) 单个文件: <code>.gz</code>   <code>.bz2</code>   <code>xz</code></h4><p>用法几乎相同</p><figure class="highlight diff"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-d :解压缩</span><br><span class="hljs-deletion">-c :将压缩的过程产生的数据输出到屏幕上</span><br><span class="hljs-deletion">-k :保留原本的文件</span><br><span class="hljs-deletion">-v :可以显示出原文件/压缩文件案的压缩比等信息;</span><br><span class="hljs-deletion">-# :#为数字的意思,代表压缩等级,默认是6</span><br><span class="hljs-deletion">-l :列出压缩文件的相关信息</span><br></code></pre></div></td></tr></table></figure><h4 id="2-打包-tar"><a href="#2-打包-tar" class="headerlink" title="(2) 打包:  tar"></a>(2) 打包:  <code>tar</code></h4><figure class="highlight diff"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-x :解打包或解压缩的功能,可以搭配 -C (大写) 在特定目录解开</span><br><span class="hljs-deletion">-C 目录:这个选项用在解压缩,若要在特定目录解压缩,可以使用这个选项。</span><br><span class="hljs-deletion">-f filename:-f 后面要立刻接要被处理的档名!建议 -f 单独写一个选项啰!(比较不会忘记)</span><br><br><span class="hljs-deletion">-c :建立打包文件,可搭配 -v 来察看过程中被打包的档名(filename)</span><br><span class="hljs-deletion">-t :察看打包文件的内容含有哪些档名,重点在察看『档名』就是了;</span><br><span class="hljs-deletion">-v :在压缩/解压缩的过程中,显示正在处理的文件名</span><br><br><span class="hljs-deletion">-z :透过 gzip的支持进行压缩/解压缩:此时档名最好为 *.tar.gz</span><br><span class="hljs-deletion">-j :透过 bzip2 的支持进行压缩/解压缩:此时档名最好为 *.tar.bz2</span><br><span class="hljs-deletion">-J :透过 xz的支持进行压缩/解压缩:此时档名最好为 *.tar.xz</span><br></code></pre></div></td></tr></table></figure><h4 id="3-对于tar-xz-等文件-可采用两种方法解压"><a href="#3-对于tar-xz-等文件-可采用两种方法解压" class="headerlink" title="(3) 对于tar.xz 等文件 可采用两种方法解压"></a>(3) 对于<code>tar.xz</code> 等文件 可采用两种方法解压</h4><ul><li>先将外层用xz解压方式解压,，然后里层用tar解压方式解压：</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ xz -d  ***.tar.xz<br>$ tar -xv -f  ***.tar<br></code></pre></div></td></tr></table></figure><ul><li>直接解压：</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"> $ tar -Jxv -f  ***.tar.xz  <span class="hljs-comment">#解压</span><br> $ tar -Jcv -f  ***.tar.xz    <span class="hljs-comment">#压缩 compress</span><br><span class="hljs-comment">#对于tar.gz : 将J改为z</span><br><span class="hljs-comment">#对于tar.bz2: 将J改为j</span><br></code></pre></div></td></tr></table></figure><h3 id="2-使用安装包"><a href="#2-使用安装包" class="headerlink" title="2. 使用安装包"></a>2. 使用安装包</h3><h4 id="2-1-Ubuntu及类似环境下"><a href="#2-1-Ubuntu及类似环境下" class="headerlink" title="2.1 Ubuntu及类似环境下"></a>2.1 Ubuntu及类似环境下</h4><h5 id="1-deb"><a href="#1-deb" class="headerlink" title="(1) deb"></a>(1) deb</h5><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo dpkg -i xxxx.deb<br><span class="hljs-comment">#对于官⽹已经提供了 Ubuntu 版本 .deb 安装⽂件的，可在官⽹下载 .deb 安装⽂件后，执⾏下⾯的命令安装</span><br>$ sudo apt install ./&lt;file&gt;.deb<br></code></pre></div></td></tr></table></figure><h5 id="2-rmp"><a href="#2-rmp" class="headerlink" title="(2) rmp"></a>(2) rmp</h5><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将.rpm 包转换为.deb 包（当前⽬录下会⽣成⼀个 deb 安装包)</span><br>sudo alien xxxx.rpm<br><span class="hljs-comment"># 安装</span><br>sudo dpkg -i xxxx.deb<br></code></pre></div></td></tr></table></figure><h4 id="2-2-Manjaro"><a href="#2-2-Manjaro" class="headerlink" title="2.2 Manjaro"></a>2.2 Manjaro</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ debtap xxx.deb <br><span class="hljs-comment"># manjaro需要先使用debtap工具将deb包转换为arch软件包</span><br><span class="hljs-comment"># 可使用-q跳过问题</span><br>$ sudo pacman -U xxx.tar.xx <br><span class="hljs-comment">#然后使用pacman进行安装即可</span><br></code></pre></div></td></tr></table></figure><h3 id="3-有用的指令"><a href="#3-有用的指令" class="headerlink" title="3. 有用的指令"></a>3. 有用的指令</h3><h4 id="（1）alias"><a href="#（1）alias" class="headerlink" title="（1）alias"></a>（1）alias</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">alias</span> lm=<span class="hljs-string">&#x27;ls -al&#x27;</span>  <span class="hljs-comment">#表示用lm代表ls -al$ unalias xxx  #取消# 可以将alias命令加入~/.bashrc ~/.zshrc文件中，永久生效，使用source ～/.xxx更新设置</span><br></code></pre></div></td></tr></table></figure><h4 id="（2）history"><a href="#（2）history" class="headerlink" title="（2）history"></a>（2）history</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">history</span> <span class="hljs-comment">#显示历史命令$ !5 # 执行第5个命令$ !! # 执行上一个命令$ !xx#执行以xx开头的命令</span><br></code></pre></div></td></tr></table></figure><h3 id="4-shell快捷键"><a href="#4-shell快捷键" class="headerlink" title="4. shell快捷键"></a>4. shell快捷键</h3><ul><li><p>移动光标：</p><ul><li><p><code>ctrl</code> + <code>a</code> 最前面</p></li><li><p><code>ctrl</code> + <code>e</code> 最后面</p></li></ul></li><li><p>删除：</p><ul><li><code>ctrl</code> + <code>u</code> 从光标处向前删除</li></ul></li><li><p><code>ctrl</code> + <code>k</code> 向后</p></li></ul><h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h3><ul><li><p>显示变量：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;PATH&#125;</span><span class="hljs-comment"># 变量为大写字母</span><br></code></pre></div></td></tr></table></figure></li><li><p>变量的设定</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1.设定格式：变量名=变量内容$ myname=cwh<span class="hljs-comment">#注意:等号两边不能接空格,若变量内容有空格,使用单或双引号将内容括起来2.还需要其他额外的指令所提供的信息时,可以使用反单引号『`指令`』或 『$(指令)』。如：取得核心版本号：$ version=$(uname -r)3.增加变量：变量名=$&#123;变量名&#125;xxx$ PATH=$&#123;PATH&#125;:/home/bin#因为PATH变量中目录与目录中间以冒号分隔$ name=$&#123;name&#125;yes #在name变量后加上yes4.若该变量需要在其他子程序执行,则需要以 export :$ export PATH5.取消变量：unset 变量名</span><br></code></pre></div></td></tr></table></figure><ul><li>将某一目录加入PATH：(以下方法按效力和作用域递增)</li></ul><ol><li><p>直接修改<code>$PATH</code>值：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span> //查看当前PATH的配置路径$ <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/xxx/xxx //将需配置路径加入<span class="hljs-variable">$PATH</span> 等号两边一定不能有空格<br></code></pre></div></td></tr></table></figure><p> 生效方法：立即生效</p><p> 有效期限：<code>临时改变</code>，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置</p><p> 用户局限：仅对当前用户</p></li><li><p>修改<code>.bashrc</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ code /.bashrc<span class="hljs-comment">#在最后一行添上：$ export PATH=$PATH:/xxx/xxx  </span><br></code></pre></div></td></tr></table></figure><p>生效方法：</p><ul><li><p>关闭当前终端窗口，重新打开一个新终端窗口就能生效</p></li><li><p>输入“source .bashrc”命令，立即生效</p></li></ul><p>有效期限：永久有效</p><p>用户局限：仅对当前用户</p></li><li><p>修改<code>profile</code>文件或<code>environment</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ code /etc/profile <span class="hljs-comment">#在最后一行添上：$ export PATH=$PATH:/xxx/xxx$ code /etc/environment#在 PATH=/········· 中加入“:/xxx/xxx”#个人认为修改profile文件更合适，因为能清晰地看到哪些变量是自己加上的，哪些是系统原有的</span><br></code></pre></div></td></tr></table></figure><p> 生效方法：系统重启</p><p> 有效期限：<code>永久有效</code></p><p> 用户局限：<code>对所有用户</code></p></li></ol></li><li><p>特殊变量: ?</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> $? 显示指令回传的执行后代码<span class="hljs-comment">#指令正常，返回0#执行错误，返回非零</span><br></code></pre></div></td></tr></table></figure></li><li><p>export：引入变量 </p><p>子程序仅会继承父程序的环境变量, 子程序『不会』继承父程序的『自定义变量』。使用export可以将自定义变量变为环境变量。</p></li><li><p>locale：显示语系   发生乱码，设定系统语系编码即可。</p></li></ul><h2 id="Part2-：some-tips"><a href="#Part2-：some-tips" class="headerlink" title="Part2 ：some tips"></a>Part2 ：some tips</h2><ol><li><strong>修改开机默认引导</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /etc/default$ sudo gedit grub  修改GRUB_DEFAULT的值，ubuntu为0，windows为2$ sudo update-grub  //更新配置文件<br></code></pre></div></td></tr></table></figure><ol start="2"><li><strong>关闭sudo密码</strong></li></ol><p>终端输入命令sudo visudo，打开 visudo；</p><p>找到 %sudo ALL=(ALL:ALL) ALL 这一行修改为%sudo ALL=(ALL:ALL) NOPASSWD:ALL<br>有安全风险，请谨慎使用</p><ol start="3"><li> <strong>kill 进程</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ps -x$ <span class="hljs-built_in">kill</span> -9 进程号<br></code></pre></div></td></tr></table></figure><ol start="4"><li><strong>wine字体太小</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ env WINEPREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.deepinwine/软件名&quot;</span> winecfg<br></code></pre></div></td></tr></table></figure><ol start="5"><li><strong>换镜像</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo pacman-mirrors -i -c China -m rank<br></code></pre></div></td></tr></table></figure><ol start="6"><li><strong>使用yay时报错</strong></li></ol><ul><li><p>错误：无法从 mirrors.aliyun.com : The requested URL returned error: 404 获取文件</p><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo pacman-mirrors -i $ sudo pacman -Sy<br></code></pre></div></td></tr></table></figure></li></ul><ol start="7"><li><p><strong>majaro安装node和npm</strong> </p><p>踩坑！不要使用yay！使用nvm</p></li></ol><h2 id="Part3：Linux基本知识"><a href="#Part3：Linux基本知识" class="headerlink" title="Part3：Linux基本知识"></a>Part3：Linux基本知识</h2><h3 id="1-bin文件夹"><a href="#1-bin文件夹" class="headerlink" title="1. bin文件夹"></a>1. bin文件夹</h3><h4 id="（1）存放脚本"><a href="#（1）存放脚本" class="headerlink" title="（1）存放脚本"></a>（1）存放脚本</h4><p><code>~/bin</code>：个人用户的 script<br><code>/usr/local/bin</code>：存放所有用户都可以使用的 script<br><code>/usr/local/sbin</code>： 存放管理员的 script</p><h3 id="（2）存放其他文件"><a href="#（2）存放其他文件" class="headerlink" title="（2）存放其他文件"></a>（2）存放其他文件</h3><p><code>/usr/local/</code>：大部分是本地用户软件<br><code>/bin或/usr/bin</code>：不是用来放软件的，是用来存放 Linux distribution 专用文件的。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
