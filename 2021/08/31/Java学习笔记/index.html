

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="大二下Java课程笔记">
  <meta name="author" content="Henry">
  <meta name="keywords" content="">
  <meta name="description" content="大二下Java课程笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习笔记">
<meta property="og:url" content="http://example.com/2021/08/31/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Henry Chi&#39;s Blog">
<meta property="og:description" content="大二下Java课程笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/池炜恒/AppData/Roaming/Typora/typora-user-images/image-20210305163509008.png">
<meta property="article:published_time" content="2021-08-31T12:54:08.000Z">
<meta property="article:modified_time" content="2021-09-27T15:59:37.297Z">
<meta property="article:author" content="Henry">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:/Users/池炜恒/AppData/Roaming/Typora/typora-user-images/image-20210305163509008.png">
  
  <title>Java学习笔记 - Henry Chi&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"APjDJRCEtwETk2JqAx6lmCiS-gzGzoHsz","app_key":"NBAOoEsFe7YFr915DSzxn3BD","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Henry Chi&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/sea.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java学习笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-31 20:54" pubdate>
        2021年8月31日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      31 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java学习笔记</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年9月27日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h2 id="Part-1：语法"><a href="#Part-1：语法" class="headerlink" title="Part 1：语法"></a>Part 1：语法</h2><h3 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1. 关键字"></a>1. 关键字</h3><h4 id="lt-1-gt-static关键字"><a href="#lt-1-gt-static关键字" class="headerlink" title="&lt;1&gt; static关键字"></a>&lt;1&gt; static关键字</h4><h5 id="1-static修饰方法："><a href="#1-static修饰方法：" class="headerlink" title="(1) static修饰方法："></a>(1) static修饰方法：</h5><p>分为静态方法和非静态方法：</p>
<ul>
<li><p><strong>静态方法</strong>是在类中使用<code>staitc</code>修饰的方法，在类定义的时候已经被装载和分配。</p>
</li>
<li><p><strong>非静态方法</strong>是不加<code>static</code>关键字的方法，在类定义时没有占用内存，非静态方法只有在类被实例化成对象时，对象调用该方法才被分配内存.</p>
</li>
</ul>
<blockquote>
<p>注意: <strong>静态方法只能访问静态成员</strong>，<strong>实例方法可以访问静态和实例成员</strong>。</p>
<p>因为实例成员和变量属于某个对象的, 而静态方法在使用时,不一定存在对象, 所以不允许访问.</p>
</blockquote>
<p>调用静态方法可以<strong>无需创建对象</strong> </p>
<p>而调用实例方法则<strong>需要创建对象</strong></p>
<h5 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h5><ul>
<li>所有静态方法: <code> 类名.方法名</code></li>
<li>实例方法: <ul>
<li>当前类: <code>this.方法名 </code>(this可省略)</li>
<li>其他类:<code>对象名.方法名</code><ul>
<li>子类调用父类: <code>super.方法名</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-static修饰变量"><a href="#2-static修饰变量" class="headerlink" title="(2)static修饰变量"></a>(2)static修饰变量</h5><p>也称为<strong>静态变量</strong>。</p>
<ul>
<li><p>静态变量<strong>被所有对象共享</strong>，内存中只有<strong>一个副本</strong>，在<strong>类初次加载的时候</strong>才会初始化</p>
</li>
<li><p>非静态变量是<strong>对象所拥有的</strong>，在<strong>创建对象的时候</strong>被初始化，存在多个副本，各个对象拥有的副本互不影响</p>
</li>
<li><p>static不允许用来修饰局部变量</p>
</li>
</ul>
<blockquote>
<p>与C/C++中的static不同，Java中的static关键字<strong>不会影响到变量或者方法的作用域</strong></p>
<p>静态成员变量虽然独立于对象，但是<strong>不代表不可以通过对象去访问</strong>，所有的静态方法和静态变量<strong>都可以通过对象访问</strong>（只要访问权限足够）。</p>
</blockquote>
<h4 id="lt-2-gt-final-关键字"><a href="#lt-2-gt-final-关键字" class="headerlink" title="&lt;2&gt; final 关键字"></a>&lt;2&gt; final 关键字</h4><ul>
<li><p>声明类: 表示该类<strong>不能继承</strong>，即最终类；</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<span class="hljs-comment">//类体&#125;</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>声明方法: 表示该方法<strong>不能被子类重写</strong>, 即最终方法</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">修饰符(<span class="hljs-keyword">public</span>/<span class="hljs-keyword">protected</span>/<span class="hljs-keyword">default</span>/<span class="hljs-keyword">private</span>) <span class="hljs-keyword">final</span> 返回值类型 方法名()&#123;<span class="hljs-comment">//方法体&#125;</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>声明变量: 表示该变量不可修改, 即最终变量</p>
</li>
</ul>
<h4 id="lt-3-gt-this-关键字"><a href="#lt-3-gt-this-关键字" class="headerlink" title="&lt;3&gt;this 关键字"></a>&lt;3&gt;this 关键字</h4><ul>
<li><p><code>this.属性名称</code>: 访问本类的成员变量, 用来区分成员变量和局部变量</p>
</li>
<li><p><code>this.方法名称</code>: 访问本类的成员方法</p>
<ul>
<li><p>特例: <code>this(参数)</code>: 访问本类的构造方法,但注意:</p>
<blockquote>
<p>1.不能在普通方法中使用, 只能写在构造方法中</p>
<ol start="2">
<li>必须是构造方法的第一条语句</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="2-修饰符"><a href="#2-修饰符" class="headerlink" title="2.修饰符"></a>2.修饰符</h3><p>public &gt; protected &gt; package &gt; private</p>
<h4 id="lt-1-gt-protected修饰符"><a href="#lt-1-gt-protected修饰符" class="headerlink" title="&lt;1&gt;protected修饰符"></a>&lt;1&gt;protected修饰符</h4><blockquote>
<p>被protected 修饰的成员对于<strong>本包和其子类</strong>可见</p>
</blockquote>
<p><strong>详解</strong>: protected的可见性在于:</p>
<ul>
<li>父类的 protected 成员是包内可见的，并且对子类可见；</li>
<li>若子类与父类不在同一包中，那么在子类中，子类实例<strong>可以访问</strong>其从父类<strong>继承而来</strong>的protected成员（子类的），而<strong>不能访问</strong>父类实例的protected成员（父类的）。</li>
</ul>
<p>例子: 第9章作业题</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> homework.ch9.p1;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> homework.ch9.p2;<br><span class="hljs-keyword">import</span> homework.ch9.p1.A;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> A().j = <span class="hljs-number">10</span>;<span class="hljs-comment">//不同包中,父类的protected变量不可访问</span><br>        <span class="hljs-keyword">this</span>.j = <span class="hljs-number">10</span>;<span class="hljs-comment">//指当前类B的继承来的protected变量,可以访问</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="3-可变参数"><a href="#3-可变参数" class="headerlink" title="3.可变参数"></a>3.可变参数</h3><p>可变参数用类型<code>...</code>定义，可变参数<strong>相当于数组类型</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Group</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String[] names;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNames</span><span class="hljs-params">(String... names)</span></span>&#123;<br>    	<span class="hljs-keyword">this</span>.names = names;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h3><h4 id="4-1-向上转型"><a href="#4-1-向上转型" class="headerlink" title="4.1 向上转型"></a>4.1 向上转型</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Person p= <span class="hljs-keyword">new</span> Student();<span class="hljs-comment">//Student是Person的子类</span><br>p是一个引用类型为Person，实际类型为Student的变量<br></code></pre></div></td></tr></table></figure>

<p>​        这种指向是允许的，因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。所以说，<code>Person</code>类型的变量<code>p</code>，指向<code>Student</code>类型的实例，对<code>p</code>做任何<code>Person</code>的操作, <code>Student</code>实例都能实现。</p>
<p>​        变量p指向的还是一个<code>Student</code>类型的实例对象，只是p的操作被局限在<code>Person</code> 所具有的内容中。</p>
<blockquote>
<p>与之相反的就是向下转型: 把父类类型强制转型为子类类型</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Student s=<span class="hljs-keyword">new</span> Person();<br></code></pre></div></td></tr></table></figure>

<p><strong>很可能会失败!</strong> 因为s为student类型的变量, 而<code>Person</code>很可能没有<code>Student</code>的部分内容。</p>
</blockquote>
<ul>
<li>从现实的角度来理解：一个Student，说他是个Person那肯定没错；但一个Person不一定是Student</li>
</ul>
<h4 id="4-2-多态"><a href="#4-2-多态" class="headerlink" title="4.2 多态"></a>4.2 多态</h4><p>由4.1中的例子，对于变量p，其实际类型为Student，而引用类型为Person，那么p.run()调用的是谁的方法？</p>
<p>答案是：<code>Student</code></p>
<p>这说明：Java的<em><strong>实例方法</strong></em>调用是<strong>基于运行时的实际类型</strong>的动态调用，<strong>而非变量的声明类型</strong>。　　　　（１）</p>
<p>这就是<strong>多态</strong></p>
<blockquote>
<p>多态的特性就是，<strong>运行期才能动态决定</strong>调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法</p>
<p>多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p>
</blockquote>
<ul>
<li>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用.</li>
</ul>
<h5 id="注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）"><a href="#注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）" class="headerlink" title="注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）"></a>注意！只有实例方法具有多态性，静态方法和成员变量没有多态性，需要根据声明类型来决定调用对象。（和１进行对比）</h5><h4 id="4-3-抽象类"><a href="#4-3-抽象类" class="headerlink" title="4.3 抽象类"></a>4.3 抽象类</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类。</p>
<p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。</p>
<p>即<code>Person</code>的子类必须覆写<code>run()</code>方法。</p>
<ul>
<li>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Person s = <span class="hljs-keyword">new</span> Student();<br>Person t = <span class="hljs-keyword">new</span> Teacher();<br></code></pre></div></td></tr></table></figure>

<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型。这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p>
<h4 id="4-4-接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）"><a href="#4-4-接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）" class="headerlink" title="4.4 接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）"></a>4.4 接口（没有字段、只有抽象方法和default方法的抽象类就改写为接口interface）</h4><h5 id="4-4-1-定义"><a href="#4-4-1-定义" class="headerlink" title="4.4.1 定义"></a>4.4.1 定义</h5><p>​        所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
<p>​        当一个<code>class</code>去实现一个接口时, 使用<code>implement</code>关键字</p>
<p>​        与继承不同, 一个类只能继承自一个父类, 但一个类却能实现<strong>多个接口</strong></p>
<h5 id="4-4-2-接口继承"><a href="#4-4-2-接口继承" class="headerlink" title="4.4.2 接口继承"></a>4.4.2 接口继承</h5><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。</p>
<h5 id="4-4-3-default方法"><a href="#4-4-3-default方法" class="headerlink" title="4.4.3 default方法"></a>4.4.3 default方法</h5><p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(getName() + <span class="hljs-string">&quot; run&quot;</span>);    &#125;&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="５-异常"><a href="#５-异常" class="headerlink" title="５.异常"></a>５.异常</h3><h4 id="5-1-抛出异常"><a href="#5-1-抛出异常" class="headerlink" title="5.1 抛出异常"></a>5.1 抛出异常</h4><p>抛出异常分两步：</p>
<ol>
<li>创建某个<code>Exception</code>的实例；</li>
<li>用<code>throw</code>语句抛出。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s==<span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    &#125;&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>JVM先执行<code>finally</code>中的语句, 再抛出异常; 但若<code>finally</code>中也抛出了异常, catch抛出的异常会被屏蔽。绝大多数情况下，在<code>finally</code>中不要抛出异常。若真有需求，使用<code>Throwable.addSuppressed()</code>, 具体自行百度.</li>
</ul>
<h4 id="5-2捕获异常"><a href="#5-2捕获异常" class="headerlink" title="5.2捕获异常"></a>5.2捕获异常</h4><p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明.</p>
<ul>
<li><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类。</p>
<ul>
<li>使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<strong>不再</strong>继续匹配。即：多个<code>catch</code>语句<strong>只有一个能被执行</strong>。所以顺序很重要，要把子类放前面。</li>
<li><code>try ... catch</code>还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。</li>
<li>catch语句和finally语句至少得有一个，可以理解为两个同级的出口</li>
</ul>
</li>
<li><p>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。</p>
<blockquote>
<p>某个方法抛出了异常时，若当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try ... catch</code>被捕获为止</p>
</blockquote>
<ul>
<li>调用方在调用这些方法的时候，必须强制捕获这些异常，否则编译器会报错。</li>
<li>我们也可以不捕获它，而是在调用了这些方法的方法定义处加上<code>throws xxx</code></li>
</ul>
</li>
<li><p>可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在<strong>更高的调用层捕获</strong>。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会。</p>
<p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>。</p>
<blockquote>
<p>因为<code>main()</code>方法声明了可能抛出<code>Exception</code>，也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p>
</blockquote>
</li>
<li><p>所有异常都可以<strong>调用<code>printStackTrace()</code>方法打印异常栈</strong>，这是一个简单有用的快速打印异常的方法。</p>
</li>
</ul>
<h4 id="5-3-最常见的NullPointerException"><a href="#5-3-最常见的NullPointerException" class="headerlink" title="5.3 最常见的NullPointerException"></a>5.3 最常见的NullPointerException</h4><p>好的编码习惯可以极大地降低<code>NullPointerException</code>的产生:</p>
<ol>
<li>成员变量在定义时初始化：</li>
</ol>
<figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name = <span class="hljs-string">&quot;&quot;</span>;&#125;<br></code></pre></div></td></tr></table></figure>

<ol start="2">
<li><p>使用空字符串<code>&quot;&quot;</code>而不是默认的<code>null</code>可避免很多<code>NullPointerException</code>.</p>
</li>
<li><p>返回空字符串<code>&quot;&quot;</code>、空数组而不是<code>null</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">public <span class="hljs-keyword">String</span>[] readLinesFromFile(<span class="hljs-keyword">String</span> <span class="hljs-keyword">file</span>) &#123;    <span class="hljs-keyword">if</span> (getFileSize(<span class="hljs-keyword">file</span>) == <span class="hljs-number">0</span>) &#123;        // 返回空数组而不是null:        <span class="hljs-keyword">return</span> new <span class="hljs-keyword">String</span>[<span class="hljs-number">0</span>];    &#125;    ...&#125;<br></code></pre></div></td></tr></table></figure>

<p>这样可以使得调用方无需检查结果是否为<code>null</code>。</p>
</li>
</ol>
<blockquote>
<p> 如果调用方一定要根据<code>null</code>判断，比如返回<code>null</code>表示文件不存在，那么考虑返回<code>Optional&lt;T&gt;</code></p>
</blockquote>
<p><strong>定位NullPointerException</strong></p>
<p>可以启用Java 14的增强异常信息来查看<code>NullPointerException</code>的详细错误信息。</p>
<p>这种增强的<code>NullPointerException</code>详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个<code>-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java -XX:+ShowCodeDetailsInExceptionMessages Main.java<br></code></pre></div></td></tr></table></figure>

<h3 id="6-I-O"><a href="#6-I-O" class="headerlink" title="6.I/O"></a>6.I/O</h3><p>Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符</p>
<p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p>
<figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl">// 假设当前目录是C:\DocsFile f1 = new File(<span class="hljs-string">&quot;sub\\javac&quot;</span>); <span class="hljs-regexp">//</span> 绝对路径是C:\Docs\<span class="hljs-function"><span class="hljs-keyword">sub</span>\<span class="hljs-title">javacFile</span> <span class="hljs-title">f3</span> = <span class="hljs-title">new</span> <span class="hljs-title">File</span></span>(&quot;.\\<span class="hljs-keyword">sub</span>\\javac&quot;); // 绝对路径是C:\Docs\<span class="hljs-function"><span class="hljs-keyword">sub</span>\<span class="hljs-title">javac</span></span><br></code></pre></div></td></tr></table></figure>

<p>可以用<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p>
<h3 id="7-覆写clone（）"><a href="#7-覆写clone（）" class="headerlink" title="7.覆写clone（）"></a>7.覆写clone（）</h3><h4 id="7-1-List深拷贝"><a href="#7-1-List深拷贝" class="headerlink" title="7.1 List深拷贝"></a>7.1 List深拷贝</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/DeMonliuhui/article/details/54572908">看这里</a></p>
<h3 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8. 泛型"></a>8. 泛型</h3><h4 id="8-1-使用通配符"><a href="#8-1-使用通配符" class="headerlink" title="8.1 使用通配符"></a>8.1 使用通配符</h4><h5 id="1-extends"><a href="#1-extends" class="headerlink" title="1. extends"></a>1. extends</h5><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p>
<ul>
<li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li>
<li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li>
</ul>
<p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p>
<h5 id="2-super"><a href="#2-super" class="headerlink" title="2. super"></a>2. super</h5><p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>
<ul>
<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>
<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li>
</ul>
<p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p>
<p>换句话说，使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p>
<h5 id="3-PECS-原则"><a href="#3-PECS-原则" class="headerlink" title="3. PECS 原则"></a>3. PECS 原则</h5><p>ECS原则：Producer Extends Consumer Super。</p>
<p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p>
<h4 id="8-2-擦拭法"><a href="#8-2-擦拭法" class="headerlink" title="8.2 擦拭法"></a>8.2 擦拭法</h4><p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p>
<ul>
<li>不能是基本类型，例如：<code>int</code>；</li>
<li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</li>
<li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li>
<li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li>
</ul>
<h3 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="# 零碎知识点"></a># 零碎知识点</h3><h5 id="（1）既对字段进行初始化，又在构造方法中对字段进行初始化："><a href="#（1）既对字段进行初始化，又在构造方法中对字段进行初始化：" class="headerlink" title="（1）既对字段进行初始化，又在构造方法中对字段进行初始化："></a>（1）既对字段进行初始化，又在构造方法中对字段进行初始化：</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;Unamed&quot;</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age =<span class="hljs-number">10</span>;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;            <span class="hljs-keyword">this</span>.name=name;            <span class="hljs-keyword">this</span>.age=age;        &#125;        &#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>Q:</strong> 当我们创建对象的时候，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>得到的对象实例，字段的初始值是啥？</p>
<p>**A: **在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p>
<ol>
<li><p>先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；</p>
</li>
<li><p>执行构造方法的代码进行初始化。</p>
</li>
</ol>
<p>因此，构造方法的代码由于后运行，所以，new Person(“Xiao Ming”, 12)的字段值最终由构造方法的代码确定。</p>
<h5 id="（2）增强for循环（for-each）"><a href="#（2）增强for循环（for-each）" class="headerlink" title="（2）增强for循环（for each）"></a>（2）增强for循环（for each）</h5><p>增强for循环不会修改原数组的值</p>
<blockquote>
<p>因为每一次loop你只是获得了当前元素的值，却没有获得当前元素在数组中的对象句柄。这样就无法直接操作对应的句柄。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] s=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v: s)&#123;    ++v;&#125;<span class="hljs-comment">//s数组的值不会变化!</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>想遍历数组并只想获得元素值的时候才用for-each</p>
<p>其他的时候比如想修改数组，或者想获得index的时候就别用for-each</p>
</blockquote>
<h5 id="（3）字符串相加"><a href="#（3）字符串相加" class="headerlink" title="（3）字符串相加"></a>（3）字符串相加</h5><ul>
<li><p><strong>都是静态字符串</strong>的结果会添加到字符串池;</p>
</li>
<li><p>如果其中<strong>含有变量</strong>则<strong>不会</strong>进入字符串池中。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;Hello&quot;</span>;String b = a+<span class="hljs-string">&quot;world&quot;</span>;    <span class="hljs-comment">//含有变量a，不会进入String c = &quot;Hello&quot;+&quot; world&quot;;//进入常量池String d = &quot;Hello world&quot;;//c==d, 但b不等于d//注意，final修饰的字符串当作静态字符串来看，不是变量final String s1=&quot;Hello&quot;;final String s2=&quot; world&quot;;s1+s2==d;//结果为ture</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。</p>
</li>
</ul>
<h2 id="Part-2：Tips"><a href="#Part-2：Tips" class="headerlink" title="Part 2：Tips"></a>Part 2：Tips</h2><h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h4><blockquote>
<p>多行注释和单行注释与c相同 </p>
</blockquote>
<h5 id="文档注释-可以使用javadoc提取注释-自动形成API文档"><a href="#文档注释-可以使用javadoc提取注释-自动形成API文档" class="headerlink" title="文档注释: 可以使用javadoc提取注释, 自动形成API文档"></a>文档注释: 可以使用<code>javadoc</code>提取注释, 自动形成API文档</h5><p>点击<code>Tools</code> -&gt; <code>Generate JavaDoc</code> 选择output 文件夹为doc目录(需要新建)</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">特点:第一个斜杠后两个*注释对象:紧跟其后的代码块<span class="hljs-comment">/**注释内容   注释内容*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>&#123;    xxx&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>形成写文档注释的习惯</p>
</blockquote>
<h4 id="2-注意import"><a href="#2-注意import" class="headerlink" title="2. 注意import"></a>2. 注意import</h4><h2 id="Part-3：IDE及命令行"><a href="#Part-3：IDE及命令行" class="headerlink" title="Part 3：IDE及命令行"></a>Part 3：IDE及命令行</h2><h3 id="一、Idea的使用"><a href="#一、Idea的使用" class="headerlink" title="一、Idea的使用"></a>一、Idea的使用</h3><h4 id="1-基本流程"><a href="#1-基本流程" class="headerlink" title="1. 基本流程"></a>1. 基本流程</h4><p><code>new project</code> -&gt; <code>在src下创建一个package</code> -&gt; <code>在package下创建class</code>  </p>
<blockquote>
<p>在项目文件夹下创建一个bin目录, 用于存放编译成功的.class文件</p>
<p>创建后需要到<code>File</code> -&gt; <code>Project Structure</code> 中修改<code>Project compiler output</code></p>
</blockquote>
<h4 id="2-奇技淫巧"><a href="#2-奇技淫巧" class="headerlink" title="2. 奇技淫巧"></a>2. 奇技淫巧</h4><h5 id="2-1-生成弹出对话框"><a href="#2-1-生成弹出对话框" class="headerlink" title="2.1 生成弹出对话框"></a>2.1 生成弹出对话框</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.swing.JOp<br></code></pre></div></td></tr></table></figure>



<h3 id="二、命令行的使用"><a href="#二、命令行的使用" class="headerlink" title="二、命令行的使用"></a>二、命令行的使用</h3><h4 id="1-注意"><a href="#1-注意" class="headerlink" title="1. 注意"></a>1. 注意</h4><ul>
<li><p>在使用<code>javac</code> 编译时, shell目前所处的目录应为package的顶级目录,即<code>src</code>目录</p>
<p>例如：package名为 homework.ch1, 则在该目录系统中, class文件夹就相当于 src文件夹</p>
<ul>
<li>文件的目录结构如下：<img src="C:\Users\池炜恒\AppData\Roaming\Typora\typora-user-images\image-20210305163509008.png" srcset="/img/loading.gif" lazyload alt="image-20210305163509008"></li>
</ul>
<p>​        那么 shell所处的目录应为：./chapter1/class</p>
<p>​    </p>
<ul>
<li><p>运行Welcome.class时, 类名要打全! 要带上package名,这样jvm才找得到</p>
<blockquote>
<p>这是因为JVM只看完整类名 , 编译器编译出的class文件也只使用完整类名</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$  java homework.ch1.Welcome<br></code></pre></div></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Part-4-：作业知识点"><a href="#Part-4-：作业知识点" class="headerlink" title="Part 4 ：作业知识点"></a>Part 4 ：作业知识点</h2><h4 id="4-1-chapter-2-3"><a href="#4-1-chapter-2-3" class="headerlink" title="4.1 chapter 2-3"></a>4.1 chapter 2-3</h4><ol>
<li><p>switch 语句的判断条件expression的计算结果只能是__不大于int__的类型</p>
</li>
<li><p>Java源程序经过编译后生成被称为 <strong>字节码</strong> 的特殊机器语言码</p>
</li>
<li><p>&amp;&amp;为条件逻辑运算符，&amp;为无条件逻辑运算符，有区别</p>
</li>
<li><p>Java中所有的方法都__必须在类内定义__</p>
</li>
<li><p>一些规则:</p>
<ul>
<li><p>一个源文件中__只能有一个public类__。</p>
</li>
<li><p>一个源文件__可以有多个非public类__。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span></span>&#123; <span class="hljs-comment">//只能有一个public class,且该文件必须命名为C1.java    ...&#125;class C2 &#123;&#125;final class C3&#123;&#125;...//可以有任意个 class</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>源文件的名称应该__和public类的类名保持一致__。例如：源文件中public类的类名是Employee，那么源文件应该命名Employee.java。</p>
</li>
<li><p>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</p>
</li>
<li><p>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</p>
</li>
</ul>
</li>
<li><p>java标识符__严格区分大小写__, __不能__以数字开头</p>
</li>
</ol>
<h4 id="4-2-Chapter-4-5"><a href="#4-2-Chapter-4-5" class="headerlink" title="4.2 Chapter 4-5"></a>4.2 Chapter 4-5</h4><ol>
<li><p>字符串函数：</p>
<ul>
<li><p>indexof(): 返回某个字符串在字符串中<strong>首次出现</strong>的位置，从0开始计数（用数组下标理解）</p>
</li>
<li><p>lastIndexof(): <strong>最后一次</strong>出现的位置</p>
<ul>
<li><p><strong>public int lastIndexOf(int ch):</strong> 返回指定字符在此字符串中<strong>最后一次</strong>出现处的索引，如果此字符串中没有这样的字符，则<strong>返回 -1</strong>。</p>
</li>
<li><p><strong>public int lastIndexOf(int ch, int fromIndex):</strong> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行<strong>反向搜索</strong>，如果此字符串中没有这样的字符，则返回 -1。</p>
<blockquote>
<p>fromIndex: 开始搜索的索引位置</p>
</blockquote>
</li>
</ul>
</li>
<li><p>substring(): 用于截取字符串的一部分，返回新字符串</p>
<ul>
<li>substring(0,11): 表示0-<strong>10</strong>的子串</li>
<li>substring(11): 表示从11-末尾的子串</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意: 字符串函数中,若参数为(int, int), 如substring(0,11),则一般为数组下标0 - <strong>(11-1)<strong>的字符的范围, 即</strong>不含后一个参数</strong>的范围</p>
<p>如何理解? </p>
<p>非常容易。可以把这两个数字看成地址，地址0-1之间的内存储存第一个字符，那么显然0-11的地址范围不包括位置11上的字符</p>
</blockquote>
<ul>
<li>int length(): 返回字符串的长度，（字符数）</li>
<li>concat(String s): 将s连接到当前字符串上</li>
</ul>
</li>
</ol>
<ul>
<li>清空StringBuffer s：s.delete(0,length()-1);  或者  s.setLength(0);</li>
</ul>
<h4 id="4-3-Chapter-6-7"><a href="#4-3-Chapter-6-7" class="headerlink" title="4.3 Chapter 6-7"></a>4.3 Chapter 6-7</h4><ol>
<li><p><code>length</code>和<code>length()</code>是不同的</p>
<ol>
<li>length用于求<strong>数组</strong>的长度, 即数组元素个数 </li>
<li>length()用于求<strong>字符串对象</strong>的长度</li>
</ol>
</li>
<li><p>数组声明和初始化语句</p>
<ul>
<li><p><code>int a[]=null</code>等效于<code>int[] b=&#123;&#125;</code>;</p>
</li>
<li><p><code>int[] c=&#123;1,2,3,4&#125; </code>等效于<code>int[] c</code>= new <strong>int[]</strong>{1,2,3,4} </p>
<p><strong>注意：</strong>此处<code>new int[]</code>的<code>[]</code>不能少！</p>
<p>int[ ] c=new int{1,2,3,4} 错误!</p>
</li>
<li><p>int[ ] d[ ]=new int[5][ ]</p>
</li>
</ul>
</li>
<li><p>判断：局部变量在使用前必须通过初始化或者赋值语句显式地给一个值。( √ )</p>
<p>原因：<strong>局部变量必须初始化</strong>,而类的成员变量有默认值0,不用初始化</p>
<blockquote>
<p>注意: 成员变量和局部变量<strong>不同</strong>! 区别如下: </p>
</blockquote>
<p><strong>1.在类中的位置不同</strong></p>
<p>成员变量: 在类中, 方法外</p>
<p>局部变量: 在方法中, 代码块, 或形参列表中</p>
<p><strong>2.在内存中的位置不同</strong></p>
<p>成员变量: 堆中(与<strong>对象</strong>共存亡)</p>
<p>局部变量: 栈中(与<strong>方法调用或代码块的执行</strong>共存亡)</p>
<p><strong>3.初始值</strong></p>
<p>成员变量: 有默认初始值</p>
<p>局部变量: 没有默认初始值, 使用前<strong>必须初始化</strong></p>
</li>
<li><p>仅返回类型不同的方法不是合法的重载</p>
<blockquote>
<p><strong>方法重载</strong>：指方法名称相同，但<strong>形参列表不同</strong>的方法</p>
</blockquote>
</li>
</ol>
<h4 id="4-4-Chapter-9"><a href="#4-4-Chapter-9" class="headerlink" title="4.4 Chapter 9"></a>4.4 Chapter 9</h4><ol>
<li><p>静态方法不能访问实例变量</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;    m =<span class="hljs-number">1</span>;<span class="hljs-comment">//会报错，因为fun()为静态方法&#125; //将m改为static即可</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>private权限</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AA</span></span>&#123;	<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//注意i为private	AA(int i)&#123;		this.i =i;	&#125;	String AA(long i) &#123;		this.i = i;		return  &quot;i = &quot; + this.i;	&#125;	&#125;</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>在其他类中,使用<code>new AA(10)</code>创建一个实例对象<code>test</code></p>
<p>因为<code>i</code>为<code>private</code>(仅类内能访问), 所以不能通过<code>test.i</code>在其他类中访问<code>i</code>；</p>
<p>但是可以通过调用<code>String AA(long i)函数</code>来<strong>间接修改</strong><code>i</code>的值！</p>
<p>因为AA函数位于类AA中, 可以访问i. 且权限为<code>package</code>，同一包的实例对象都可以调用</p>
</blockquote>
</li>
</ol>
<h4 id="4-5-Chapter-11-13"><a href="#4-5-Chapter-11-13" class="headerlink" title="4.5 Chapter 11-13"></a>4.5 Chapter 11-13</h4><ol>
<li><p>抽象类：<strong>含有</strong>抽象方法的类，可以有非抽象方法（包括构造方法）和实例字段，也可以是非抽象类的子类</p>
<p>与接口的区别：</p>
<p>1）接口不能有构造方法，抽象类可以有。</p>
<p>2）接口不能有方法体，抽象类可以有。</p>
<p>3）接口不能有静态方法，抽象类可以有。</p>
</li>
<li><p>接口可以继承多个父接口，而类只能继承一个父类</p>
<blockquote>
<p>不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？</p>
<p>但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。</p>
</blockquote>
</li>
<li><p>使用父类的引用变量指向子类实例，若父类的实例方法被覆盖，则调用子类的实例方法（多态性）；若没被覆盖，则调用子类的实例方法。</p>
</li>
</ol>
<h4 id="4-6-Chapter-19"><a href="#4-6-Chapter-19" class="headerlink" title="4.6 Chapter 19"></a>4.6 Chapter 19</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s2</span><span class="hljs-params">(T i)</span> </span>&#123;&#125; <span class="hljs-comment">//编译报错，类型变量T无法在静态上下文中被引用</span><br></code></pre></div></td></tr></table></figure>


<h4 id="4-7-Chapter-30"><a href="#4-7-Chapter-30" class="headerlink" title="4.7 Chapter 30"></a>4.7 Chapter 30</h4><ol>
<li>sleep不会释放锁，await会</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AC%94%E8%AE%B0/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">语言学习</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                  </div>
                
              </div>
                <p class="note note-warning">
              <strong>本文作者: </strong><a href="/">Henry Chi</a> <br>
              <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                </p>
                
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/31/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Markdown学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/31/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">C++学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"APjDJRCEtwETk2JqAx6lmCiS-gzGzoHsz","appKey":"NBAOoEsFe7YFr915DSzxn3BD","placeholder":"说点什么","path":"window.location.pathname","avatar":"md","meta":["nick"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
      <span>cwh</span>
      <i class="iconfont icon-love"></i>
      <span>wcy</span> <br>
      <span>Copyright © 2021</span></a>
          <a href="http://henrychi.top/" target="_blank" rel="nofollow noopener">
      <span>Henry Chi's Blog</span></a>    <br>
       
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>



  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
